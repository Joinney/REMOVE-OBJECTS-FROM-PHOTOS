import dedent from "dedent";
import require$$1 from "tty";
import require$$1$1 from "util";
import require$$0 from "os";
import require$$0$1 from "fs";
import require$$1$2 from "path";
import require$$3 from "crypto";
import { PostHog } from "posthog-node";
import nodeFsPromises from "node:fs/promises";
import nodePath__default from "node:path";
import crypto$2 from "node:crypto";
import { colors } from "consola/utils";
import consola from "consola";
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var typebox = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Type = exports2.JsonType = exports2.JavaScriptTypeBuilder = exports2.JsonTypeBuilder = exports2.TypeBuilder = exports2.TypeBuilderError = exports2.TransformEncodeBuilder = exports2.TransformDecodeBuilder = exports2.TemplateLiteralDslParser = exports2.TemplateLiteralGenerator = exports2.TemplateLiteralGeneratorError = exports2.TemplateLiteralFinite = exports2.TemplateLiteralFiniteError = exports2.TemplateLiteralParser = exports2.TemplateLiteralParserError = exports2.TemplateLiteralResolver = exports2.TemplateLiteralPattern = exports2.TemplateLiteralPatternError = exports2.UnionResolver = exports2.KeyArrayResolver = exports2.KeyArrayResolverError = exports2.KeyResolver = exports2.ObjectMap = exports2.Intrinsic = exports2.IndexedAccessor = exports2.TypeClone = exports2.TypeExtends = exports2.TypeExtendsResult = exports2.TypeExtendsError = exports2.ExtendsUndefined = exports2.TypeGuard = exports2.TypeGuardUnknownTypeError = exports2.ValueGuard = exports2.FormatRegistry = exports2.TypeBoxError = exports2.TypeRegistry = exports2.PatternStringExact = exports2.PatternNumberExact = exports2.PatternBooleanExact = exports2.PatternString = exports2.PatternNumber = exports2.PatternBoolean = exports2.Kind = exports2.Hint = exports2.Optional = exports2.Readonly = exports2.Transform = void 0;
  exports2.Transform = Symbol.for("TypeBox.Transform");
  exports2.Readonly = Symbol.for("TypeBox.Readonly");
  exports2.Optional = Symbol.for("TypeBox.Optional");
  exports2.Hint = Symbol.for("TypeBox.Hint");
  exports2.Kind = Symbol.for("TypeBox.Kind");
  exports2.PatternBoolean = "(true|false)";
  exports2.PatternNumber = "(0|[1-9][0-9]*)";
  exports2.PatternString = "(.*)";
  exports2.PatternBooleanExact = `^${exports2.PatternBoolean}$`;
  exports2.PatternNumberExact = `^${exports2.PatternNumber}$`;
  exports2.PatternStringExact = `^${exports2.PatternString}$`;
  var TypeRegistry;
  (function(TypeRegistry2) {
    const map = /* @__PURE__ */ new Map();
    function Entries() {
      return new Map(map);
    }
    TypeRegistry2.Entries = Entries;
    function Clear() {
      return map.clear();
    }
    TypeRegistry2.Clear = Clear;
    function Delete(kind) {
      return map.delete(kind);
    }
    TypeRegistry2.Delete = Delete;
    function Has(kind) {
      return map.has(kind);
    }
    TypeRegistry2.Has = Has;
    function Set2(kind, func) {
      map.set(kind, func);
    }
    TypeRegistry2.Set = Set2;
    function Get(kind) {
      return map.get(kind);
    }
    TypeRegistry2.Get = Get;
  })(TypeRegistry || (exports2.TypeRegistry = TypeRegistry = {}));
  class TypeBoxError extends Error {
    constructor(message) {
      super(message);
    }
  }
  exports2.TypeBoxError = TypeBoxError;
  var FormatRegistry;
  (function(FormatRegistry2) {
    const map = /* @__PURE__ */ new Map();
    function Entries() {
      return new Map(map);
    }
    FormatRegistry2.Entries = Entries;
    function Clear() {
      return map.clear();
    }
    FormatRegistry2.Clear = Clear;
    function Delete(format) {
      return map.delete(format);
    }
    FormatRegistry2.Delete = Delete;
    function Has(format) {
      return map.has(format);
    }
    FormatRegistry2.Has = Has;
    function Set2(format, func) {
      map.set(format, func);
    }
    FormatRegistry2.Set = Set2;
    function Get(format) {
      return map.get(format);
    }
    FormatRegistry2.Get = Get;
  })(FormatRegistry || (exports2.FormatRegistry = FormatRegistry = {}));
  var ValueGuard;
  (function(ValueGuard2) {
    function IsArray2(value2) {
      return Array.isArray(value2);
    }
    ValueGuard2.IsArray = IsArray2;
    function IsBigInt2(value2) {
      return typeof value2 === "bigint";
    }
    ValueGuard2.IsBigInt = IsBigInt2;
    function IsBoolean2(value2) {
      return typeof value2 === "boolean";
    }
    ValueGuard2.IsBoolean = IsBoolean2;
    function IsDate2(value2) {
      return value2 instanceof globalThis.Date;
    }
    ValueGuard2.IsDate = IsDate2;
    function IsNull2(value2) {
      return value2 === null;
    }
    ValueGuard2.IsNull = IsNull2;
    function IsNumber2(value2) {
      return typeof value2 === "number";
    }
    ValueGuard2.IsNumber = IsNumber2;
    function IsObject2(value2) {
      return typeof value2 === "object" && value2 !== null;
    }
    ValueGuard2.IsObject = IsObject2;
    function IsString2(value2) {
      return typeof value2 === "string";
    }
    ValueGuard2.IsString = IsString2;
    function IsUint8Array2(value2) {
      return value2 instanceof globalThis.Uint8Array;
    }
    ValueGuard2.IsUint8Array = IsUint8Array2;
    function IsUndefined2(value2) {
      return value2 === void 0;
    }
    ValueGuard2.IsUndefined = IsUndefined2;
  })(ValueGuard || (exports2.ValueGuard = ValueGuard = {}));
  class TypeGuardUnknownTypeError extends TypeBoxError {
  }
  exports2.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;
  var TypeGuard;
  (function(TypeGuard2) {
    function IsPattern(value2) {
      try {
        new RegExp(value2);
        return true;
      } catch {
        return false;
      }
    }
    function IsControlCharacterFree(value2) {
      if (!ValueGuard.IsString(value2))
        return false;
      for (let i2 = 0; i2 < value2.length; i2++) {
        const code = value2.charCodeAt(i2);
        if (code >= 7 && code <= 13 || code === 27 || code === 127) {
          return false;
        }
      }
      return true;
    }
    function IsAdditionalProperties(value2) {
      return IsOptionalBoolean(value2) || TSchema(value2);
    }
    function IsOptionalBigInt(value2) {
      return ValueGuard.IsUndefined(value2) || ValueGuard.IsBigInt(value2);
    }
    function IsOptionalNumber(value2) {
      return ValueGuard.IsUndefined(value2) || ValueGuard.IsNumber(value2);
    }
    function IsOptionalBoolean(value2) {
      return ValueGuard.IsUndefined(value2) || ValueGuard.IsBoolean(value2);
    }
    function IsOptionalString(value2) {
      return ValueGuard.IsUndefined(value2) || ValueGuard.IsString(value2);
    }
    function IsOptionalPattern(value2) {
      return ValueGuard.IsUndefined(value2) || ValueGuard.IsString(value2) && IsControlCharacterFree(value2) && IsPattern(value2);
    }
    function IsOptionalFormat(value2) {
      return ValueGuard.IsUndefined(value2) || ValueGuard.IsString(value2) && IsControlCharacterFree(value2);
    }
    function IsOptionalSchema(value2) {
      return ValueGuard.IsUndefined(value2) || TSchema(value2);
    }
    function TAny2(schema) {
      return TKindOf(schema, "Any") && IsOptionalString(schema.$id);
    }
    TypeGuard2.TAny = TAny2;
    function TArray2(schema) {
      return TKindOf(schema, "Array") && schema.type === "array" && IsOptionalString(schema.$id) && TSchema(schema.items) && IsOptionalNumber(schema.minItems) && IsOptionalNumber(schema.maxItems) && IsOptionalBoolean(schema.uniqueItems) && IsOptionalSchema(schema.contains) && IsOptionalNumber(schema.minContains) && IsOptionalNumber(schema.maxContains);
    }
    TypeGuard2.TArray = TArray2;
    function TAsyncIterator2(schema) {
      return TKindOf(schema, "AsyncIterator") && schema.type === "AsyncIterator" && IsOptionalString(schema.$id) && TSchema(schema.items);
    }
    TypeGuard2.TAsyncIterator = TAsyncIterator2;
    function TBigInt2(schema) {
      return TKindOf(schema, "BigInt") && schema.type === "bigint" && IsOptionalString(schema.$id) && IsOptionalBigInt(schema.exclusiveMaximum) && IsOptionalBigInt(schema.exclusiveMinimum) && IsOptionalBigInt(schema.maximum) && IsOptionalBigInt(schema.minimum) && IsOptionalBigInt(schema.multipleOf);
    }
    TypeGuard2.TBigInt = TBigInt2;
    function TBoolean2(schema) {
      return TKindOf(schema, "Boolean") && schema.type === "boolean" && IsOptionalString(schema.$id);
    }
    TypeGuard2.TBoolean = TBoolean2;
    function TConstructor2(schema) {
      return TKindOf(schema, "Constructor") && schema.type === "Constructor" && IsOptionalString(schema.$id) && ValueGuard.IsArray(schema.parameters) && schema.parameters.every((schema2) => TSchema(schema2)) && TSchema(schema.returns);
    }
    TypeGuard2.TConstructor = TConstructor2;
    function TDate2(schema) {
      return TKindOf(schema, "Date") && schema.type === "Date" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.exclusiveMaximumTimestamp) && IsOptionalNumber(schema.exclusiveMinimumTimestamp) && IsOptionalNumber(schema.maximumTimestamp) && IsOptionalNumber(schema.minimumTimestamp) && IsOptionalNumber(schema.multipleOfTimestamp);
    }
    TypeGuard2.TDate = TDate2;
    function TFunction2(schema) {
      return TKindOf(schema, "Function") && schema.type === "Function" && IsOptionalString(schema.$id) && ValueGuard.IsArray(schema.parameters) && schema.parameters.every((schema2) => TSchema(schema2)) && TSchema(schema.returns);
    }
    TypeGuard2.TFunction = TFunction2;
    function TInteger2(schema) {
      return TKindOf(schema, "Integer") && schema.type === "integer" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.exclusiveMaximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.multipleOf);
    }
    TypeGuard2.TInteger = TInteger2;
    function TIntersect2(schema) {
      return TKindOf(schema, "Intersect") && (ValueGuard.IsString(schema.type) && schema.type !== "object" ? false : true) && ValueGuard.IsArray(schema.allOf) && schema.allOf.every((schema2) => TSchema(schema2) && !TTransform(schema2)) && IsOptionalString(schema.type) && (IsOptionalBoolean(schema.unevaluatedProperties) || IsOptionalSchema(schema.unevaluatedProperties)) && IsOptionalString(schema.$id);
    }
    TypeGuard2.TIntersect = TIntersect2;
    function TIterator2(schema) {
      return TKindOf(schema, "Iterator") && schema.type === "Iterator" && IsOptionalString(schema.$id) && TSchema(schema.items);
    }
    TypeGuard2.TIterator = TIterator2;
    function TKindOf(schema, kind) {
      return TKind2(schema) && schema[exports2.Kind] === kind;
    }
    TypeGuard2.TKindOf = TKindOf;
    function TKind2(schema) {
      return ValueGuard.IsObject(schema) && exports2.Kind in schema && ValueGuard.IsString(schema[exports2.Kind]);
    }
    TypeGuard2.TKind = TKind2;
    function TLiteralString(schema) {
      return TLiteral2(schema) && ValueGuard.IsString(schema.const);
    }
    TypeGuard2.TLiteralString = TLiteralString;
    function TLiteralNumber(schema) {
      return TLiteral2(schema) && ValueGuard.IsNumber(schema.const);
    }
    TypeGuard2.TLiteralNumber = TLiteralNumber;
    function TLiteralBoolean(schema) {
      return TLiteral2(schema) && ValueGuard.IsBoolean(schema.const);
    }
    TypeGuard2.TLiteralBoolean = TLiteralBoolean;
    function TLiteral2(schema) {
      return TKindOf(schema, "Literal") && IsOptionalString(schema.$id) && (ValueGuard.IsBoolean(schema.const) || ValueGuard.IsNumber(schema.const) || ValueGuard.IsString(schema.const));
    }
    TypeGuard2.TLiteral = TLiteral2;
    function TNever2(schema) {
      return TKindOf(schema, "Never") && ValueGuard.IsObject(schema.not) && Object.getOwnPropertyNames(schema.not).length === 0;
    }
    TypeGuard2.TNever = TNever2;
    function TNot2(schema) {
      return TKindOf(schema, "Not") && TSchema(schema.not);
    }
    TypeGuard2.TNot = TNot2;
    function TNull2(schema) {
      return TKindOf(schema, "Null") && schema.type === "null" && IsOptionalString(schema.$id);
    }
    TypeGuard2.TNull = TNull2;
    function TNumber2(schema) {
      return TKindOf(schema, "Number") && schema.type === "number" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.exclusiveMaximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.multipleOf);
    }
    TypeGuard2.TNumber = TNumber2;
    function TObject2(schema) {
      return TKindOf(schema, "Object") && schema.type === "object" && IsOptionalString(schema.$id) && ValueGuard.IsObject(schema.properties) && IsAdditionalProperties(schema.additionalProperties) && IsOptionalNumber(schema.minProperties) && IsOptionalNumber(schema.maxProperties) && Object.entries(schema.properties).every(([key, schema2]) => IsControlCharacterFree(key) && TSchema(schema2));
    }
    TypeGuard2.TObject = TObject2;
    function TPromise2(schema) {
      return TKindOf(schema, "Promise") && schema.type === "Promise" && IsOptionalString(schema.$id) && TSchema(schema.item);
    }
    TypeGuard2.TPromise = TPromise2;
    function TRecord2(schema) {
      return TKindOf(schema, "Record") && schema.type === "object" && IsOptionalString(schema.$id) && IsAdditionalProperties(schema.additionalProperties) && ValueGuard.IsObject(schema.patternProperties) && ((schema2) => {
        const keys = Object.getOwnPropertyNames(schema2.patternProperties);
        return keys.length === 1 && IsPattern(keys[0]) && ValueGuard.IsObject(schema2.patternProperties) && TSchema(schema2.patternProperties[keys[0]]);
      })(schema);
    }
    TypeGuard2.TRecord = TRecord2;
    function TRecursive(schema) {
      return ValueGuard.IsObject(schema) && exports2.Hint in schema && schema[exports2.Hint] === "Recursive";
    }
    TypeGuard2.TRecursive = TRecursive;
    function TRef2(schema) {
      return TKindOf(schema, "Ref") && IsOptionalString(schema.$id) && ValueGuard.IsString(schema.$ref);
    }
    TypeGuard2.TRef = TRef2;
    function TString2(schema) {
      return TKindOf(schema, "String") && schema.type === "string" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minLength) && IsOptionalNumber(schema.maxLength) && IsOptionalPattern(schema.pattern) && IsOptionalFormat(schema.format);
    }
    TypeGuard2.TString = TString2;
    function TSymbol2(schema) {
      return TKindOf(schema, "Symbol") && schema.type === "symbol" && IsOptionalString(schema.$id);
    }
    TypeGuard2.TSymbol = TSymbol2;
    function TTemplateLiteral2(schema) {
      return TKindOf(schema, "TemplateLiteral") && schema.type === "string" && ValueGuard.IsString(schema.pattern) && schema.pattern[0] === "^" && schema.pattern[schema.pattern.length - 1] === "$";
    }
    TypeGuard2.TTemplateLiteral = TTemplateLiteral2;
    function TThis2(schema) {
      return TKindOf(schema, "This") && IsOptionalString(schema.$id) && ValueGuard.IsString(schema.$ref);
    }
    TypeGuard2.TThis = TThis2;
    function TTransform(schema) {
      return ValueGuard.IsObject(schema) && exports2.Transform in schema;
    }
    TypeGuard2.TTransform = TTransform;
    function TTuple2(schema) {
      return TKindOf(schema, "Tuple") && schema.type === "array" && IsOptionalString(schema.$id) && ValueGuard.IsNumber(schema.minItems) && ValueGuard.IsNumber(schema.maxItems) && schema.minItems === schema.maxItems && // empty
      (ValueGuard.IsUndefined(schema.items) && ValueGuard.IsUndefined(schema.additionalItems) && schema.minItems === 0 || ValueGuard.IsArray(schema.items) && schema.items.every((schema2) => TSchema(schema2)));
    }
    TypeGuard2.TTuple = TTuple2;
    function TUndefined2(schema) {
      return TKindOf(schema, "Undefined") && schema.type === "undefined" && IsOptionalString(schema.$id);
    }
    TypeGuard2.TUndefined = TUndefined2;
    function TUnionLiteral(schema) {
      return TUnion2(schema) && schema.anyOf.every((schema2) => TLiteralString(schema2) || TLiteralNumber(schema2));
    }
    TypeGuard2.TUnionLiteral = TUnionLiteral;
    function TUnion2(schema) {
      return TKindOf(schema, "Union") && IsOptionalString(schema.$id) && ValueGuard.IsObject(schema) && ValueGuard.IsArray(schema.anyOf) && schema.anyOf.every((schema2) => TSchema(schema2));
    }
    TypeGuard2.TUnion = TUnion2;
    function TUint8Array2(schema) {
      return TKindOf(schema, "Uint8Array") && schema.type === "Uint8Array" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minByteLength) && IsOptionalNumber(schema.maxByteLength);
    }
    TypeGuard2.TUint8Array = TUint8Array2;
    function TUnknown2(schema) {
      return TKindOf(schema, "Unknown") && IsOptionalString(schema.$id);
    }
    TypeGuard2.TUnknown = TUnknown2;
    function TUnsafe(schema) {
      return TKindOf(schema, "Unsafe");
    }
    TypeGuard2.TUnsafe = TUnsafe;
    function TVoid2(schema) {
      return TKindOf(schema, "Void") && schema.type === "void" && IsOptionalString(schema.$id);
    }
    TypeGuard2.TVoid = TVoid2;
    function TReadonly(schema) {
      return ValueGuard.IsObject(schema) && schema[exports2.Readonly] === "Readonly";
    }
    TypeGuard2.TReadonly = TReadonly;
    function TOptional(schema) {
      return ValueGuard.IsObject(schema) && schema[exports2.Optional] === "Optional";
    }
    TypeGuard2.TOptional = TOptional;
    function TSchema(schema) {
      return ValueGuard.IsObject(schema) && (TAny2(schema) || TArray2(schema) || TBoolean2(schema) || TBigInt2(schema) || TAsyncIterator2(schema) || TConstructor2(schema) || TDate2(schema) || TFunction2(schema) || TInteger2(schema) || TIntersect2(schema) || TIterator2(schema) || TLiteral2(schema) || TNever2(schema) || TNot2(schema) || TNull2(schema) || TNumber2(schema) || TObject2(schema) || TPromise2(schema) || TRecord2(schema) || TRef2(schema) || TString2(schema) || TSymbol2(schema) || TTemplateLiteral2(schema) || TThis2(schema) || TTuple2(schema) || TUndefined2(schema) || TUnion2(schema) || TUint8Array2(schema) || TUnknown2(schema) || TUnsafe(schema) || TVoid2(schema) || TKind2(schema) && TypeRegistry.Has(schema[exports2.Kind]));
    }
    TypeGuard2.TSchema = TSchema;
  })(TypeGuard || (exports2.TypeGuard = TypeGuard = {}));
  var ExtendsUndefined;
  (function(ExtendsUndefined2) {
    function Check2(schema) {
      return schema[exports2.Kind] === "Intersect" ? schema.allOf.every((schema2) => Check2(schema2)) : schema[exports2.Kind] === "Union" ? schema.anyOf.some((schema2) => Check2(schema2)) : schema[exports2.Kind] === "Undefined" ? true : schema[exports2.Kind] === "Not" ? !Check2(schema.not) : false;
    }
    ExtendsUndefined2.Check = Check2;
  })(ExtendsUndefined || (exports2.ExtendsUndefined = ExtendsUndefined = {}));
  class TypeExtendsError extends TypeBoxError {
  }
  exports2.TypeExtendsError = TypeExtendsError;
  var TypeExtendsResult;
  (function(TypeExtendsResult2) {
    TypeExtendsResult2[TypeExtendsResult2["Union"] = 0] = "Union";
    TypeExtendsResult2[TypeExtendsResult2["True"] = 1] = "True";
    TypeExtendsResult2[TypeExtendsResult2["False"] = 2] = "False";
  })(TypeExtendsResult || (exports2.TypeExtendsResult = TypeExtendsResult = {}));
  var TypeExtends;
  (function(TypeExtends2) {
    function IntoBooleanResult(result) {
      return result === TypeExtendsResult.False ? result : TypeExtendsResult.True;
    }
    function Throw(message) {
      throw new TypeExtendsError(message);
    }
    function IsStructuralRight(right) {
      return TypeGuard.TNever(right) || TypeGuard.TIntersect(right) || TypeGuard.TUnion(right) || TypeGuard.TUnknown(right) || TypeGuard.TAny(right);
    }
    function StructuralRight(left, right) {
      return TypeGuard.TNever(right) ? TNeverRight() : TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TUnknown(right) ? TUnknownRight() : TypeGuard.TAny(right) ? TAnyRight() : Throw("StructuralRight");
    }
    function TAnyRight(left, right) {
      return TypeExtendsResult.True;
    }
    function TAny2(left, right) {
      return TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) && right.anyOf.some((schema) => TypeGuard.TAny(schema) || TypeGuard.TUnknown(schema)) ? TypeExtendsResult.True : TypeGuard.TUnion(right) ? TypeExtendsResult.Union : TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeGuard.TAny(right) ? TypeExtendsResult.True : TypeExtendsResult.Union;
    }
    function TArrayRight(left, right) {
      return TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeGuard.TNever(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TArray2(left, right) {
      return TypeGuard.TObject(right) && IsObjectArrayLike(right) ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TArray(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit2(left.items, right.items));
    }
    function TAsyncIterator2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TAsyncIterator(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit2(left.items, right.items));
    }
    function TBigInt2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TBigInt(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TBooleanRight(left, right) {
      return TypeGuard.TLiteral(left) && ValueGuard.IsBoolean(left.const) ? TypeExtendsResult.True : TypeGuard.TBoolean(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TBoolean2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TBoolean(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TConstructor2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TConstructor(right) ? TypeExtendsResult.False : left.parameters.length > right.parameters.length ? TypeExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit2(right.parameters[index], schema)) === TypeExtendsResult.True) ? TypeExtendsResult.False : IntoBooleanResult(Visit2(left.returns, right.returns));
    }
    function TDate2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TDate(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TFunction2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TFunction(right) ? TypeExtendsResult.False : left.parameters.length > right.parameters.length ? TypeExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit2(right.parameters[index], schema)) === TypeExtendsResult.True) ? TypeExtendsResult.False : IntoBooleanResult(Visit2(left.returns, right.returns));
    }
    function TIntegerRight(left, right) {
      return TypeGuard.TLiteral(left) && ValueGuard.IsNumber(left.const) ? TypeExtendsResult.True : TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TInteger2(left, right) {
      return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeExtendsResult.False;
    }
    function TIntersectRight(left, right) {
      return right.allOf.every((schema) => Visit2(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TIntersect2(left, right) {
      return left.allOf.some((schema) => Visit2(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TIterator2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TIterator(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit2(left.items, right.items));
    }
    function TLiteral2(left, right) {
      return TypeGuard.TLiteral(right) && right.const === left.const ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TString(right) ? TStringRight(left) : TypeGuard.TNumber(right) ? TNumberRight(left) : TypeGuard.TInteger(right) ? TIntegerRight(left) : TypeGuard.TBoolean(right) ? TBooleanRight(left) : TypeExtendsResult.False;
    }
    function TNeverRight(left, right) {
      return TypeExtendsResult.False;
    }
    function TNever2(left, right) {
      return TypeExtendsResult.True;
    }
    function UnwrapTNot(schema) {
      let [current, depth] = [schema, 0];
      while (true) {
        if (!TypeGuard.TNot(current))
          break;
        current = current.not;
        depth += 1;
      }
      return depth % 2 === 0 ? current : exports2.Type.Unknown();
    }
    function TNot2(left, right) {
      return TypeGuard.TNot(left) ? Visit2(UnwrapTNot(left), right) : TypeGuard.TNot(right) ? Visit2(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
    }
    function TNull2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TNull(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TNumberRight(left, right) {
      return TypeGuard.TLiteralNumber(left) ? TypeExtendsResult.True : TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TNumber2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function IsObjectPropertyCount(schema, count) {
      return Object.getOwnPropertyNames(schema.properties).length === count;
    }
    function IsObjectStringLike(schema) {
      return IsObjectArrayLike(schema);
    }
    function IsObjectSymbolLike(schema) {
      return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && TypeGuard.TUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (TypeGuard.TString(schema.properties.description.anyOf[0]) && TypeGuard.TUndefined(schema.properties.description.anyOf[1]) || TypeGuard.TString(schema.properties.description.anyOf[1]) && TypeGuard.TUndefined(schema.properties.description.anyOf[0]));
    }
    function IsObjectNumberLike(schema) {
      return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectBooleanLike(schema) {
      return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectBigIntLike(schema) {
      return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectDateLike(schema) {
      return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectUint8ArrayLike(schema) {
      return IsObjectArrayLike(schema);
    }
    function IsObjectFunctionLike(schema) {
      const length = exports2.Type.Number();
      return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit2(schema.properties["length"], length)) === TypeExtendsResult.True;
    }
    function IsObjectConstructorLike(schema) {
      return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectArrayLike(schema) {
      const length = exports2.Type.Number();
      return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit2(schema.properties["length"], length)) === TypeExtendsResult.True;
    }
    function IsObjectPromiseLike(schema) {
      const then = exports2.Type.Function([exports2.Type.Any()], exports2.Type.Any());
      return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit2(schema.properties["then"], then)) === TypeExtendsResult.True;
    }
    function Property(left, right) {
      return Visit2(left, right) === TypeExtendsResult.False ? TypeExtendsResult.False : TypeGuard.TOptional(left) && !TypeGuard.TOptional(right) ? TypeExtendsResult.False : TypeExtendsResult.True;
    }
    function TObjectRight(left, right) {
      return TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeGuard.TNever(left) || TypeGuard.TLiteralString(left) && IsObjectStringLike(right) || TypeGuard.TLiteralNumber(left) && IsObjectNumberLike(right) || TypeGuard.TLiteralBoolean(left) && IsObjectBooleanLike(right) || TypeGuard.TSymbol(left) && IsObjectSymbolLike(right) || TypeGuard.TBigInt(left) && IsObjectBigIntLike(right) || TypeGuard.TString(left) && IsObjectStringLike(right) || TypeGuard.TSymbol(left) && IsObjectSymbolLike(right) || TypeGuard.TNumber(left) && IsObjectNumberLike(right) || TypeGuard.TInteger(left) && IsObjectNumberLike(right) || TypeGuard.TBoolean(left) && IsObjectBooleanLike(right) || TypeGuard.TUint8Array(left) && IsObjectUint8ArrayLike(right) || TypeGuard.TDate(left) && IsObjectDateLike(right) || TypeGuard.TConstructor(left) && IsObjectConstructorLike(right) || TypeGuard.TFunction(left) && IsObjectFunctionLike(right) ? TypeExtendsResult.True : TypeGuard.TRecord(left) && TypeGuard.TString(RecordKey(left)) ? (() => {
        return right[exports2.Hint] === "Record" ? TypeExtendsResult.True : TypeExtendsResult.False;
      })() : TypeGuard.TRecord(left) && TypeGuard.TNumber(RecordKey(left)) ? (() => {
        return IsObjectPropertyCount(right, 0) ? TypeExtendsResult.True : TypeExtendsResult.False;
      })() : TypeExtendsResult.False;
    }
    function TObject2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : !TypeGuard.TObject(right) ? TypeExtendsResult.False : (() => {
        for (const key of Object.getOwnPropertyNames(right.properties)) {
          if (!(key in left.properties) && !TypeGuard.TOptional(right.properties[key])) {
            return TypeExtendsResult.False;
          }
          if (TypeGuard.TOptional(right.properties[key])) {
            return TypeExtendsResult.True;
          }
          if (Property(left.properties[key], right.properties[key]) === TypeExtendsResult.False) {
            return TypeExtendsResult.False;
          }
        }
        return TypeExtendsResult.True;
      })();
    }
    function TPromise2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) && IsObjectPromiseLike(right) ? TypeExtendsResult.True : !TypeGuard.TPromise(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit2(left.item, right.item));
    }
    function RecordKey(schema) {
      return exports2.PatternNumberExact in schema.patternProperties ? exports2.Type.Number() : exports2.PatternStringExact in schema.patternProperties ? exports2.Type.String() : Throw("Unknown record key pattern");
    }
    function RecordValue(schema) {
      return exports2.PatternNumberExact in schema.patternProperties ? schema.patternProperties[exports2.PatternNumberExact] : exports2.PatternStringExact in schema.patternProperties ? schema.patternProperties[exports2.PatternStringExact] : Throw("Unable to get record value schema");
    }
    function TRecordRight(left, right) {
      const [Key, Value2] = [RecordKey(right), RecordValue(right)];
      return TypeGuard.TLiteralString(left) && TypeGuard.TNumber(Key) && IntoBooleanResult(Visit2(left, Value2)) === TypeExtendsResult.True ? TypeExtendsResult.True : TypeGuard.TUint8Array(left) && TypeGuard.TNumber(Key) ? Visit2(left, Value2) : TypeGuard.TString(left) && TypeGuard.TNumber(Key) ? Visit2(left, Value2) : TypeGuard.TArray(left) && TypeGuard.TNumber(Key) ? Visit2(left, Value2) : TypeGuard.TObject(left) ? (() => {
        for (const key of Object.getOwnPropertyNames(left.properties)) {
          if (Property(Value2, left.properties[key]) === TypeExtendsResult.False) {
            return TypeExtendsResult.False;
          }
        }
        return TypeExtendsResult.True;
      })() : TypeExtendsResult.False;
    }
    function TRecord2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TRecord(right) ? TypeExtendsResult.False : Visit2(RecordValue(left), RecordValue(right));
    }
    function TStringRight(left, right) {
      return TypeGuard.TLiteral(left) && ValueGuard.IsString(left.const) ? TypeExtendsResult.True : TypeGuard.TString(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TString2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TString(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TSymbol2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TSymbol(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TTemplateLiteral2(left, right) {
      return TypeGuard.TTemplateLiteral(left) ? Visit2(TemplateLiteralResolver.Resolve(left), right) : TypeGuard.TTemplateLiteral(right) ? Visit2(left, TemplateLiteralResolver.Resolve(right)) : Throw("Invalid fallthrough for TemplateLiteral");
    }
    function IsArrayOfTuple(left, right) {
      return TypeGuard.TArray(right) && left.items !== void 0 && left.items.every((schema) => Visit2(schema, right.items) === TypeExtendsResult.True);
    }
    function TTupleRight(left, right) {
      return TypeGuard.TNever(left) ? TypeExtendsResult.True : TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeExtendsResult.False;
    }
    function TTuple2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) && IsObjectArrayLike(right) ? TypeExtendsResult.True : TypeGuard.TArray(right) && IsArrayOfTuple(left, right) ? TypeExtendsResult.True : !TypeGuard.TTuple(right) ? TypeExtendsResult.False : ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items) || !ValueGuard.IsUndefined(left.items) && ValueGuard.IsUndefined(right.items) ? TypeExtendsResult.False : ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items) ? TypeExtendsResult.True : left.items.every((schema, index) => Visit2(schema, right.items[index]) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TUint8Array2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TUint8Array(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TUndefined2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TVoid(right) ? VoidRight(left) : TypeGuard.TUndefined(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TUnionRight(left, right) {
      return right.anyOf.some((schema) => Visit2(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TUnion2(left, right) {
      return left.anyOf.every((schema) => Visit2(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TUnknownRight(left, right) {
      return TypeExtendsResult.True;
    }
    function TUnknown2(left, right) {
      return TypeGuard.TNever(right) ? TNeverRight() : TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TAny(right) ? TAnyRight() : TypeGuard.TString(right) ? TStringRight(left) : TypeGuard.TNumber(right) ? TNumberRight(left) : TypeGuard.TInteger(right) ? TIntegerRight(left) : TypeGuard.TBoolean(right) ? TBooleanRight(left) : TypeGuard.TArray(right) ? TArrayRight(left) : TypeGuard.TTuple(right) ? TTupleRight(left) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function VoidRight(left, right) {
      return TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TVoid2(left, right) {
      return TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TUnknown(right) ? TUnknownRight() : TypeGuard.TAny(right) ? TAnyRight() : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TVoid(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function Visit2(left, right) {
      return (
        // resolvable
        TypeGuard.TTemplateLiteral(left) || TypeGuard.TTemplateLiteral(right) ? TTemplateLiteral2(left, right) : TypeGuard.TNot(left) || TypeGuard.TNot(right) ? TNot2(left, right) : (
          // standard
          TypeGuard.TAny(left) ? TAny2(left, right) : TypeGuard.TArray(left) ? TArray2(left, right) : TypeGuard.TBigInt(left) ? TBigInt2(left, right) : TypeGuard.TBoolean(left) ? TBoolean2(left, right) : TypeGuard.TAsyncIterator(left) ? TAsyncIterator2(left, right) : TypeGuard.TConstructor(left) ? TConstructor2(left, right) : TypeGuard.TDate(left) ? TDate2(left, right) : TypeGuard.TFunction(left) ? TFunction2(left, right) : TypeGuard.TInteger(left) ? TInteger2(left, right) : TypeGuard.TIntersect(left) ? TIntersect2(left, right) : TypeGuard.TIterator(left) ? TIterator2(left, right) : TypeGuard.TLiteral(left) ? TLiteral2(left, right) : TypeGuard.TNever(left) ? TNever2() : TypeGuard.TNull(left) ? TNull2(left, right) : TypeGuard.TNumber(left) ? TNumber2(left, right) : TypeGuard.TObject(left) ? TObject2(left, right) : TypeGuard.TRecord(left) ? TRecord2(left, right) : TypeGuard.TString(left) ? TString2(left, right) : TypeGuard.TSymbol(left) ? TSymbol2(left, right) : TypeGuard.TTuple(left) ? TTuple2(left, right) : TypeGuard.TPromise(left) ? TPromise2(left, right) : TypeGuard.TUint8Array(left) ? TUint8Array2(left, right) : TypeGuard.TUndefined(left) ? TUndefined2(left, right) : TypeGuard.TUnion(left) ? TUnion2(left, right) : TypeGuard.TUnknown(left) ? TUnknown2(left, right) : TypeGuard.TVoid(left) ? TVoid2(left, right) : Throw(`Unknown left type operand '${left[exports2.Kind]}'`)
        )
      );
    }
    function Extends(left, right) {
      return Visit2(left, right);
    }
    TypeExtends2.Extends = Extends;
  })(TypeExtends || (exports2.TypeExtends = TypeExtends = {}));
  var TypeClone;
  (function(TypeClone2) {
    function ArrayType2(value2) {
      return value2.map((value3) => Visit2(value3));
    }
    function DateType2(value2) {
      return new Date(value2.getTime());
    }
    function Uint8ArrayType2(value2) {
      return new Uint8Array(value2);
    }
    function ObjectType2(value2) {
      const clonedProperties = Object.getOwnPropertyNames(value2).reduce((acc, key) => ({ ...acc, [key]: Visit2(value2[key]) }), {});
      const clonedSymbols = Object.getOwnPropertySymbols(value2).reduce((acc, key) => ({ ...acc, [key]: Visit2(value2[key]) }), {});
      return { ...clonedProperties, ...clonedSymbols };
    }
    function Visit2(value2) {
      return ValueGuard.IsArray(value2) ? ArrayType2(value2) : ValueGuard.IsDate(value2) ? DateType2(value2) : ValueGuard.IsUint8Array(value2) ? Uint8ArrayType2(value2) : ValueGuard.IsObject(value2) ? ObjectType2(value2) : value2;
    }
    function Rest(schemas) {
      return schemas.map((schema) => Type(schema));
    }
    TypeClone2.Rest = Rest;
    function Type(schema, options = {}) {
      return { ...Visit2(schema), ...options };
    }
    TypeClone2.Type = Type;
  })(TypeClone || (exports2.TypeClone = TypeClone = {}));
  var IndexedAccessor;
  (function(IndexedAccessor2) {
    function OptionalUnwrap(schema) {
      return schema.map((schema2) => {
        const { [exports2.Optional]: _, ...clone2 } = TypeClone.Type(schema2);
        return clone2;
      });
    }
    function IsIntersectOptional(schema) {
      return schema.every((schema2) => TypeGuard.TOptional(schema2));
    }
    function IsUnionOptional(schema) {
      return schema.some((schema2) => TypeGuard.TOptional(schema2));
    }
    function ResolveIntersect(schema) {
      return IsIntersectOptional(schema.allOf) ? exports2.Type.Optional(exports2.Type.Intersect(OptionalUnwrap(schema.allOf))) : schema;
    }
    function ResolveUnion(schema) {
      return IsUnionOptional(schema.anyOf) ? exports2.Type.Optional(exports2.Type.Union(OptionalUnwrap(schema.anyOf))) : schema;
    }
    function ResolveOptional(schema) {
      return schema[exports2.Kind] === "Intersect" ? ResolveIntersect(schema) : schema[exports2.Kind] === "Union" ? ResolveUnion(schema) : schema;
    }
    function TIntersect2(schema, key) {
      const resolved = schema.allOf.reduce((acc, schema2) => {
        const indexed = Visit2(schema2, key);
        return indexed[exports2.Kind] === "Never" ? acc : [...acc, indexed];
      }, []);
      return ResolveOptional(exports2.Type.Intersect(resolved));
    }
    function TUnion2(schema, key) {
      const resolved = schema.anyOf.map((schema2) => Visit2(schema2, key));
      return ResolveOptional(exports2.Type.Union(resolved));
    }
    function TObject2(schema, key) {
      const property = schema.properties[key];
      return ValueGuard.IsUndefined(property) ? exports2.Type.Never() : exports2.Type.Union([property]);
    }
    function TTuple2(schema, key) {
      const items = schema.items;
      if (ValueGuard.IsUndefined(items))
        return exports2.Type.Never();
      const element = items[key];
      if (ValueGuard.IsUndefined(element))
        return exports2.Type.Never();
      return element;
    }
    function Visit2(schema, key) {
      return schema[exports2.Kind] === "Intersect" ? TIntersect2(schema, key) : schema[exports2.Kind] === "Union" ? TUnion2(schema, key) : schema[exports2.Kind] === "Object" ? TObject2(schema, key) : schema[exports2.Kind] === "Tuple" ? TTuple2(schema, key) : exports2.Type.Never();
    }
    function Resolve(schema, keys, options = {}) {
      const resolved = keys.map((key) => Visit2(schema, key.toString()));
      return ResolveOptional(exports2.Type.Union(resolved, options));
    }
    IndexedAccessor2.Resolve = Resolve;
  })(IndexedAccessor || (exports2.IndexedAccessor = IndexedAccessor = {}));
  var Intrinsic;
  (function(Intrinsic2) {
    function Uncapitalize(value2) {
      const [first, rest] = [value2.slice(0, 1), value2.slice(1)];
      return `${first.toLowerCase()}${rest}`;
    }
    function Capitalize(value2) {
      const [first, rest] = [value2.slice(0, 1), value2.slice(1)];
      return `${first.toUpperCase()}${rest}`;
    }
    function Uppercase(value2) {
      return value2.toUpperCase();
    }
    function Lowercase(value2) {
      return value2.toLowerCase();
    }
    function IntrinsicTemplateLiteral(schema, mode) {
      const expression = TemplateLiteralParser.ParseExact(schema.pattern);
      const finite = TemplateLiteralFinite.Check(expression);
      if (!finite)
        return { ...schema, pattern: IntrinsicLiteral(schema.pattern, mode) };
      const strings = [...TemplateLiteralGenerator.Generate(expression)];
      const literals = strings.map((value2) => exports2.Type.Literal(value2));
      const mapped = IntrinsicRest(literals, mode);
      const union = exports2.Type.Union(mapped);
      return exports2.Type.TemplateLiteral([union]);
    }
    function IntrinsicLiteral(value2, mode) {
      return typeof value2 === "string" ? mode === "Uncapitalize" ? Uncapitalize(value2) : mode === "Capitalize" ? Capitalize(value2) : mode === "Uppercase" ? Uppercase(value2) : mode === "Lowercase" ? Lowercase(value2) : value2 : value2.toString();
    }
    function IntrinsicRest(schema, mode) {
      if (schema.length === 0)
        return [];
      const [L, ...R] = schema;
      return [Map2(L, mode), ...IntrinsicRest(R, mode)];
    }
    function Visit2(schema, mode) {
      return TypeGuard.TTemplateLiteral(schema) ? IntrinsicTemplateLiteral(schema, mode) : TypeGuard.TUnion(schema) ? exports2.Type.Union(IntrinsicRest(schema.anyOf, mode)) : TypeGuard.TLiteral(schema) ? exports2.Type.Literal(IntrinsicLiteral(schema.const, mode)) : schema;
    }
    function Map2(schema, mode) {
      return Visit2(schema, mode);
    }
    Intrinsic2.Map = Map2;
  })(Intrinsic || (exports2.Intrinsic = Intrinsic = {}));
  var ObjectMap;
  (function(ObjectMap2) {
    function TIntersect2(schema, callback) {
      return exports2.Type.Intersect(schema.allOf.map((inner) => Visit2(inner, callback)), { ...schema });
    }
    function TUnion2(schema, callback) {
      return exports2.Type.Union(schema.anyOf.map((inner) => Visit2(inner, callback)), { ...schema });
    }
    function TObject2(schema, callback) {
      return callback(schema);
    }
    function Visit2(schema, callback) {
      return schema[exports2.Kind] === "Intersect" ? TIntersect2(schema, callback) : schema[exports2.Kind] === "Union" ? TUnion2(schema, callback) : schema[exports2.Kind] === "Object" ? TObject2(schema, callback) : schema;
    }
    function Map2(schema, callback, options) {
      return { ...Visit2(TypeClone.Type(schema), callback), ...options };
    }
    ObjectMap2.Map = Map2;
  })(ObjectMap || (exports2.ObjectMap = ObjectMap = {}));
  var KeyResolver;
  (function(KeyResolver2) {
    function UnwrapPattern(key) {
      return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
    }
    function TIntersect2(schema, options) {
      return schema.allOf.reduce((acc, schema2) => [...acc, ...Visit2(schema2, options)], []);
    }
    function TUnion2(schema, options) {
      const sets = schema.anyOf.map((inner) => Visit2(inner, options));
      return [...sets.reduce((set, outer) => outer.map((key) => sets.every((inner) => inner.includes(key)) ? set.add(key) : set)[0], /* @__PURE__ */ new Set())];
    }
    function TObject2(schema, options) {
      return Object.getOwnPropertyNames(schema.properties);
    }
    function TRecord2(schema, options) {
      return options.includePatterns ? Object.getOwnPropertyNames(schema.patternProperties) : [];
    }
    function Visit2(schema, options) {
      return TypeGuard.TIntersect(schema) ? TIntersect2(schema, options) : TypeGuard.TUnion(schema) ? TUnion2(schema, options) : TypeGuard.TObject(schema) ? TObject2(schema) : TypeGuard.TRecord(schema) ? TRecord2(schema, options) : [];
    }
    function ResolveKeys(schema, options) {
      return [...new Set(Visit2(schema, options))];
    }
    KeyResolver2.ResolveKeys = ResolveKeys;
    function ResolvePattern(schema) {
      const keys = ResolveKeys(schema, { includePatterns: true });
      const pattern2 = keys.map((key) => `(${UnwrapPattern(key)})`);
      return `^(${pattern2.join("|")})$`;
    }
    KeyResolver2.ResolvePattern = ResolvePattern;
  })(KeyResolver || (exports2.KeyResolver = KeyResolver = {}));
  class KeyArrayResolverError extends TypeBoxError {
  }
  exports2.KeyArrayResolverError = KeyArrayResolverError;
  var KeyArrayResolver;
  (function(KeyArrayResolver2) {
    function Resolve(schema) {
      return Array.isArray(schema) ? schema : TypeGuard.TUnionLiteral(schema) ? schema.anyOf.map((schema2) => schema2.const.toString()) : TypeGuard.TLiteral(schema) ? [schema.const] : TypeGuard.TTemplateLiteral(schema) ? (() => {
        const expression = TemplateLiteralParser.ParseExact(schema.pattern);
        if (!TemplateLiteralFinite.Check(expression))
          throw new KeyArrayResolverError("Cannot resolve keys from infinite template expression");
        return [...TemplateLiteralGenerator.Generate(expression)];
      })() : [];
    }
    KeyArrayResolver2.Resolve = Resolve;
  })(KeyArrayResolver || (exports2.KeyArrayResolver = KeyArrayResolver = {}));
  var UnionResolver;
  (function(UnionResolver2) {
    function* TUnion2(union) {
      for (const schema of union.anyOf) {
        if (schema[exports2.Kind] === "Union") {
          yield* TUnion2(schema);
        } else {
          yield schema;
        }
      }
    }
    function Resolve(union) {
      return exports2.Type.Union([...TUnion2(union)], { ...union });
    }
    UnionResolver2.Resolve = Resolve;
  })(UnionResolver || (exports2.UnionResolver = UnionResolver = {}));
  class TemplateLiteralPatternError extends TypeBoxError {
  }
  exports2.TemplateLiteralPatternError = TemplateLiteralPatternError;
  var TemplateLiteralPattern;
  (function(TemplateLiteralPattern2) {
    function Throw(message) {
      throw new TemplateLiteralPatternError(message);
    }
    function Escape(value2) {
      return value2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function Visit2(schema, acc) {
      return TypeGuard.TTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : TypeGuard.TUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit2(schema2, acc)).join("|")})` : TypeGuard.TNumber(schema) ? `${acc}${exports2.PatternNumber}` : TypeGuard.TInteger(schema) ? `${acc}${exports2.PatternNumber}` : TypeGuard.TBigInt(schema) ? `${acc}${exports2.PatternNumber}` : TypeGuard.TString(schema) ? `${acc}${exports2.PatternString}` : TypeGuard.TLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : TypeGuard.TBoolean(schema) ? `${acc}${exports2.PatternBoolean}` : Throw(`Unexpected Kind '${schema[exports2.Kind]}'`);
    }
    function Create2(kinds) {
      return `^${kinds.map((schema) => Visit2(schema, "")).join("")}$`;
    }
    TemplateLiteralPattern2.Create = Create2;
  })(TemplateLiteralPattern || (exports2.TemplateLiteralPattern = TemplateLiteralPattern = {}));
  var TemplateLiteralResolver;
  (function(TemplateLiteralResolver2) {
    function Resolve(template) {
      const expression = TemplateLiteralParser.ParseExact(template.pattern);
      if (!TemplateLiteralFinite.Check(expression))
        return exports2.Type.String();
      const literals = [...TemplateLiteralGenerator.Generate(expression)].map((value2) => exports2.Type.Literal(value2));
      return exports2.Type.Union(literals);
    }
    TemplateLiteralResolver2.Resolve = Resolve;
  })(TemplateLiteralResolver || (exports2.TemplateLiteralResolver = TemplateLiteralResolver = {}));
  class TemplateLiteralParserError extends TypeBoxError {
  }
  exports2.TemplateLiteralParserError = TemplateLiteralParserError;
  var TemplateLiteralParser;
  (function(TemplateLiteralParser2) {
    function IsNonEscaped(pattern2, index, char) {
      return pattern2[index] === char && pattern2.charCodeAt(index - 1) !== 92;
    }
    function IsOpenParen(pattern2, index) {
      return IsNonEscaped(pattern2, index, "(");
    }
    function IsCloseParen(pattern2, index) {
      return IsNonEscaped(pattern2, index, ")");
    }
    function IsSeparator(pattern2, index) {
      return IsNonEscaped(pattern2, index, "|");
    }
    function IsGroup(pattern2) {
      if (!(IsOpenParen(pattern2, 0) && IsCloseParen(pattern2, pattern2.length - 1)))
        return false;
      let count = 0;
      for (let index = 0; index < pattern2.length; index++) {
        if (IsOpenParen(pattern2, index))
          count += 1;
        if (IsCloseParen(pattern2, index))
          count -= 1;
        if (count === 0 && index !== pattern2.length - 1)
          return false;
      }
      return true;
    }
    function InGroup(pattern2) {
      return pattern2.slice(1, pattern2.length - 1);
    }
    function IsPrecedenceOr(pattern2) {
      let count = 0;
      for (let index = 0; index < pattern2.length; index++) {
        if (IsOpenParen(pattern2, index))
          count += 1;
        if (IsCloseParen(pattern2, index))
          count -= 1;
        if (IsSeparator(pattern2, index) && count === 0)
          return true;
      }
      return false;
    }
    function IsPrecedenceAnd(pattern2) {
      for (let index = 0; index < pattern2.length; index++) {
        if (IsOpenParen(pattern2, index))
          return true;
      }
      return false;
    }
    function Or(pattern2) {
      let [count, start] = [0, 0];
      const expressions = [];
      for (let index = 0; index < pattern2.length; index++) {
        if (IsOpenParen(pattern2, index))
          count += 1;
        if (IsCloseParen(pattern2, index))
          count -= 1;
        if (IsSeparator(pattern2, index) && count === 0) {
          const range2 = pattern2.slice(start, index);
          if (range2.length > 0)
            expressions.push(Parse(range2));
          start = index + 1;
        }
      }
      const range = pattern2.slice(start);
      if (range.length > 0)
        expressions.push(Parse(range));
      if (expressions.length === 0)
        return { type: "const", const: "" };
      if (expressions.length === 1)
        return expressions[0];
      return { type: "or", expr: expressions };
    }
    function And(pattern2) {
      function Group(value2, index) {
        if (!IsOpenParen(value2, index))
          throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
        let count = 0;
        for (let scan = index; scan < value2.length; scan++) {
          if (IsOpenParen(value2, scan))
            count += 1;
          if (IsCloseParen(value2, scan))
            count -= 1;
          if (count === 0)
            return [index, scan];
        }
        throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
      }
      function Range(pattern3, index) {
        for (let scan = index; scan < pattern3.length; scan++) {
          if (IsOpenParen(pattern3, scan))
            return [index, scan];
        }
        return [index, pattern3.length];
      }
      const expressions = [];
      for (let index = 0; index < pattern2.length; index++) {
        if (IsOpenParen(pattern2, index)) {
          const [start, end] = Group(pattern2, index);
          const range = pattern2.slice(start, end + 1);
          expressions.push(Parse(range));
          index = end;
        } else {
          const [start, end] = Range(pattern2, index);
          const range = pattern2.slice(start, end);
          if (range.length > 0)
            expressions.push(Parse(range));
          index = end - 1;
        }
      }
      return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
    }
    function Parse(pattern2) {
      return IsGroup(pattern2) ? Parse(InGroup(pattern2)) : IsPrecedenceOr(pattern2) ? Or(pattern2) : IsPrecedenceAnd(pattern2) ? And(pattern2) : { type: "const", const: pattern2 };
    }
    TemplateLiteralParser2.Parse = Parse;
    function ParseExact(pattern2) {
      return Parse(pattern2.slice(1, pattern2.length - 1));
    }
    TemplateLiteralParser2.ParseExact = ParseExact;
  })(TemplateLiteralParser || (exports2.TemplateLiteralParser = TemplateLiteralParser = {}));
  class TemplateLiteralFiniteError extends TypeBoxError {
  }
  exports2.TemplateLiteralFiniteError = TemplateLiteralFiniteError;
  var TemplateLiteralFinite;
  (function(TemplateLiteralFinite2) {
    function Throw(message) {
      throw new TemplateLiteralFiniteError(message);
    }
    function IsNumber2(expression) {
      return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
    }
    function IsBoolean2(expression) {
      return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
    }
    function IsString2(expression) {
      return expression.type === "const" && expression.const === ".*";
    }
    function Check2(expression) {
      return IsBoolean2(expression) ? true : IsNumber2(expression) || IsString2(expression) ? false : expression.type === "and" ? expression.expr.every((expr) => Check2(expr)) : expression.type === "or" ? expression.expr.every((expr) => Check2(expr)) : expression.type === "const" ? true : Throw(`Unknown expression type`);
    }
    TemplateLiteralFinite2.Check = Check2;
  })(TemplateLiteralFinite || (exports2.TemplateLiteralFinite = TemplateLiteralFinite = {}));
  class TemplateLiteralGeneratorError extends TypeBoxError {
  }
  exports2.TemplateLiteralGeneratorError = TemplateLiteralGeneratorError;
  var TemplateLiteralGenerator;
  (function(TemplateLiteralGenerator2) {
    function* Reduce(buffer) {
      if (buffer.length === 1)
        return yield* buffer[0];
      for (const left of buffer[0]) {
        for (const right of Reduce(buffer.slice(1))) {
          yield `${left}${right}`;
        }
      }
    }
    function* And(expression) {
      return yield* Reduce(expression.expr.map((expr) => [...Generate(expr)]));
    }
    function* Or(expression) {
      for (const expr of expression.expr)
        yield* Generate(expr);
    }
    function* Const(expression) {
      return yield expression.const;
    }
    function* Generate(expression) {
      return expression.type === "and" ? yield* And(expression) : expression.type === "or" ? yield* Or(expression) : expression.type === "const" ? yield* Const(expression) : (() => {
        throw new TemplateLiteralGeneratorError("Unknown expression");
      })();
    }
    TemplateLiteralGenerator2.Generate = Generate;
  })(TemplateLiteralGenerator || (exports2.TemplateLiteralGenerator = TemplateLiteralGenerator = {}));
  var TemplateLiteralDslParser;
  (function(TemplateLiteralDslParser2) {
    function* ParseUnion(template) {
      const trim = template.trim().replace(/"|'/g, "");
      return trim === "boolean" ? yield exports2.Type.Boolean() : trim === "number" ? yield exports2.Type.Number() : trim === "bigint" ? yield exports2.Type.BigInt() : trim === "string" ? yield exports2.Type.String() : yield (() => {
        const literals = trim.split("|").map((literal) => exports2.Type.Literal(literal.trim()));
        return literals.length === 0 ? exports2.Type.Never() : literals.length === 1 ? literals[0] : exports2.Type.Union(literals);
      })();
    }
    function* ParseTerminal(template) {
      if (template[1] !== "{") {
        const L = exports2.Type.Literal("$");
        const R = ParseLiteral(template.slice(1));
        return yield* [L, ...R];
      }
      for (let i2 = 2; i2 < template.length; i2++) {
        if (template[i2] === "}") {
          const L = ParseUnion(template.slice(2, i2));
          const R = ParseLiteral(template.slice(i2 + 1));
          return yield* [...L, ...R];
        }
      }
      yield exports2.Type.Literal(template);
    }
    function* ParseLiteral(template) {
      for (let i2 = 0; i2 < template.length; i2++) {
        if (template[i2] === "$") {
          const L = exports2.Type.Literal(template.slice(0, i2));
          const R = ParseTerminal(template.slice(i2));
          return yield* [L, ...R];
        }
      }
      yield exports2.Type.Literal(template);
    }
    function Parse(template_dsl) {
      return [...ParseLiteral(template_dsl)];
    }
    TemplateLiteralDslParser2.Parse = Parse;
  })(TemplateLiteralDslParser || (exports2.TemplateLiteralDslParser = TemplateLiteralDslParser = {}));
  class TransformDecodeBuilder {
    constructor(schema) {
      this.schema = schema;
    }
    Decode(decode) {
      return new TransformEncodeBuilder(this.schema, decode);
    }
  }
  exports2.TransformDecodeBuilder = TransformDecodeBuilder;
  class TransformEncodeBuilder {
    constructor(schema, decode) {
      this.schema = schema;
      this.decode = decode;
    }
    Encode(encode) {
      const schema = TypeClone.Type(this.schema);
      return TypeGuard.TTransform(schema) ? (() => {
        const Encode = (value2) => schema[exports2.Transform].Encode(encode(value2));
        const Decode = (value2) => this.decode(schema[exports2.Transform].Decode(value2));
        const Codec = { Encode, Decode };
        return { ...schema, [exports2.Transform]: Codec };
      })() : (() => {
        const Codec = { Decode: this.decode, Encode: encode };
        return { ...schema, [exports2.Transform]: Codec };
      })();
    }
  }
  exports2.TransformEncodeBuilder = TransformEncodeBuilder;
  let TypeOrdinal = 0;
  class TypeBuilderError extends TypeBoxError {
  }
  exports2.TypeBuilderError = TypeBuilderError;
  class TypeBuilder {
    /** `[Internal]` Creates a schema without `static` and `params` types */
    Create(schema) {
      return schema;
    }
    /** `[Internal]` Throws a TypeBuilder error with the given message */
    Throw(message) {
      throw new TypeBuilderError(message);
    }
    /** `[Internal]` Discards property keys from the given record type */
    Discard(record, keys) {
      return keys.reduce((acc, key) => {
        const { [key]: _, ...rest } = acc;
        return rest;
      }, record);
    }
    /** `[Json]` Omits compositing symbols from this schema */
    Strict(schema) {
      return JSON.parse(JSON.stringify(schema));
    }
  }
  exports2.TypeBuilder = TypeBuilder;
  class JsonTypeBuilder extends TypeBuilder {
    // ------------------------------------------------------------------------
    // Modifiers
    // ------------------------------------------------------------------------
    /** `[Json]` Creates a Readonly and Optional property */
    ReadonlyOptional(schema) {
      return this.Readonly(this.Optional(schema));
    }
    /** `[Json]` Creates a Readonly property */
    Readonly(schema) {
      return { ...TypeClone.Type(schema), [exports2.Readonly]: "Readonly" };
    }
    /** `[Json]` Creates an Optional property */
    Optional(schema) {
      return { ...TypeClone.Type(schema), [exports2.Optional]: "Optional" };
    }
    // ------------------------------------------------------------------------
    // Types
    // ------------------------------------------------------------------------
    /** `[Json]` Creates an Any type */
    Any(options = {}) {
      return this.Create({ ...options, [exports2.Kind]: "Any" });
    }
    /** `[Json]` Creates an Array type */
    Array(schema, options = {}) {
      return this.Create({ ...options, [exports2.Kind]: "Array", type: "array", items: TypeClone.Type(schema) });
    }
    /** `[Json]` Creates a Boolean type */
    Boolean(options = {}) {
      return this.Create({ ...options, [exports2.Kind]: "Boolean", type: "boolean" });
    }
    /** `[Json]` Intrinsic function to Capitalize LiteralString types */
    Capitalize(schema, options = {}) {
      return { ...Intrinsic.Map(TypeClone.Type(schema), "Capitalize"), ...options };
    }
    /** `[Json]` Creates a Composite object type */
    Composite(objects, options) {
      const intersect = exports2.Type.Intersect(objects, {});
      const keys = KeyResolver.ResolveKeys(intersect, { includePatterns: false });
      const properties = keys.reduce((acc, key) => ({ ...acc, [key]: exports2.Type.Index(intersect, [key]) }), {});
      return exports2.Type.Object(properties, options);
    }
    /** `[Json]` Creates a Enum type */
    Enum(item, options = {}) {
      if (ValueGuard.IsUndefined(item))
        return this.Throw("Enum undefined or empty");
      const values1 = Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
      const values2 = [...new Set(values1)];
      const anyOf = values2.map((value2) => exports2.Type.Literal(value2));
      return this.Union(anyOf, { ...options, [exports2.Hint]: "Enum" });
    }
    /** `[Json]` Creates a Conditional type */
    Extends(left, right, trueType, falseType, options = {}) {
      switch (TypeExtends.Extends(left, right)) {
        case TypeExtendsResult.Union:
          return this.Union([TypeClone.Type(trueType, options), TypeClone.Type(falseType, options)]);
        case TypeExtendsResult.True:
          return TypeClone.Type(trueType, options);
        case TypeExtendsResult.False:
          return TypeClone.Type(falseType, options);
      }
    }
    /** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */
    Exclude(unionType2, excludedMembers, options = {}) {
      return TypeGuard.TTemplateLiteral(unionType2) ? this.Exclude(TemplateLiteralResolver.Resolve(unionType2), excludedMembers, options) : TypeGuard.TTemplateLiteral(excludedMembers) ? this.Exclude(unionType2, TemplateLiteralResolver.Resolve(excludedMembers), options) : TypeGuard.TUnion(unionType2) ? (() => {
        const narrowed = unionType2.anyOf.filter((inner) => TypeExtends.Extends(inner, excludedMembers) === TypeExtendsResult.False);
        return narrowed.length === 1 ? TypeClone.Type(narrowed[0], options) : this.Union(narrowed, options);
      })() : TypeExtends.Extends(unionType2, excludedMembers) !== TypeExtendsResult.False ? this.Never(options) : TypeClone.Type(unionType2, options);
    }
    /** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */
    Extract(type, union, options = {}) {
      return TypeGuard.TTemplateLiteral(type) ? this.Extract(TemplateLiteralResolver.Resolve(type), union, options) : TypeGuard.TTemplateLiteral(union) ? this.Extract(type, TemplateLiteralResolver.Resolve(union), options) : TypeGuard.TUnion(type) ? (() => {
        const narrowed = type.anyOf.filter((inner) => TypeExtends.Extends(inner, union) !== TypeExtendsResult.False);
        return narrowed.length === 1 ? TypeClone.Type(narrowed[0], options) : this.Union(narrowed, options);
      })() : TypeExtends.Extends(type, union) !== TypeExtendsResult.False ? TypeClone.Type(type, options) : this.Never(options);
    }
    /** `[Json]` Returns an Indexed property type for the given keys */
    Index(schema, unresolved, options = {}) {
      return TypeGuard.TArray(schema) && TypeGuard.TNumber(unresolved) ? (() => {
        return TypeClone.Type(schema.items, options);
      })() : TypeGuard.TTuple(schema) && TypeGuard.TNumber(unresolved) ? (() => {
        const items = ValueGuard.IsUndefined(schema.items) ? [] : schema.items;
        const cloned = items.map((schema2) => TypeClone.Type(schema2));
        return this.Union(cloned, options);
      })() : (() => {
        const keys = KeyArrayResolver.Resolve(unresolved);
        const clone2 = TypeClone.Type(schema);
        return IndexedAccessor.Resolve(clone2, keys, options);
      })();
    }
    /** `[Json]` Creates an Integer type */
    Integer(options = {}) {
      return this.Create({ ...options, [exports2.Kind]: "Integer", type: "integer" });
    }
    /** `[Json]` Creates an Intersect type */
    Intersect(allOf, options = {}) {
      if (allOf.length === 0)
        return exports2.Type.Never();
      if (allOf.length === 1)
        return TypeClone.Type(allOf[0], options);
      if (allOf.some((schema) => TypeGuard.TTransform(schema)))
        this.Throw("Cannot intersect transform types");
      const objects = allOf.every((schema) => TypeGuard.TObject(schema));
      const cloned = TypeClone.Rest(allOf);
      const clonedUnevaluatedProperties = TypeGuard.TSchema(options.unevaluatedProperties) ? { unevaluatedProperties: TypeClone.Type(options.unevaluatedProperties) } : {};
      return options.unevaluatedProperties === false || TypeGuard.TSchema(options.unevaluatedProperties) || objects ? this.Create({ ...options, ...clonedUnevaluatedProperties, [exports2.Kind]: "Intersect", type: "object", allOf: cloned }) : this.Create({ ...options, ...clonedUnevaluatedProperties, [exports2.Kind]: "Intersect", allOf: cloned });
    }
    /** `[Json]` Creates a KeyOf type */
    KeyOf(schema, options = {}) {
      return TypeGuard.TRecord(schema) ? (() => {
        const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
        return pattern2 === exports2.PatternNumberExact ? this.Number(options) : pattern2 === exports2.PatternStringExact ? this.String(options) : this.Throw("Unable to resolve key type from Record key pattern");
      })() : TypeGuard.TTuple(schema) ? (() => {
        const items = ValueGuard.IsUndefined(schema.items) ? [] : schema.items;
        const literals = items.map((_, index) => exports2.Type.Literal(index.toString()));
        return this.Union(literals, options);
      })() : TypeGuard.TArray(schema) ? (() => {
        return this.Number(options);
      })() : (() => {
        const keys = KeyResolver.ResolveKeys(schema, { includePatterns: false });
        if (keys.length === 0)
          return this.Never(options);
        const literals = keys.map((key) => this.Literal(key));
        return this.Union(literals, options);
      })();
    }
    /** `[Json]` Creates a Literal type */
    Literal(value2, options = {}) {
      return this.Create({ ...options, [exports2.Kind]: "Literal", const: value2, type: typeof value2 });
    }
    /** `[Json]` Intrinsic function to Lowercase LiteralString types */
    Lowercase(schema, options = {}) {
      return { ...Intrinsic.Map(TypeClone.Type(schema), "Lowercase"), ...options };
    }
    /** `[Json]` Creates a Never type */
    Never(options = {}) {
      return this.Create({ ...options, [exports2.Kind]: "Never", not: {} });
    }
    /** `[Json]` Creates a Not type */
    Not(schema, options) {
      return this.Create({ ...options, [exports2.Kind]: "Not", not: TypeClone.Type(schema) });
    }
    /** `[Json]` Creates a Null type */
    Null(options = {}) {
      return this.Create({ ...options, [exports2.Kind]: "Null", type: "null" });
    }
    /** `[Json]` Creates a Number type */
    Number(options = {}) {
      return this.Create({ ...options, [exports2.Kind]: "Number", type: "number" });
    }
    /** `[Json]` Creates an Object type */
    Object(properties, options = {}) {
      const propertyKeys = Object.getOwnPropertyNames(properties);
      const optionalKeys = propertyKeys.filter((key) => TypeGuard.TOptional(properties[key]));
      const requiredKeys = propertyKeys.filter((name2) => !optionalKeys.includes(name2));
      const clonedAdditionalProperties = TypeGuard.TSchema(options.additionalProperties) ? { additionalProperties: TypeClone.Type(options.additionalProperties) } : {};
      const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: TypeClone.Type(properties[key]) }), {});
      return requiredKeys.length > 0 ? this.Create({ ...options, ...clonedAdditionalProperties, [exports2.Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys }) : this.Create({ ...options, ...clonedAdditionalProperties, [exports2.Kind]: "Object", type: "object", properties: clonedProperties });
    }
    /** `[Json]` Constructs a type whose keys are omitted from the given type */
    Omit(schema, unresolved, options = {}) {
      const keys = KeyArrayResolver.Resolve(unresolved);
      return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports2.Transform]), (object) => {
        if (ValueGuard.IsArray(object.required)) {
          object.required = object.required.filter((key) => !keys.includes(key));
          if (object.required.length === 0)
            delete object.required;
        }
        for (const key of Object.getOwnPropertyNames(object.properties)) {
          if (keys.includes(key))
            delete object.properties[key];
        }
        return this.Create(object);
      }, options);
    }
    /** `[Json]` Constructs a type where all properties are optional */
    Partial(schema, options = {}) {
      return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports2.Transform]), (object) => {
        const properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => {
          return { ...acc, [key]: this.Optional(object.properties[key]) };
        }, {});
        return this.Object(
          properties,
          this.Discard(object, ["required"])
          /* object used as options to retain other constraints */
        );
      }, options);
    }
    /** `[Json]` Constructs a type whose keys are picked from the given type */
    Pick(schema, unresolved, options = {}) {
      const keys = KeyArrayResolver.Resolve(unresolved);
      return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports2.Transform]), (object) => {
        if (ValueGuard.IsArray(object.required)) {
          object.required = object.required.filter((key) => keys.includes(key));
          if (object.required.length === 0)
            delete object.required;
        }
        for (const key of Object.getOwnPropertyNames(object.properties)) {
          if (!keys.includes(key))
            delete object.properties[key];
        }
        return this.Create(object);
      }, options);
    }
    /** `[Json]` Creates a Record type */
    Record(key, schema, options = {}) {
      return TypeGuard.TTemplateLiteral(key) ? (() => {
        const expression = TemplateLiteralParser.ParseExact(key.pattern);
        return TemplateLiteralFinite.Check(expression) ? this.Object([...TemplateLiteralGenerator.Generate(expression)].reduce((acc, key2) => ({ ...acc, [key2]: TypeClone.Type(schema) }), {}), options) : this.Create({ ...options, [exports2.Kind]: "Record", type: "object", patternProperties: { [key.pattern]: TypeClone.Type(schema) } });
      })() : TypeGuard.TUnion(key) ? (() => {
        const union = UnionResolver.Resolve(key);
        if (TypeGuard.TUnionLiteral(union)) {
          const properties = union.anyOf.reduce((acc, literal) => ({ ...acc, [literal.const]: TypeClone.Type(schema) }), {});
          return this.Object(properties, { ...options, [exports2.Hint]: "Record" });
        } else
          this.Throw("Record key of type union contains non-literal types");
      })() : TypeGuard.TLiteral(key) ? (() => {
        return ValueGuard.IsString(key.const) || ValueGuard.IsNumber(key.const) ? this.Object({ [key.const]: TypeClone.Type(schema) }, options) : this.Throw("Record key of type literal is not of type string or number");
      })() : TypeGuard.TInteger(key) || TypeGuard.TNumber(key) ? (() => {
        return this.Create({ ...options, [exports2.Kind]: "Record", type: "object", patternProperties: { [exports2.PatternNumberExact]: TypeClone.Type(schema) } });
      })() : TypeGuard.TString(key) ? (() => {
        const pattern2 = ValueGuard.IsUndefined(key.pattern) ? exports2.PatternStringExact : key.pattern;
        return this.Create({ ...options, [exports2.Kind]: "Record", type: "object", patternProperties: { [pattern2]: TypeClone.Type(schema) } });
      })() : this.Never();
    }
    /** `[Json]` Creates a Recursive type */
    Recursive(callback, options = {}) {
      if (ValueGuard.IsUndefined(options.$id))
        options.$id = `T${TypeOrdinal++}`;
      const thisType = callback({ [exports2.Kind]: "This", $ref: `${options.$id}` });
      thisType.$id = options.$id;
      return this.Create({ ...options, [exports2.Hint]: "Recursive", ...thisType });
    }
    /** `[Json]` Creates a Ref type. */
    Ref(unresolved, options = {}) {
      if (ValueGuard.IsString(unresolved))
        return this.Create({ ...options, [exports2.Kind]: "Ref", $ref: unresolved });
      if (ValueGuard.IsUndefined(unresolved.$id))
        this.Throw("Reference target type must specify an $id");
      return this.Create({ ...options, [exports2.Kind]: "Ref", $ref: unresolved.$id });
    }
    /** `[Json]` Constructs a type where all properties are required */
    Required(schema, options = {}) {
      return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports2.Transform]), (object) => {
        const properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => {
          return { ...acc, [key]: this.Discard(object.properties[key], [exports2.Optional]) };
        }, {});
        return this.Object(
          properties,
          object
          /* object used as options to retain other constraints  */
        );
      }, options);
    }
    /** `[Json]` Extracts interior Rest elements from Tuple, Intersect and Union types */
    Rest(schema) {
      return TypeGuard.TTuple(schema) && !ValueGuard.IsUndefined(schema.items) ? TypeClone.Rest(schema.items) : TypeGuard.TIntersect(schema) ? TypeClone.Rest(schema.allOf) : TypeGuard.TUnion(schema) ? TypeClone.Rest(schema.anyOf) : [];
    }
    /** `[Json]` Creates a String type */
    String(options = {}) {
      return this.Create({ ...options, [exports2.Kind]: "String", type: "string" });
    }
    /** `[Json]` Creates a TemplateLiteral type */
    TemplateLiteral(unresolved, options = {}) {
      const pattern2 = ValueGuard.IsString(unresolved) ? TemplateLiteralPattern.Create(TemplateLiteralDslParser.Parse(unresolved)) : TemplateLiteralPattern.Create(unresolved);
      return this.Create({ ...options, [exports2.Kind]: "TemplateLiteral", type: "string", pattern: pattern2 });
    }
    /** `[Json]` Creates a Transform type */
    Transform(schema) {
      return new TransformDecodeBuilder(schema);
    }
    /** `[Json]` Creates a Tuple type */
    Tuple(items, options = {}) {
      const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
      const clonedItems = TypeClone.Rest(items);
      const schema = items.length > 0 ? { ...options, [exports2.Kind]: "Tuple", type: "array", items: clonedItems, additionalItems, minItems, maxItems } : { ...options, [exports2.Kind]: "Tuple", type: "array", minItems, maxItems };
      return this.Create(schema);
    }
    /** `[Json]` Intrinsic function to Uncapitalize LiteralString types */
    Uncapitalize(schema, options = {}) {
      return { ...Intrinsic.Map(TypeClone.Type(schema), "Uncapitalize"), ...options };
    }
    /** `[Json]` Creates a Union type */
    Union(union, options = {}) {
      return TypeGuard.TTemplateLiteral(union) ? TemplateLiteralResolver.Resolve(union) : (() => {
        const anyOf = union;
        if (anyOf.length === 0)
          return this.Never(options);
        if (anyOf.length === 1)
          return this.Create(TypeClone.Type(anyOf[0], options));
        const clonedAnyOf = TypeClone.Rest(anyOf);
        return this.Create({ ...options, [exports2.Kind]: "Union", anyOf: clonedAnyOf });
      })();
    }
    /** `[Json]` Creates an Unknown type */
    Unknown(options = {}) {
      return this.Create({ ...options, [exports2.Kind]: "Unknown" });
    }
    /** `[Json]` Creates a Unsafe type that will infers as the generic argument T */
    Unsafe(options = {}) {
      return this.Create({ ...options, [exports2.Kind]: options[exports2.Kind] || "Unsafe" });
    }
    /** `[Json]` Intrinsic function to Uppercase LiteralString types */
    Uppercase(schema, options = {}) {
      return { ...Intrinsic.Map(TypeClone.Type(schema), "Uppercase"), ...options };
    }
  }
  exports2.JsonTypeBuilder = JsonTypeBuilder;
  class JavaScriptTypeBuilder extends JsonTypeBuilder {
    /** `[JavaScript]` Creates a AsyncIterator type */
    AsyncIterator(items, options = {}) {
      return this.Create({ ...options, [exports2.Kind]: "AsyncIterator", type: "AsyncIterator", items: TypeClone.Type(items) });
    }
    /** `[JavaScript]` Constructs a type by recursively unwrapping Promise types */
    Awaited(schema, options = {}) {
      const Unwrap = (rest) => rest.length > 0 ? (() => {
        const [L, ...R] = rest;
        return [this.Awaited(L), ...Unwrap(R)];
      })() : rest;
      return TypeGuard.TIntersect(schema) ? exports2.Type.Intersect(Unwrap(schema.allOf)) : TypeGuard.TUnion(schema) ? exports2.Type.Union(Unwrap(schema.anyOf)) : TypeGuard.TPromise(schema) ? this.Awaited(schema.item) : TypeClone.Type(schema, options);
    }
    /** `[JavaScript]` Creates a BigInt type */
    BigInt(options = {}) {
      return this.Create({ ...options, [exports2.Kind]: "BigInt", type: "bigint" });
    }
    /** `[JavaScript]` Extracts the ConstructorParameters from the given Constructor type */
    ConstructorParameters(schema, options = {}) {
      return this.Tuple([...schema.parameters], { ...options });
    }
    /** `[JavaScript]` Creates a Constructor type */
    Constructor(parameters, returns, options) {
      const [clonedParameters, clonedReturns] = [TypeClone.Rest(parameters), TypeClone.Type(returns)];
      return this.Create({ ...options, [exports2.Kind]: "Constructor", type: "Constructor", parameters: clonedParameters, returns: clonedReturns });
    }
    /** `[JavaScript]` Creates a Date type */
    Date(options = {}) {
      return this.Create({ ...options, [exports2.Kind]: "Date", type: "Date" });
    }
    /** `[JavaScript]` Creates a Function type */
    Function(parameters, returns, options) {
      const [clonedParameters, clonedReturns] = [TypeClone.Rest(parameters), TypeClone.Type(returns)];
      return this.Create({ ...options, [exports2.Kind]: "Function", type: "Function", parameters: clonedParameters, returns: clonedReturns });
    }
    /** `[JavaScript]` Extracts the InstanceType from the given Constructor type */
    InstanceType(schema, options = {}) {
      return TypeClone.Type(schema.returns, options);
    }
    /** `[JavaScript]` Creates an Iterator type */
    Iterator(items, options = {}) {
      return this.Create({ ...options, [exports2.Kind]: "Iterator", type: "Iterator", items: TypeClone.Type(items) });
    }
    /** `[JavaScript]` Extracts the Parameters from the given Function type */
    Parameters(schema, options = {}) {
      return this.Tuple(schema.parameters, { ...options });
    }
    /** `[JavaScript]` Creates a Promise type */
    Promise(item, options = {}) {
      return this.Create({ ...options, [exports2.Kind]: "Promise", type: "Promise", item: TypeClone.Type(item) });
    }
    /** `[Extended]` Creates a String type */
    RegExp(unresolved, options = {}) {
      const pattern2 = ValueGuard.IsString(unresolved) ? unresolved : unresolved.source;
      return this.Create({ ...options, [exports2.Kind]: "String", type: "string", pattern: pattern2 });
    }
    /**
     * @deprecated Use `Type.RegExp`
     */
    RegEx(regex, options = {}) {
      return this.RegExp(regex, options);
    }
    /** `[JavaScript]` Extracts the ReturnType from the given Function type */
    ReturnType(schema, options = {}) {
      return TypeClone.Type(schema.returns, options);
    }
    /** `[JavaScript]` Creates a Symbol type */
    Symbol(options) {
      return this.Create({ ...options, [exports2.Kind]: "Symbol", type: "symbol" });
    }
    /** `[JavaScript]` Creates a Undefined type */
    Undefined(options = {}) {
      return this.Create({ ...options, [exports2.Kind]: "Undefined", type: "undefined" });
    }
    /** `[JavaScript]` Creates a Uint8Array type */
    Uint8Array(options = {}) {
      return this.Create({ ...options, [exports2.Kind]: "Uint8Array", type: "Uint8Array" });
    }
    /** `[JavaScript]` Creates a Void type */
    Void(options = {}) {
      return this.Create({ ...options, [exports2.Kind]: "Void", type: "void" });
    }
  }
  exports2.JavaScriptTypeBuilder = JavaScriptTypeBuilder;
  exports2.JsonType = new JsonTypeBuilder();
  exports2.Type = new JavaScriptTypeBuilder();
})(typebox);
const pattern = "^((?<grandfathered>(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?<language>([A-Za-z]{2,3}(-(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?))(-(?<script>[A-Za-z]{4}))?(-(?<region>[A-Za-z]{2}|[0-9]{3}))?(-(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*))$";
const LanguageTag = typebox.Type.String({
  pattern,
  description: "The language tag must be a valid IETF BCP 47 language tag.",
  examples: ["en", "de", "en-US", "zh-Hans", "es-419"]
});
function lookup(languageTag, options) {
  const fallbackLanguages = [];
  const languageTagParts = languageTag.split("-").filter(Boolean);
  for (let i2 = languageTagParts.length; i2 > 0; i2--) {
    if (languageTagParts[i2 - 1] === "x")
      continue;
    const fallbackLanguageTag = languageTagParts.slice(0, i2).join("-");
    if (!options.languageTags.includes(fallbackLanguageTag))
      continue;
    fallbackLanguages.push(fallbackLanguageTag);
  }
  return fallbackLanguages[0] ?? options.defaultLanguageTag;
}
const Translatable = (type) => typebox.Type.Union([type, typebox.Type.Intersect([typebox.Type.Object({ en: type }), typebox.Type.Record(LanguageTag, type)])]);
const JSONValue1 = typebox.Type.Union([typebox.Type.String(), typebox.Type.Number(), typebox.Type.Boolean(), typebox.Type.Null()]);
const JSONArray1 = typebox.Type.Array(JSONValue1);
const JSONObject1 = typebox.Type.Record(typebox.Type.String(), typebox.Type.Union([JSONArray1, JSONValue1]));
const JSONValue2 = typebox.Type.Union([JSONValue1, JSONObject1]);
const JSONArray2 = typebox.Type.Array(JSONValue2);
const JSONObject2 = typebox.Type.Record(typebox.Type.String(), typebox.Type.Union([JSONValue2, JSONArray2]));
const JSONValue3 = typebox.Type.Union([JSONValue2, JSONObject2]);
const JSONArray3 = typebox.Type.Array(JSONValue3);
const JSONObject3 = typebox.Type.Record(typebox.Type.String(), typebox.Type.Union([JSONValue3, JSONArray3]));
const JSONValue4 = typebox.Type.Union([JSONValue3, JSONObject3]);
const JSONArray4 = typebox.Type.Array(JSONValue4);
const JSONObject4 = typebox.Type.Record(typebox.Type.String(), typebox.Type.Union([JSONValue4, JSONArray4]));
const JSON$1 = typebox.Type.Union([JSONObject4, JSONValue4, JSONArray4]);
const _MessageLintRuleId = typebox.Type.String({
  pattern: "^messageLintRule\\.([a-z][a-zA-Z0-9]*)\\.([a-z][a-zA-Z0-9]*(?:[A-Z][a-z0-9]*)*)$",
  description: "The key must be conform to `messageLintRule.{namespace}.{id}` pattern.",
  examples: [
    "messageLintRule.namespace.patternInvalid",
    "messageLintRule.namespace.missingTranslation"
  ]
});
const _MessageLintRuleLevel = typebox.Type.Union([typebox.Type.Literal("error"), typebox.Type.Literal("warning")]);
const SourceLanguageTag = LanguageTag;
SourceLanguageTag.title = "Source language tag";
SourceLanguageTag.description = "Set the reference language for your project. It needs to be a valid BCP-47 language tag.";
const InternalProjectSettings = typebox.Type.Object({
  $schema: typebox.Type.Optional(typebox.Type.Literal("https://inlang.com/schema/project-settings")),
  sourceLanguageTag: SourceLanguageTag,
  languageTags: typebox.Type.Array(LanguageTag, {
    uniqueItems: true,
    title: "Language tags",
    description: "Set the languages that are available in your project. All language tags needs to be a valid BCP-47 language tag. Needs to include the source language tag."
  }),
  /**
   * The modules to load.
   *
   * @example
   *  modules: [
   * 	  "https://cdn.jsdelivr.net/npm/@inlang/plugin-i18next@3/dist/index.js",
   * 	  "https://cdn.jsdelivr.net/npm/@inlang/plugin-csv@1/dist/index.js",
   *  ]
   */
  modules: typebox.Type.Array(typebox.Type.Intersect([
    typebox.Type.String({
      pattern: "(?:[A-Za-z][A-Za-z0-9+.-]*:/{2})?(?:(?:[A-Za-z0-9-._~]|%[A-Fa-f0-9]{2})+(?::([A-Za-z0-9-._~]?|[%][A-Fa-f0-9]{2})+)?@)?(?:[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?\\.){1,126}[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?::[0-9]+)?(?:/(?:[A-Za-z0-9-._~]|%[A-Fa-f0-9]{2})*)*(?:\\?(?:[A-Za-z0-9-._~]+(?:=(?:[A-Za-z0-9-._~+]|%[A-Fa-f0-9]{2})+)?)(?:&|;[A-Za-z0-9-._~]+(?:=(?:[A-Za-z0-9-._~+]|%[A-Fa-f0-9]{2})+)?)*)?",
      description: "The module must be a valid URI according to RFC 3986."
    }),
    typebox.Type.String({
      pattern: ".*\\.js$",
      description: "The module must end with `.js`."
    }),
    typebox.Type.String({
      pattern: "^(?!.*@\\d\\.)[^]*$",
      description: "The module can only contain a major version number (ComVer, not SemVer). See https://inlang.com/documentation/comver"
    })
  ]), {
    uniqueItems: true,
    description: "The modules to load. Must be a valid URI but can be relative.",
    examples: [
      "https://cdn.jsdelivr.net/npm/@inlang/plugin-i18next@3/dist/index.js",
      "https://cdn.jsdelivr.net/npm/@inlang/plugin-csv@1/dist/index.js",
      "./local-testing-plugin.js"
    ]
  }),
  messageLintRuleLevels: typebox.Type.Optional(typebox.Type.Record(_MessageLintRuleId, _MessageLintRuleLevel, {
    title: "Levels for lint rules",
    description: "Adjust the lint rule levels in your project to choose between 'warning' and 'error'. If set to 'error', you can configure a CI process to prevent merging with existing reports. (When you want to configure your lint rules visit inlang.com/c/lint-rules)",
    examples: [
      {
        "messageLintRule.inlang.missingTranslation": "error",
        "messageLintRule.inlang.patternInvalid": "warning"
      }
    ]
  })),
  experimental: typebox.Type.Optional(typebox.Type.Record(typebox.Type.String(), typebox.Type.Literal(true)))
});
const ExternalProjectSettings = typebox.Type.Record(
  typebox.Type.String({
    // pattern includes ProjectSettings keys
    pattern: `^((messageLintRule|plugin|app|library)\\.([a-z][a-zA-Z0-9]*)\\.([a-z][a-zA-Z0-9]*(?:[A-Z][a-z0-9]*)*)|\\$schema|${Object.keys(InternalProjectSettings.properties).map((key) => key.replaceAll(".", "\\.")).join("|")})$`,
    description: "The key must be conform to `{type:app|plugin|messageLintRule}.{namespace:string}.{id:string}`.",
    examples: ["plugin.publisher.sqlite", "messageLintRule.inlang.missingTranslation"]
  }),
  // Using JSON (array and object) as a workaround to make the
  // intersection between `InternalSettings`, which contains an array,
  // and `ExternalSettings` which are objects possible
  JSON$1,
  { description: "Settings defined by apps, plugins, etc." }
);
const ProjectSettings = typebox.Type.Intersect([InternalProjectSettings, ExternalProjectSettings]);
const MessageLintRule = typebox.Type.Object({
  id: _MessageLintRuleId,
  displayName: Translatable(typebox.Type.String()),
  description: Translatable(typebox.Type.String()),
  /**
   * Tyepbox is must be used to validate the Json Schema.
   * Github discussion to upvote a plain Json Schema validator and read the benefits of Typebox
   * https://github.com/opral/monorepo/discussions/1503
   */
  settingsSchema: typebox.Type.Optional(typebox.Type.Object({}, { additionalProperties: true }))
});
const MessageReferenceMatch = typebox.Type.Object({
  /**
   * The messages id.
   */
  messageId: typebox.Type.String(),
  /**
   * The position from where to where the reference can be found.
   */
  position: typebox.Type.Object({
    start: typebox.Type.Object({
      line: typebox.Type.Number(),
      character: typebox.Type.Number()
    }),
    end: typebox.Type.Object({
      line: typebox.Type.Number(),
      character: typebox.Type.Number()
    })
  })
});
typebox.Type.Object({
  /**
   * Defines matchers for message references inside the code.
   *
   * @param args represents the data to conduct the search on
   * @returns a promise with matched message references
   */
  messageReferenceMatchers: typebox.Type.Array(typebox.Type.Function([
    typebox.Type.Object({
      documentText: typebox.Type.String()
    })
  ], typebox.Type.Promise(typebox.Type.Array(MessageReferenceMatch)))),
  /**
   * Defines the options to extract messages.
   */
  extractMessageOptions: typebox.Type.Array(typebox.Type.Object({
    /**
     * Function which is called, when the user finished the message extraction command.
     *
     * @param messageId is the message identifier entered by the user
     * @param selection is the text which was extracted
     * @returns the code which is inserted into the document
     */
    callback: typebox.Type.Function([
      typebox.Type.Object({
        messageId: typebox.Type.String(),
        selection: typebox.Type.String()
      })
    ], typebox.Type.Object({
      messageId: typebox.Type.String(),
      messageReplacement: typebox.Type.String()
    }))
  })),
  /**
   * An array of Visual Studio Code DocumentSelectors.
   *
   * The document selectors specify for which files/programming languages
   * (typescript, svelte, etc.) the extension should be activated.
   *
   * See https://code.visualstudio.com/api/references/document-selector
   */
  documentSelectors: typebox.Type.Optional(typebox.Type.Array(typebox.Type.Object({
    language: typebox.Type.Optional(typebox.Type.String())
  })))
});
const Plugin = typebox.Type.Object({
  id: typebox.Type.String({
    pattern: "^plugin\\.([a-z][a-zA-Z0-9]*)\\.([a-z][a-zA-Z0-9]*(?:[A-Z][a-z0-9]*)*)$",
    examples: ["plugin.namespace.id"]
  }),
  displayName: Translatable(typebox.Type.String()),
  description: Translatable(typebox.Type.String()),
  /**
   * Tyepbox is must be used to validate the Json Schema.
   * Github discussion to upvote a plain Json Schema validator and read the benefits of Typebox
   * https://github.com/opral/monorepo/discussions/1503
   */
  settingsSchema: typebox.Type.Optional(typebox.Type.Object({}, { additionalProperties: true })),
  loadMessages: typebox.Type.Optional(typebox.Type.Any()),
  saveMessages: typebox.Type.Optional(typebox.Type.Any()),
  /**
   * @deprecated removed
   */
  detectedLanguageTags: typebox.Type.Optional(typebox.Type.Any()),
  addCustomApi: typebox.Type.Optional(typebox.Type.Any())
});
const Text = typebox.Type.Object({
  type: typebox.Type.Literal("Text"),
  value: typebox.Type.String()
});
const VariableReference = typebox.Type.Object({
  type: typebox.Type.Literal("VariableReference"),
  name: typebox.Type.String()
});
const Expression = typebox.Type.Union([VariableReference]);
const Pattern = typebox.Type.Array(typebox.Type.Union([Text, Expression]));
const Variant = typebox.Type.Object({
  languageTag: LanguageTag,
  /**
   * The number of keys in each variant match MUST equal the number of expressions in the selectors.
   *
   * Inspired by: https://github.com/unicode-org/message-format-wg/blob/main/spec/formatting.md#pattern-selection
   */
  // a match can always only be string-based because a string is what is rendered to the UI
  match: typebox.Type.Array(typebox.Type.String()),
  pattern: Pattern
});
typebox.Type.Object({
  id: typebox.Type.String(),
  alias: typebox.Type.Record(typebox.Type.String(), typebox.Type.String()),
  /**
   * The order in which the selectors are placed determines the precedence of patterns.
   */
  selectors: typebox.Type.Array(Expression),
  variants: typebox.Type.Array(Variant)
});
const InlangModule = typebox.Type.Object({
  default: typebox.Type.Union([Plugin, MessageLintRule])
});
class PluginHasInvalidIdError extends Error {
  constructor(options) {
    super(`Plugin "${options.id}" has an invalid id. The id must:
1) Start with "plugin."
2) camelCase
3) Contain a namespace.
An example would be "plugin.namespace.myPlugin".`);
    this.name = "PluginHasInvalidIdError";
  }
}
class PluginHasInvalidSchemaError extends Error {
  constructor(options) {
    super(`Plugin "${options.id}" has an invalid schema:

${options.errors.map((error) => `Path "${error.path}" with value "${error.value}": "${error.message}"`).join("\n")})}

Please refer to the documentation for the correct schema.`);
    this.name = "PluginHasInvalidSchemaError";
  }
}
class PluginLoadMessagesFunctionAlreadyDefinedError extends Error {
  constructor(options) {
    super(`Plugin "${options.id}" defines the \`loadMessages()\` function, but it was already defined by another plugin.

Inlang only allows one plugin to define the \`loadMessages()\` function.`);
    this.name = "PluginLoadMessagesFunctionAlreadyDefinedError";
  }
}
class PluginSaveMessagesFunctionAlreadyDefinedError extends Error {
  constructor(options) {
    super(`Plugin "${options.id}" defines the \`saveMessages()\` function, but it was already defined by another plugin.

Inlang only allows one plugin to define the \`saveMessages()\` function.`);
    this.name = "PluginSaveMessagesFunctionAlreadyDefinedError";
  }
}
class PluginReturnedInvalidCustomApiError extends Error {
  constructor(options) {
    super(`Plugin "${options.id}" returned an invalid custom API:

${options.cause}`, options);
    this.name = "PluginReturnedInvalidCustomApiError";
  }
}
class PluginsDoNotProvideLoadOrSaveMessagesError extends Error {
  constructor() {
    super(`No plugin provides a \`loadMessages()\` or \`saveMessages()\` function

In case no plugin threw an error, you likely forgot to add a plugin that handles the loading and saving of messages. Refer to the marketplace for available plugins https://inlang.com/marketplace.`);
    this.name = "PluginsDoNotProvideLoadOrSaveMessagesError";
  }
}
class MessageLintRuleIsInvalidError extends Error {
  constructor(options) {
    super(`The message lint rule "${options.id}" is invalid:

${options.errors.join("\n")}`);
    this.name = "MessageLintRuleIsInvalidError";
  }
}
class ModuleError extends Error {
  module;
  constructor(message, options) {
    super(message);
    this.name = "ModuleError";
    this.module = options.module;
    this.cause = options.cause;
  }
}
class ModuleHasNoExportsError extends ModuleError {
  constructor(options) {
    super(`Module "${options.module}" has no exports. Every module must have an "export default".`, options);
    this.name = "ModuleHasNoExportsError";
  }
}
class ModuleImportError extends ModuleError {
  constructor(options) {
    super(`Couldn't import the plugin "${options.module}":

${options.cause}`, options);
    this.name = "ModuleImportError";
  }
}
class ModuleExportIsInvalidError extends ModuleError {
  constructor(options) {
    super(`The export(s) of "${options.module}" are invalid:

${options.errors.map((error) => `"${error.path}" "${JSON.stringify(error.value, void 0, 2)}": "${error.message}"`).join("\n")}`, options);
    this.name = "ModuleExportIsInvalidError";
  }
}
class ModuleSettingsAreInvalidError extends ModuleError {
  constructor(options) {
    super(`The settings are invalid of "${options.module}" are invalid:

${options.errors.map((error) => `Path "${error.path}" with value "${JSON.stringify(error.value, void 0, 2)}": "${error.message}"`).join("\n")}`, options);
    this.name = "ModuleSettingsAreInvalidError";
  }
}
function tryCatch(callback) {
  try {
    const callbackResult = callback();
    if (isAsync$1(callbackResult)) {
      return callbackResult.then((data) => ({ data })).catch(getErrorResponse);
    }
    return { data: callbackResult };
  } catch (e) {
    return getErrorResponse(e);
  }
}
const getErrorResponse = (error) => {
  if (error instanceof Error) {
    return { error };
  }
  return { error: new Error(`Unknown error has been caught: ${error}`, { cause: error }) };
};
const isAsync$1 = (p) => !!p && typeof p === "object" && typeof p.then === "function";
var value$1 = {};
var errors$1 = {};
var errors = {};
var guard = {};
Object.defineProperty(guard, "__esModule", { value: true });
guard.IsValueType = guard.IsSymbol = guard.IsFunction = guard.IsString = guard.IsBigInt = guard.IsInteger = guard.IsNumber = guard.IsBoolean = guard.IsNull = guard.IsUndefined = guard.IsArray = guard.IsObject = guard.IsPlainObject = guard.HasPropertyKey = guard.IsDate = guard.IsUint8Array = guard.IsPromise = guard.IsTypedArray = guard.IsIterator = guard.IsAsyncIterator = void 0;
function IsAsyncIterator(value2) {
  return IsObject(value2) && Symbol.asyncIterator in value2;
}
guard.IsAsyncIterator = IsAsyncIterator;
function IsIterator(value2) {
  return IsObject(value2) && Symbol.iterator in value2;
}
guard.IsIterator = IsIterator;
function IsTypedArray(value2) {
  return ArrayBuffer.isView(value2);
}
guard.IsTypedArray = IsTypedArray;
function IsPromise(value2) {
  return value2 instanceof Promise;
}
guard.IsPromise = IsPromise;
function IsUint8Array(value2) {
  return value2 instanceof Uint8Array;
}
guard.IsUint8Array = IsUint8Array;
function IsDate(value2) {
  return value2 instanceof Date && Number.isFinite(value2.getTime());
}
guard.IsDate = IsDate;
function HasPropertyKey(value2, key) {
  return key in value2;
}
guard.HasPropertyKey = HasPropertyKey;
function IsPlainObject(value2) {
  return IsObject(value2) && IsFunction(value2.constructor) && value2.constructor.name === "Object";
}
guard.IsPlainObject = IsPlainObject;
function IsObject(value2) {
  return value2 !== null && typeof value2 === "object";
}
guard.IsObject = IsObject;
function IsArray(value2) {
  return Array.isArray(value2) && !ArrayBuffer.isView(value2);
}
guard.IsArray = IsArray;
function IsUndefined(value2) {
  return value2 === void 0;
}
guard.IsUndefined = IsUndefined;
function IsNull(value2) {
  return value2 === null;
}
guard.IsNull = IsNull;
function IsBoolean(value2) {
  return typeof value2 === "boolean";
}
guard.IsBoolean = IsBoolean;
function IsNumber(value2) {
  return typeof value2 === "number";
}
guard.IsNumber = IsNumber;
function IsInteger(value2) {
  return IsNumber(value2) && Number.isInteger(value2);
}
guard.IsInteger = IsInteger;
function IsBigInt(value2) {
  return typeof value2 === "bigint";
}
guard.IsBigInt = IsBigInt;
function IsString(value2) {
  return typeof value2 === "string";
}
guard.IsString = IsString;
function IsFunction(value2) {
  return typeof value2 === "function";
}
guard.IsFunction = IsFunction;
function IsSymbol(value2) {
  return typeof value2 === "symbol";
}
guard.IsSymbol = IsSymbol;
function IsValueType(value2) {
  return IsBigInt(value2) || IsBoolean(value2) || IsNull(value2) || IsNumber(value2) || IsString(value2) || IsSymbol(value2) || IsUndefined(value2);
}
guard.IsValueType = IsValueType;
var system$1 = {};
var hasRequiredSystem;
function requireSystem() {
  if (hasRequiredSystem)
    return system$1;
  hasRequiredSystem = 1;
  Object.defineProperty(system$1, "__esModule", { value: true });
  system$1.DefaultErrorFunction = system$1.TypeSystemPolicy = system$1.TypeSystemErrorFunction = system$1.TypeSystem = system$1.TypeSystemDuplicateFormat = system$1.TypeSystemDuplicateTypeKind = void 0;
  const guard_12 = guard;
  const errors_12 = requireErrors();
  const Types2 = typebox;
  class TypeSystemDuplicateTypeKind extends Types2.TypeBoxError {
    constructor(kind) {
      super(`Duplicate type kind '${kind}' detected`);
    }
  }
  system$1.TypeSystemDuplicateTypeKind = TypeSystemDuplicateTypeKind;
  class TypeSystemDuplicateFormat extends Types2.TypeBoxError {
    constructor(kind) {
      super(`Duplicate string format '${kind}' detected`);
    }
  }
  system$1.TypeSystemDuplicateFormat = TypeSystemDuplicateFormat;
  var TypeSystem;
  (function(TypeSystem2) {
    function Type(kind, check2) {
      if (Types2.TypeRegistry.Has(kind))
        throw new TypeSystemDuplicateTypeKind(kind);
      Types2.TypeRegistry.Set(kind, check2);
      return (options = {}) => Types2.Type.Unsafe({ ...options, [Types2.Kind]: kind });
    }
    TypeSystem2.Type = Type;
    function Format(format, check2) {
      if (Types2.FormatRegistry.Has(format))
        throw new TypeSystemDuplicateFormat(format);
      Types2.FormatRegistry.Set(format, check2);
      return format;
    }
    TypeSystem2.Format = Format;
  })(TypeSystem || (system$1.TypeSystem = TypeSystem = {}));
  var TypeSystemErrorFunction;
  (function(TypeSystemErrorFunction2) {
    let errorMessageFunction = DefaultErrorFunction;
    function Reset() {
      errorMessageFunction = DefaultErrorFunction;
    }
    TypeSystemErrorFunction2.Reset = Reset;
    function Set2(callback) {
      errorMessageFunction = callback;
    }
    TypeSystemErrorFunction2.Set = Set2;
    function Get() {
      return errorMessageFunction;
    }
    TypeSystemErrorFunction2.Get = Get;
  })(TypeSystemErrorFunction || (system$1.TypeSystemErrorFunction = TypeSystemErrorFunction = {}));
  var TypeSystemPolicy;
  (function(TypeSystemPolicy2) {
    TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
    TypeSystemPolicy2.AllowArrayObject = false;
    TypeSystemPolicy2.AllowNaN = false;
    TypeSystemPolicy2.AllowNullVoid = false;
    function IsExactOptionalProperty(value2, key) {
      return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value2 : value2[key] !== void 0;
    }
    TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
    function IsObjectLike(value2) {
      const isObject = (0, guard_12.IsObject)(value2);
      return TypeSystemPolicy2.AllowArrayObject ? isObject : isObject && !(0, guard_12.IsArray)(value2);
    }
    TypeSystemPolicy2.IsObjectLike = IsObjectLike;
    function IsRecordLike(value2) {
      return IsObjectLike(value2) && !(value2 instanceof Date) && !(value2 instanceof Uint8Array);
    }
    TypeSystemPolicy2.IsRecordLike = IsRecordLike;
    function IsNumberLike(value2) {
      const isNumber = (0, guard_12.IsNumber)(value2);
      return TypeSystemPolicy2.AllowNaN ? isNumber : isNumber && Number.isFinite(value2);
    }
    TypeSystemPolicy2.IsNumberLike = IsNumberLike;
    function IsVoidLike(value2) {
      const isUndefined = (0, guard_12.IsUndefined)(value2);
      return TypeSystemPolicy2.AllowNullVoid ? isUndefined || value2 === null : isUndefined;
    }
    TypeSystemPolicy2.IsVoidLike = IsVoidLike;
  })(TypeSystemPolicy || (system$1.TypeSystemPolicy = TypeSystemPolicy = {}));
  function DefaultErrorFunction(schema, errorType) {
    switch (errorType) {
      case errors_12.ValueErrorType.ArrayContains:
        return "Expected array to contain at least one matching value";
      case errors_12.ValueErrorType.ArrayMaxContains:
        return `Expected array to contain no more than ${schema.maxContains} matching values`;
      case errors_12.ValueErrorType.ArrayMinContains:
        return `Expected array to contain at least ${schema.minContains} matching values`;
      case errors_12.ValueErrorType.ArrayMaxItems:
        return `Expected array length to be less or equal to ${schema.maxItems}`;
      case errors_12.ValueErrorType.ArrayMinItems:
        return `Expected array length to be greater or equal to ${schema.minItems}`;
      case errors_12.ValueErrorType.ArrayUniqueItems:
        return "Expected array elements to be unique";
      case errors_12.ValueErrorType.Array:
        return "Expected array";
      case errors_12.ValueErrorType.AsyncIterator:
        return "Expected AsyncIterator";
      case errors_12.ValueErrorType.BigIntExclusiveMaximum:
        return `Expected bigint to be less than ${schema.exclusiveMaximum}`;
      case errors_12.ValueErrorType.BigIntExclusiveMinimum:
        return `Expected bigint to be greater than ${schema.exclusiveMinimum}`;
      case errors_12.ValueErrorType.BigIntMaximum:
        return `Expected bigint to be less or equal to ${schema.maximum}`;
      case errors_12.ValueErrorType.BigIntMinimum:
        return `Expected bigint to be greater or equal to ${schema.minimum}`;
      case errors_12.ValueErrorType.BigIntMultipleOf:
        return `Expected bigint to be a multiple of ${schema.multipleOf}`;
      case errors_12.ValueErrorType.BigInt:
        return "Expected bigint";
      case errors_12.ValueErrorType.Boolean:
        return "Expected boolean";
      case errors_12.ValueErrorType.DateExclusiveMinimumTimestamp:
        return `Expected Date timestamp to be greater than ${schema.exclusiveMinimumTimestamp}`;
      case errors_12.ValueErrorType.DateExclusiveMaximumTimestamp:
        return `Expected Date timestamp to be less than ${schema.exclusiveMaximumTimestamp}`;
      case errors_12.ValueErrorType.DateMinimumTimestamp:
        return `Expected Date timestamp to be greater or equal to ${schema.minimumTimestamp}`;
      case errors_12.ValueErrorType.DateMaximumTimestamp:
        return `Expected Date timestamp to be less or equal to ${schema.maximumTimestamp}`;
      case errors_12.ValueErrorType.DateMultipleOfTimestamp:
        return `Expected Date timestamp to be a multiple of ${schema.multipleOfTimestamp}`;
      case errors_12.ValueErrorType.Date:
        return "Expected Date";
      case errors_12.ValueErrorType.Function:
        return "Expected function";
      case errors_12.ValueErrorType.IntegerExclusiveMaximum:
        return `Expected integer to be less than ${schema.exclusiveMaximum}`;
      case errors_12.ValueErrorType.IntegerExclusiveMinimum:
        return `Expected integer to be greater than ${schema.exclusiveMinimum}`;
      case errors_12.ValueErrorType.IntegerMaximum:
        return `Expected integer to be less or equal to ${schema.maximum}`;
      case errors_12.ValueErrorType.IntegerMinimum:
        return `Expected integer to be greater or equal to ${schema.minimum}`;
      case errors_12.ValueErrorType.IntegerMultipleOf:
        return `Expected integer to be a multiple of ${schema.multipleOf}`;
      case errors_12.ValueErrorType.Integer:
        return "Expected integer";
      case errors_12.ValueErrorType.IntersectUnevaluatedProperties:
        return "Unexpected property";
      case errors_12.ValueErrorType.Intersect:
        return "Expected all values to match";
      case errors_12.ValueErrorType.Iterator:
        return "Expected Iterator";
      case errors_12.ValueErrorType.Literal:
        return `Expected ${typeof schema.const === "string" ? `'${schema.const}'` : schema.const}`;
      case errors_12.ValueErrorType.Never:
        return "Never";
      case errors_12.ValueErrorType.Not:
        return "Value should not match";
      case errors_12.ValueErrorType.Null:
        return "Expected null";
      case errors_12.ValueErrorType.NumberExclusiveMaximum:
        return `Expected number to be less than ${schema.exclusiveMaximum}`;
      case errors_12.ValueErrorType.NumberExclusiveMinimum:
        return `Expected number to be greater than ${schema.exclusiveMinimum}`;
      case errors_12.ValueErrorType.NumberMaximum:
        return `Expected number to be less or equal to ${schema.maximum}`;
      case errors_12.ValueErrorType.NumberMinimum:
        return `Expected number to be greater or equal to ${schema.minimum}`;
      case errors_12.ValueErrorType.NumberMultipleOf:
        return `Expected number to be a multiple of ${schema.multipleOf}`;
      case errors_12.ValueErrorType.Number:
        return "Expected number";
      case errors_12.ValueErrorType.Object:
        return "Expected object";
      case errors_12.ValueErrorType.ObjectAdditionalProperties:
        return "Unexpected property";
      case errors_12.ValueErrorType.ObjectMaxProperties:
        return `Expected object to have no more than ${schema.maxProperties} properties`;
      case errors_12.ValueErrorType.ObjectMinProperties:
        return `Expected object to have at least ${schema.minProperties} properties`;
      case errors_12.ValueErrorType.ObjectRequiredProperty:
        return "Required property";
      case errors_12.ValueErrorType.Promise:
        return "Expected Promise";
      case errors_12.ValueErrorType.StringFormatUnknown:
        return `Unknown format '${schema.format}'`;
      case errors_12.ValueErrorType.StringFormat:
        return `Expected string to match '${schema.format}' format`;
      case errors_12.ValueErrorType.StringMaxLength:
        return `Expected string length less or equal to ${schema.maxLength}`;
      case errors_12.ValueErrorType.StringMinLength:
        return `Expected string length greater or equal to ${schema.minLength}`;
      case errors_12.ValueErrorType.StringPattern:
        return `Expected string to match '${schema.pattern}'`;
      case errors_12.ValueErrorType.String:
        return "Expected string";
      case errors_12.ValueErrorType.Symbol:
        return "Expected symbol";
      case errors_12.ValueErrorType.TupleLength:
        return `Expected tuple to have ${schema.maxItems || 0} elements`;
      case errors_12.ValueErrorType.Tuple:
        return "Expected tuple";
      case errors_12.ValueErrorType.Uint8ArrayMaxByteLength:
        return `Expected byte length less or equal to ${schema.maxByteLength}`;
      case errors_12.ValueErrorType.Uint8ArrayMinByteLength:
        return `Expected byte length greater or equal to ${schema.minByteLength}`;
      case errors_12.ValueErrorType.Uint8Array:
        return "Expected Uint8Array";
      case errors_12.ValueErrorType.Undefined:
        return "Expected undefined";
      case errors_12.ValueErrorType.Union:
        return "Expected union value";
      case errors_12.ValueErrorType.Void:
        return "Expected void";
      case errors_12.ValueErrorType.Kind:
        return `Expected kind '${schema[Types2.Kind]}'`;
      default:
        return "Unknown error type";
    }
  }
  system$1.DefaultErrorFunction = DefaultErrorFunction;
  return system$1;
}
var deref = {};
Object.defineProperty(deref, "__esModule", { value: true });
deref.Deref = deref.TypeDereferenceError = void 0;
const typebox_1 = typebox;
class TypeDereferenceError extends typebox_1.TypeBoxError {
  constructor(schema) {
    super(`Unable to dereference schema with $id '${schema.$id}'`);
    this.schema = schema;
  }
}
deref.TypeDereferenceError = TypeDereferenceError;
function Deref(schema, references) {
  const index = references.findIndex((target) => target.$id === schema.$ref);
  if (index === -1)
    throw new TypeDereferenceError(schema);
  return references[index];
}
deref.Deref = Deref;
var hash$1 = {};
Object.defineProperty(hash$1, "__esModule", { value: true });
hash$1.Hash = hash$1.ByteMarker = hash$1.ValueHashError = void 0;
const guard_1$9 = guard;
class ValueHashError extends Error {
  constructor(value2) {
    super(`Unable to hash value`);
    this.value = value2;
  }
}
hash$1.ValueHashError = ValueHashError;
var ByteMarker;
(function(ByteMarker2) {
  ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
  ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
  ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
  ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
  ByteMarker2[ByteMarker2["String"] = 4] = "String";
  ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
  ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
  ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
  ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
  ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
  ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
})(ByteMarker || (hash$1.ByteMarker = ByteMarker = {}));
let Accumulator = BigInt("14695981039346656037");
const [Prime, Size] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")];
const Bytes = Array.from({ length: 256 }).map((_, i2) => BigInt(i2));
const F64 = new Float64Array(1);
const F64In = new DataView(F64.buffer);
const F64Out = new Uint8Array(F64.buffer);
function* NumberToBytes(value2) {
  const byteCount = value2 === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value2) + 1) / 8);
  for (let i2 = 0; i2 < byteCount; i2++) {
    yield value2 >> 8 * (byteCount - 1 - i2) & 255;
  }
}
function ArrayType$3(value2) {
  FNV1A64(ByteMarker.Array);
  for (const item of value2) {
    Visit$5(item);
  }
}
function BooleanType(value2) {
  FNV1A64(ByteMarker.Boolean);
  FNV1A64(value2 ? 1 : 0);
}
function BigIntType(value2) {
  FNV1A64(ByteMarker.BigInt);
  F64In.setBigInt64(0, value2);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function DateType$2(value2) {
  FNV1A64(ByteMarker.Date);
  Visit$5(value2.getTime());
}
function NullType(value2) {
  FNV1A64(ByteMarker.Null);
}
function NumberType(value2) {
  FNV1A64(ByteMarker.Number);
  F64In.setFloat64(0, value2);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function ObjectType$3(value2) {
  FNV1A64(ByteMarker.Object);
  for (const key of globalThis.Object.keys(value2).sort()) {
    Visit$5(key);
    Visit$5(value2[key]);
  }
}
function StringType(value2) {
  FNV1A64(ByteMarker.String);
  for (let i2 = 0; i2 < value2.length; i2++) {
    for (const byte of NumberToBytes(value2.charCodeAt(i2))) {
      FNV1A64(byte);
    }
  }
}
function SymbolType(value2) {
  FNV1A64(ByteMarker.Symbol);
  Visit$5(value2.description);
}
function Uint8ArrayType(value2) {
  FNV1A64(ByteMarker.Uint8Array);
  for (let i2 = 0; i2 < value2.length; i2++) {
    FNV1A64(value2[i2]);
  }
}
function UndefinedType(value2) {
  return FNV1A64(ByteMarker.Undefined);
}
function Visit$5(value2) {
  if ((0, guard_1$9.IsArray)(value2))
    return ArrayType$3(value2);
  if ((0, guard_1$9.IsBoolean)(value2))
    return BooleanType(value2);
  if ((0, guard_1$9.IsBigInt)(value2))
    return BigIntType(value2);
  if ((0, guard_1$9.IsDate)(value2))
    return DateType$2(value2);
  if ((0, guard_1$9.IsNull)(value2))
    return NullType();
  if ((0, guard_1$9.IsNumber)(value2))
    return NumberType(value2);
  if ((0, guard_1$9.IsPlainObject)(value2))
    return ObjectType$3(value2);
  if ((0, guard_1$9.IsString)(value2))
    return StringType(value2);
  if ((0, guard_1$9.IsSymbol)(value2))
    return SymbolType(value2);
  if ((0, guard_1$9.IsUint8Array)(value2))
    return Uint8ArrayType(value2);
  if ((0, guard_1$9.IsUndefined)(value2))
    return UndefinedType();
  throw new ValueHashError(value2);
}
function FNV1A64(byte) {
  Accumulator = Accumulator ^ Bytes[byte];
  Accumulator = Accumulator * Prime % Size;
}
function Hash(value2) {
  Accumulator = BigInt("14695981039346656037");
  Visit$5(value2);
  return Accumulator;
}
hash$1.Hash = Hash;
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors)
    return errors;
  hasRequiredErrors = 1;
  Object.defineProperty(errors, "__esModule", { value: true });
  errors.Errors = errors.ValueErrorIterator = errors.EscapeKey = errors.ValueErrorsUnknownTypeError = errors.ValueErrorType = void 0;
  const guard_12 = guard;
  const system_1 = requireSystem();
  const deref_12 = deref;
  const hash_12 = hash$1;
  const Types2 = typebox;
  var ValueErrorType;
  (function(ValueErrorType2) {
    ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
    ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
    ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
    ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
    ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
    ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
    ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
    ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
    ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
    ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
    ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
    ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
    ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
    ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
    ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
    ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
    ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
    ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
    ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
    ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
    ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
    ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
    ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
    ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
    ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
    ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
    ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
    ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
    ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
    ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
    ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
    ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
    ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
    ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
    ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
    ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
    ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
    ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
    ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
    ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
    ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
    ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
    ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
    ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
    ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
    ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
    ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
    ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
    ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 48] = "StringFormatUnknown";
    ValueErrorType2[ValueErrorType2["StringFormat"] = 49] = "StringFormat";
    ValueErrorType2[ValueErrorType2["StringMaxLength"] = 50] = "StringMaxLength";
    ValueErrorType2[ValueErrorType2["StringMinLength"] = 51] = "StringMinLength";
    ValueErrorType2[ValueErrorType2["StringPattern"] = 52] = "StringPattern";
    ValueErrorType2[ValueErrorType2["String"] = 53] = "String";
    ValueErrorType2[ValueErrorType2["Symbol"] = 54] = "Symbol";
    ValueErrorType2[ValueErrorType2["TupleLength"] = 55] = "TupleLength";
    ValueErrorType2[ValueErrorType2["Tuple"] = 56] = "Tuple";
    ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 57] = "Uint8ArrayMaxByteLength";
    ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 58] = "Uint8ArrayMinByteLength";
    ValueErrorType2[ValueErrorType2["Uint8Array"] = 59] = "Uint8Array";
    ValueErrorType2[ValueErrorType2["Undefined"] = 60] = "Undefined";
    ValueErrorType2[ValueErrorType2["Union"] = 61] = "Union";
    ValueErrorType2[ValueErrorType2["Void"] = 62] = "Void";
  })(ValueErrorType || (errors.ValueErrorType = ValueErrorType = {}));
  class ValueErrorsUnknownTypeError extends Types2.TypeBoxError {
    constructor(schema) {
      super("Unknown type");
      this.schema = schema;
    }
  }
  errors.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError;
  function EscapeKey(key) {
    return key.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  errors.EscapeKey = EscapeKey;
  function IsDefined2(value2) {
    return value2 !== void 0;
  }
  class ValueErrorIterator {
    constructor(iterator) {
      this.iterator = iterator;
    }
    [Symbol.iterator]() {
      return this.iterator;
    }
    /** Returns the first value error or undefined if no errors */
    First() {
      const next = this.iterator.next();
      return next.done ? void 0 : next.value;
    }
  }
  errors.ValueErrorIterator = ValueErrorIterator;
  function Create2(type, schema, path2, value2) {
    return { type, schema, path: path2, value: value2, message: system_1.TypeSystemErrorFunction.Get()(schema, type) };
  }
  function* TAny2(schema, references, path2, value2) {
  }
  function* TArray2(schema, references, path2, value2) {
    if (!(0, guard_12.IsArray)(value2)) {
      return yield Create2(ValueErrorType.Array, schema, path2, value2);
    }
    if (IsDefined2(schema.minItems) && !(value2.length >= schema.minItems)) {
      yield Create2(ValueErrorType.ArrayMinItems, schema, path2, value2);
    }
    if (IsDefined2(schema.maxItems) && !(value2.length <= schema.maxItems)) {
      yield Create2(ValueErrorType.ArrayMaxItems, schema, path2, value2);
    }
    for (let i2 = 0; i2 < value2.length; i2++) {
      yield* Visit2(schema.items, references, `${path2}/${i2}`, value2[i2]);
    }
    if (schema.uniqueItems === true && !function() {
      const set = /* @__PURE__ */ new Set();
      for (const element of value2) {
        const hashed = (0, hash_12.Hash)(element);
        if (set.has(hashed)) {
          return false;
        } else {
          set.add(hashed);
        }
      }
      return true;
    }()) {
      yield Create2(ValueErrorType.ArrayUniqueItems, schema, path2, value2);
    }
    if (!(IsDefined2(schema.contains) || IsDefined2(schema.minContains) || IsDefined2(schema.maxContains))) {
      return;
    }
    const containsSchema = IsDefined2(schema.contains) ? schema.contains : Types2.Type.Never();
    const containsCount = value2.reduce((acc, value3, index) => Visit2(containsSchema, references, `${path2}${index}`, value3).next().done === true ? acc + 1 : acc, 0);
    if (containsCount === 0) {
      yield Create2(ValueErrorType.ArrayContains, schema, path2, value2);
    }
    if ((0, guard_12.IsNumber)(schema.minContains) && containsCount < schema.minContains) {
      yield Create2(ValueErrorType.ArrayMinContains, schema, path2, value2);
    }
    if ((0, guard_12.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {
      yield Create2(ValueErrorType.ArrayMaxContains, schema, path2, value2);
    }
  }
  function* TAsyncIterator2(schema, references, path2, value2) {
    if (!(0, guard_12.IsAsyncIterator)(value2))
      yield Create2(ValueErrorType.AsyncIterator, schema, path2, value2);
  }
  function* TBigInt2(schema, references, path2, value2) {
    if (!(0, guard_12.IsBigInt)(value2))
      return yield Create2(ValueErrorType.BigInt, schema, path2, value2);
    if (IsDefined2(schema.exclusiveMaximum) && !(value2 < schema.exclusiveMaximum)) {
      yield Create2(ValueErrorType.BigIntExclusiveMaximum, schema, path2, value2);
    }
    if (IsDefined2(schema.exclusiveMinimum) && !(value2 > schema.exclusiveMinimum)) {
      yield Create2(ValueErrorType.BigIntExclusiveMinimum, schema, path2, value2);
    }
    if (IsDefined2(schema.maximum) && !(value2 <= schema.maximum)) {
      yield Create2(ValueErrorType.BigIntMaximum, schema, path2, value2);
    }
    if (IsDefined2(schema.minimum) && !(value2 >= schema.minimum)) {
      yield Create2(ValueErrorType.BigIntMinimum, schema, path2, value2);
    }
    if (IsDefined2(schema.multipleOf) && !(value2 % schema.multipleOf === BigInt(0))) {
      yield Create2(ValueErrorType.BigIntMultipleOf, schema, path2, value2);
    }
  }
  function* TBoolean2(schema, references, path2, value2) {
    if (!(0, guard_12.IsBoolean)(value2))
      yield Create2(ValueErrorType.Boolean, schema, path2, value2);
  }
  function* TConstructor2(schema, references, path2, value2) {
    yield* Visit2(schema.returns, references, path2, value2.prototype);
  }
  function* TDate2(schema, references, path2, value2) {
    if (!(0, guard_12.IsDate)(value2))
      return yield Create2(ValueErrorType.Date, schema, path2, value2);
    if (IsDefined2(schema.exclusiveMaximumTimestamp) && !(value2.getTime() < schema.exclusiveMaximumTimestamp)) {
      yield Create2(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path2, value2);
    }
    if (IsDefined2(schema.exclusiveMinimumTimestamp) && !(value2.getTime() > schema.exclusiveMinimumTimestamp)) {
      yield Create2(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path2, value2);
    }
    if (IsDefined2(schema.maximumTimestamp) && !(value2.getTime() <= schema.maximumTimestamp)) {
      yield Create2(ValueErrorType.DateMaximumTimestamp, schema, path2, value2);
    }
    if (IsDefined2(schema.minimumTimestamp) && !(value2.getTime() >= schema.minimumTimestamp)) {
      yield Create2(ValueErrorType.DateMinimumTimestamp, schema, path2, value2);
    }
    if (IsDefined2(schema.multipleOfTimestamp) && !(value2.getTime() % schema.multipleOfTimestamp === 0)) {
      yield Create2(ValueErrorType.DateMultipleOfTimestamp, schema, path2, value2);
    }
  }
  function* TFunction2(schema, references, path2, value2) {
    if (!(0, guard_12.IsFunction)(value2))
      yield Create2(ValueErrorType.Function, schema, path2, value2);
  }
  function* TInteger2(schema, references, path2, value2) {
    if (!(0, guard_12.IsInteger)(value2))
      return yield Create2(ValueErrorType.Integer, schema, path2, value2);
    if (IsDefined2(schema.exclusiveMaximum) && !(value2 < schema.exclusiveMaximum)) {
      yield Create2(ValueErrorType.IntegerExclusiveMaximum, schema, path2, value2);
    }
    if (IsDefined2(schema.exclusiveMinimum) && !(value2 > schema.exclusiveMinimum)) {
      yield Create2(ValueErrorType.IntegerExclusiveMinimum, schema, path2, value2);
    }
    if (IsDefined2(schema.maximum) && !(value2 <= schema.maximum)) {
      yield Create2(ValueErrorType.IntegerMaximum, schema, path2, value2);
    }
    if (IsDefined2(schema.minimum) && !(value2 >= schema.minimum)) {
      yield Create2(ValueErrorType.IntegerMinimum, schema, path2, value2);
    }
    if (IsDefined2(schema.multipleOf) && !(value2 % schema.multipleOf === 0)) {
      yield Create2(ValueErrorType.IntegerMultipleOf, schema, path2, value2);
    }
  }
  function* TIntersect2(schema, references, path2, value2) {
    for (const inner of schema.allOf) {
      const next = Visit2(inner, references, path2, value2).next();
      if (!next.done) {
        yield Create2(ValueErrorType.Intersect, schema, path2, value2);
        yield next.value;
      }
    }
    if (schema.unevaluatedProperties === false) {
      const keyCheck = new RegExp(Types2.KeyResolver.ResolvePattern(schema));
      for (const valueKey of Object.getOwnPropertyNames(value2)) {
        if (!keyCheck.test(valueKey)) {
          yield Create2(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path2}/${valueKey}`, value2);
        }
      }
    }
    if (typeof schema.unevaluatedProperties === "object") {
      const keyCheck = new RegExp(Types2.KeyResolver.ResolvePattern(schema));
      for (const valueKey of Object.getOwnPropertyNames(value2)) {
        if (!keyCheck.test(valueKey)) {
          const next = Visit2(schema.unevaluatedProperties, references, `${path2}/${valueKey}`, value2[valueKey]).next();
          if (!next.done)
            yield next.value;
        }
      }
    }
  }
  function* TIterator2(schema, references, path2, value2) {
    if (!(0, guard_12.IsIterator)(value2))
      yield Create2(ValueErrorType.Iterator, schema, path2, value2);
  }
  function* TLiteral2(schema, references, path2, value2) {
    if (!(value2 === schema.const))
      yield Create2(ValueErrorType.Literal, schema, path2, value2);
  }
  function* TNever2(schema, references, path2, value2) {
    yield Create2(ValueErrorType.Never, schema, path2, value2);
  }
  function* TNot2(schema, references, path2, value2) {
    if (Visit2(schema.not, references, path2, value2).next().done === true)
      yield Create2(ValueErrorType.Not, schema, path2, value2);
  }
  function* TNull2(schema, references, path2, value2) {
    if (!(0, guard_12.IsNull)(value2))
      yield Create2(ValueErrorType.Null, schema, path2, value2);
  }
  function* TNumber2(schema, references, path2, value2) {
    if (!system_1.TypeSystemPolicy.IsNumberLike(value2))
      return yield Create2(ValueErrorType.Number, schema, path2, value2);
    if (IsDefined2(schema.exclusiveMaximum) && !(value2 < schema.exclusiveMaximum)) {
      yield Create2(ValueErrorType.NumberExclusiveMaximum, schema, path2, value2);
    }
    if (IsDefined2(schema.exclusiveMinimum) && !(value2 > schema.exclusiveMinimum)) {
      yield Create2(ValueErrorType.NumberExclusiveMinimum, schema, path2, value2);
    }
    if (IsDefined2(schema.maximum) && !(value2 <= schema.maximum)) {
      yield Create2(ValueErrorType.NumberMaximum, schema, path2, value2);
    }
    if (IsDefined2(schema.minimum) && !(value2 >= schema.minimum)) {
      yield Create2(ValueErrorType.NumberMinimum, schema, path2, value2);
    }
    if (IsDefined2(schema.multipleOf) && !(value2 % schema.multipleOf === 0)) {
      yield Create2(ValueErrorType.NumberMultipleOf, schema, path2, value2);
    }
  }
  function* TObject2(schema, references, path2, value2) {
    if (!system_1.TypeSystemPolicy.IsObjectLike(value2))
      return yield Create2(ValueErrorType.Object, schema, path2, value2);
    if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value2).length >= schema.minProperties)) {
      yield Create2(ValueErrorType.ObjectMinProperties, schema, path2, value2);
    }
    if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value2).length <= schema.maxProperties)) {
      yield Create2(ValueErrorType.ObjectMaxProperties, schema, path2, value2);
    }
    const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    const unknownKeys = Object.getOwnPropertyNames(value2);
    for (const requiredKey of requiredKeys) {
      if (unknownKeys.includes(requiredKey))
        continue;
      yield Create2(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path2}/${EscapeKey(requiredKey)}`, void 0);
    }
    if (schema.additionalProperties === false) {
      for (const valueKey of unknownKeys) {
        if (!knownKeys.includes(valueKey)) {
          yield Create2(ValueErrorType.ObjectAdditionalProperties, schema, `${path2}/${EscapeKey(valueKey)}`, value2[valueKey]);
        }
      }
    }
    if (typeof schema.additionalProperties === "object") {
      for (const valueKey of unknownKeys) {
        if (knownKeys.includes(valueKey))
          continue;
        yield* Visit2(schema.additionalProperties, references, `${path2}/${EscapeKey(valueKey)}`, value2[valueKey]);
      }
    }
    for (const knownKey of knownKeys) {
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        yield* Visit2(property, references, `${path2}/${EscapeKey(knownKey)}`, value2[knownKey]);
        if (Types2.ExtendsUndefined.Check(schema) && !(knownKey in value2)) {
          yield Create2(ValueErrorType.ObjectRequiredProperty, property, `${path2}/${EscapeKey(knownKey)}`, void 0);
        }
      } else {
        if (system_1.TypeSystemPolicy.IsExactOptionalProperty(value2, knownKey)) {
          yield* Visit2(property, references, `${path2}/${EscapeKey(knownKey)}`, value2[knownKey]);
        }
      }
    }
  }
  function* TPromise2(schema, references, path2, value2) {
    if (!(0, guard_12.IsPromise)(value2))
      yield Create2(ValueErrorType.Promise, schema, path2, value2);
  }
  function* TRecord2(schema, references, path2, value2) {
    if (!system_1.TypeSystemPolicy.IsRecordLike(value2))
      return yield Create2(ValueErrorType.Object, schema, path2, value2);
    if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value2).length >= schema.minProperties)) {
      yield Create2(ValueErrorType.ObjectMinProperties, schema, path2, value2);
    }
    if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value2).length <= schema.maxProperties)) {
      yield Create2(ValueErrorType.ObjectMaxProperties, schema, path2, value2);
    }
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const regex = new RegExp(patternKey);
    for (const [propertyKey, propertyValue] of Object.entries(value2)) {
      if (regex.test(propertyKey))
        yield* Visit2(patternSchema, references, `${path2}/${EscapeKey(propertyKey)}`, propertyValue);
    }
    if (typeof schema.additionalProperties === "object") {
      for (const [propertyKey, propertyValue] of Object.entries(value2)) {
        if (!regex.test(propertyKey))
          yield* Visit2(schema.additionalProperties, references, `${path2}/${EscapeKey(propertyKey)}`, propertyValue);
      }
    }
    if (schema.additionalProperties === false) {
      for (const [propertyKey, propertyValue] of Object.entries(value2)) {
        if (regex.test(propertyKey))
          continue;
        return yield Create2(ValueErrorType.ObjectAdditionalProperties, schema, `${path2}/${EscapeKey(propertyKey)}`, propertyValue);
      }
    }
  }
  function* TRef2(schema, references, path2, value2) {
    yield* Visit2((0, deref_12.Deref)(schema, references), references, path2, value2);
  }
  function* TString2(schema, references, path2, value2) {
    if (!(0, guard_12.IsString)(value2))
      return yield Create2(ValueErrorType.String, schema, path2, value2);
    if (IsDefined2(schema.minLength) && !(value2.length >= schema.minLength)) {
      yield Create2(ValueErrorType.StringMinLength, schema, path2, value2);
    }
    if (IsDefined2(schema.maxLength) && !(value2.length <= schema.maxLength)) {
      yield Create2(ValueErrorType.StringMaxLength, schema, path2, value2);
    }
    if ((0, guard_12.IsString)(schema.pattern)) {
      const regex = new RegExp(schema.pattern);
      if (!regex.test(value2)) {
        yield Create2(ValueErrorType.StringPattern, schema, path2, value2);
      }
    }
    if ((0, guard_12.IsString)(schema.format)) {
      if (!Types2.FormatRegistry.Has(schema.format)) {
        yield Create2(ValueErrorType.StringFormatUnknown, schema, path2, value2);
      } else {
        const format = Types2.FormatRegistry.Get(schema.format);
        if (!format(value2)) {
          yield Create2(ValueErrorType.StringFormat, schema, path2, value2);
        }
      }
    }
  }
  function* TSymbol2(schema, references, path2, value2) {
    if (!(0, guard_12.IsSymbol)(value2))
      yield Create2(ValueErrorType.Symbol, schema, path2, value2);
  }
  function* TTemplateLiteral2(schema, references, path2, value2) {
    if (!(0, guard_12.IsString)(value2))
      return yield Create2(ValueErrorType.String, schema, path2, value2);
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value2)) {
      yield Create2(ValueErrorType.StringPattern, schema, path2, value2);
    }
  }
  function* TThis2(schema, references, path2, value2) {
    yield* Visit2((0, deref_12.Deref)(schema, references), references, path2, value2);
  }
  function* TTuple2(schema, references, path2, value2) {
    if (!(0, guard_12.IsArray)(value2))
      return yield Create2(ValueErrorType.Tuple, schema, path2, value2);
    if (schema.items === void 0 && !(value2.length === 0)) {
      return yield Create2(ValueErrorType.TupleLength, schema, path2, value2);
    }
    if (!(value2.length === schema.maxItems)) {
      return yield Create2(ValueErrorType.TupleLength, schema, path2, value2);
    }
    if (!schema.items) {
      return;
    }
    for (let i2 = 0; i2 < schema.items.length; i2++) {
      yield* Visit2(schema.items[i2], references, `${path2}/${i2}`, value2[i2]);
    }
  }
  function* TUndefined2(schema, references, path2, value2) {
    if (!(0, guard_12.IsUndefined)(value2))
      yield Create2(ValueErrorType.Undefined, schema, path2, value2);
  }
  function* TUnion2(schema, references, path2, value2) {
    let count = 0;
    for (const subschema of schema.anyOf) {
      const errors2 = [...Visit2(subschema, references, path2, value2)];
      if (errors2.length === 0)
        return;
      count += errors2.length;
    }
    if (count > 0) {
      yield Create2(ValueErrorType.Union, schema, path2, value2);
    }
  }
  function* TUint8Array2(schema, references, path2, value2) {
    if (!(0, guard_12.IsUint8Array)(value2))
      return yield Create2(ValueErrorType.Uint8Array, schema, path2, value2);
    if (IsDefined2(schema.maxByteLength) && !(value2.length <= schema.maxByteLength)) {
      yield Create2(ValueErrorType.Uint8ArrayMaxByteLength, schema, path2, value2);
    }
    if (IsDefined2(schema.minByteLength) && !(value2.length >= schema.minByteLength)) {
      yield Create2(ValueErrorType.Uint8ArrayMinByteLength, schema, path2, value2);
    }
  }
  function* TUnknown2(schema, references, path2, value2) {
  }
  function* TVoid2(schema, references, path2, value2) {
    if (!system_1.TypeSystemPolicy.IsVoidLike(value2))
      yield Create2(ValueErrorType.Void, schema, path2, value2);
  }
  function* TKind2(schema, references, path2, value2) {
    const check2 = Types2.TypeRegistry.Get(schema[Types2.Kind]);
    if (!check2(schema, value2))
      yield Create2(ValueErrorType.Kind, schema, path2, value2);
  }
  function* Visit2(schema, references, path2, value2) {
    const references_ = IsDefined2(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema_[Types2.Kind]) {
      case "Any":
        return yield* TAny2();
      case "Array":
        return yield* TArray2(schema_, references_, path2, value2);
      case "AsyncIterator":
        return yield* TAsyncIterator2(schema_, references_, path2, value2);
      case "BigInt":
        return yield* TBigInt2(schema_, references_, path2, value2);
      case "Boolean":
        return yield* TBoolean2(schema_, references_, path2, value2);
      case "Constructor":
        return yield* TConstructor2(schema_, references_, path2, value2);
      case "Date":
        return yield* TDate2(schema_, references_, path2, value2);
      case "Function":
        return yield* TFunction2(schema_, references_, path2, value2);
      case "Integer":
        return yield* TInteger2(schema_, references_, path2, value2);
      case "Intersect":
        return yield* TIntersect2(schema_, references_, path2, value2);
      case "Iterator":
        return yield* TIterator2(schema_, references_, path2, value2);
      case "Literal":
        return yield* TLiteral2(schema_, references_, path2, value2);
      case "Never":
        return yield* TNever2(schema_, references_, path2, value2);
      case "Not":
        return yield* TNot2(schema_, references_, path2, value2);
      case "Null":
        return yield* TNull2(schema_, references_, path2, value2);
      case "Number":
        return yield* TNumber2(schema_, references_, path2, value2);
      case "Object":
        return yield* TObject2(schema_, references_, path2, value2);
      case "Promise":
        return yield* TPromise2(schema_, references_, path2, value2);
      case "Record":
        return yield* TRecord2(schema_, references_, path2, value2);
      case "Ref":
        return yield* TRef2(schema_, references_, path2, value2);
      case "String":
        return yield* TString2(schema_, references_, path2, value2);
      case "Symbol":
        return yield* TSymbol2(schema_, references_, path2, value2);
      case "TemplateLiteral":
        return yield* TTemplateLiteral2(schema_, references_, path2, value2);
      case "This":
        return yield* TThis2(schema_, references_, path2, value2);
      case "Tuple":
        return yield* TTuple2(schema_, references_, path2, value2);
      case "Undefined":
        return yield* TUndefined2(schema_, references_, path2, value2);
      case "Union":
        return yield* TUnion2(schema_, references_, path2, value2);
      case "Uint8Array":
        return yield* TUint8Array2(schema_, references_, path2, value2);
      case "Unknown":
        return yield* TUnknown2();
      case "Void":
        return yield* TVoid2(schema_, references_, path2, value2);
      default:
        if (!Types2.TypeRegistry.Has(schema_[Types2.Kind]))
          throw new ValueErrorsUnknownTypeError(schema);
        return yield* TKind2(schema_, references_, path2, value2);
    }
  }
  function Errors(...args) {
    const iterator = args.length === 3 ? Visit2(args[0], args[1], "", args[2]) : Visit2(args[0], [], "", args[1]);
    return new ValueErrorIterator(iterator);
  }
  errors.Errors = Errors;
  return errors;
}
(function(exports2) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(requireErrors(), exports2);
})(errors$1);
var delta = {};
var pointer = {};
Object.defineProperty(pointer, "__esModule", { value: true });
pointer.ValuePointer = pointer.ValuePointerRootDeleteError = pointer.ValuePointerRootSetError = void 0;
class ValuePointerRootSetError extends Error {
  constructor(value2, path2, update) {
    super("Cannot set root value");
    this.value = value2;
    this.path = path2;
    this.update = update;
  }
}
pointer.ValuePointerRootSetError = ValuePointerRootSetError;
class ValuePointerRootDeleteError extends Error {
  constructor(value2, path2) {
    super("Cannot delete root value");
    this.value = value2;
    this.path = path2;
  }
}
pointer.ValuePointerRootDeleteError = ValuePointerRootDeleteError;
var ValuePointer;
(function(ValuePointer2) {
  function Escape(component) {
    return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  function* Format(pointer2) {
    if (pointer2 === "")
      return;
    let [start, end] = [0, 0];
    for (let i2 = 0; i2 < pointer2.length; i2++) {
      const char = pointer2.charAt(i2);
      if (char === "/") {
        if (i2 === 0) {
          start = i2 + 1;
        } else {
          end = i2;
          yield Escape(pointer2.slice(start, end));
          start = i2 + 1;
        }
      } else {
        end = i2;
      }
    }
    yield Escape(pointer2.slice(start));
  }
  ValuePointer2.Format = Format;
  function Set2(value2, pointer2, update) {
    if (pointer2 === "")
      throw new ValuePointerRootSetError(value2, pointer2, update);
    let [owner, next, key] = [null, value2, ""];
    for (const component of Format(pointer2)) {
      if (next[component] === void 0)
        next[component] = {};
      owner = next;
      next = next[component];
      key = component;
    }
    owner[key] = update;
  }
  ValuePointer2.Set = Set2;
  function Delete(value2, pointer2) {
    if (pointer2 === "")
      throw new ValuePointerRootDeleteError(value2, pointer2);
    let [owner, next, key] = [null, value2, ""];
    for (const component of Format(pointer2)) {
      if (next[component] === void 0 || next[component] === null)
        return;
      owner = next;
      next = next[component];
      key = component;
    }
    if (Array.isArray(owner)) {
      const index = parseInt(key);
      owner.splice(index, 1);
    } else {
      delete owner[key];
    }
  }
  ValuePointer2.Delete = Delete;
  function Has(value2, pointer2) {
    if (pointer2 === "")
      return true;
    let [owner, next, key] = [null, value2, ""];
    for (const component of Format(pointer2)) {
      if (next[component] === void 0)
        return false;
      owner = next;
      next = next[component];
      key = component;
    }
    return Object.getOwnPropertyNames(owner).includes(key);
  }
  ValuePointer2.Has = Has;
  function Get(value2, pointer2) {
    if (pointer2 === "")
      return value2;
    let current = value2;
    for (const component of Format(pointer2)) {
      if (current[component] === void 0)
        return void 0;
      current = current[component];
    }
    return current;
  }
  ValuePointer2.Get = Get;
})(ValuePointer || (pointer.ValuePointer = ValuePointer = {}));
var clone = {};
Object.defineProperty(clone, "__esModule", { value: true });
clone.Clone = void 0;
const guard_1$8 = guard;
function ObjectType$2(value2) {
  const keys = [...Object.getOwnPropertyNames(value2), ...Object.getOwnPropertySymbols(value2)];
  return keys.reduce((acc, key) => ({ ...acc, [key]: Clone(value2[key]) }), {});
}
function ArrayType$2(value2) {
  return value2.map((element) => Clone(element));
}
function TypedArrayType$2(value2) {
  return value2.slice();
}
function DateType$1(value2) {
  return new Date(value2.toISOString());
}
function ValueType$2(value2) {
  return value2;
}
function Clone(value2) {
  if ((0, guard_1$8.IsArray)(value2))
    return ArrayType$2(value2);
  if ((0, guard_1$8.IsDate)(value2))
    return DateType$1(value2);
  if ((0, guard_1$8.IsPlainObject)(value2))
    return ObjectType$2(value2);
  if ((0, guard_1$8.IsTypedArray)(value2))
    return TypedArrayType$2(value2);
  if ((0, guard_1$8.IsValueType)(value2))
    return ValueType$2(value2);
  throw new Error("ValueClone: Unable to clone value");
}
clone.Clone = Clone;
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Patch = exports2.Diff = exports2.ValueDeltaUnableToDiffUnknownValue = exports2.ValueDeltaObjectWithSymbolKeyError = exports2.Edit = exports2.Delete = exports2.Update = exports2.Insert = void 0;
  const guard_12 = guard;
  const typebox_12 = typebox;
  const pointer_12 = pointer;
  const clone_12 = clone;
  exports2.Insert = typebox_12.Type.Object({
    type: typebox_12.Type.Literal("insert"),
    path: typebox_12.Type.String(),
    value: typebox_12.Type.Unknown()
  });
  exports2.Update = typebox_12.Type.Object({
    type: typebox_12.Type.Literal("update"),
    path: typebox_12.Type.String(),
    value: typebox_12.Type.Unknown()
  });
  exports2.Delete = typebox_12.Type.Object({
    type: typebox_12.Type.Literal("delete"),
    path: typebox_12.Type.String()
  });
  exports2.Edit = typebox_12.Type.Union([exports2.Insert, exports2.Update, exports2.Delete]);
  class ValueDeltaObjectWithSymbolKeyError extends Error {
    constructor(key) {
      super("Cannot diff objects with symbol keys");
      this.key = key;
    }
  }
  exports2.ValueDeltaObjectWithSymbolKeyError = ValueDeltaObjectWithSymbolKeyError;
  class ValueDeltaUnableToDiffUnknownValue extends Error {
    constructor(value2) {
      super("Unable to create diff edits for unknown value");
      this.value = value2;
    }
  }
  exports2.ValueDeltaUnableToDiffUnknownValue = ValueDeltaUnableToDiffUnknownValue;
  function CreateUpdate(path2, value2) {
    return { type: "update", path: path2, value: value2 };
  }
  function CreateInsert(path2, value2) {
    return { type: "insert", path: path2, value: value2 };
  }
  function CreateDelete(path2) {
    return { type: "delete", path: path2 };
  }
  function* ObjectType2(path2, current, next) {
    if (!(0, guard_12.IsPlainObject)(next))
      return yield CreateUpdate(path2, next);
    const currentKeys = [...Object.keys(current), ...Object.getOwnPropertySymbols(current)];
    const nextKeys = [...Object.keys(next), ...Object.getOwnPropertySymbols(next)];
    for (const key of currentKeys) {
      if ((0, guard_12.IsSymbol)(key))
        throw new ValueDeltaObjectWithSymbolKeyError(key);
      if ((0, guard_12.IsUndefined)(next[key]) && nextKeys.includes(key))
        yield CreateUpdate(`${path2}/${String(key)}`, void 0);
    }
    for (const key of nextKeys) {
      if ((0, guard_12.IsUndefined)(current[key]) || (0, guard_12.IsUndefined)(next[key]))
        continue;
      if ((0, guard_12.IsSymbol)(key))
        throw new ValueDeltaObjectWithSymbolKeyError(key);
      yield* Visit2(`${path2}/${String(key)}`, current[key], next[key]);
    }
    for (const key of nextKeys) {
      if ((0, guard_12.IsSymbol)(key))
        throw new ValueDeltaObjectWithSymbolKeyError(key);
      if ((0, guard_12.IsUndefined)(current[key]))
        yield CreateInsert(`${path2}/${String(key)}`, next[key]);
    }
    for (const key of currentKeys.reverse()) {
      if ((0, guard_12.IsSymbol)(key))
        throw new ValueDeltaObjectWithSymbolKeyError(key);
      if ((0, guard_12.IsUndefined)(next[key]) && !nextKeys.includes(key))
        yield CreateDelete(`${path2}/${String(key)}`);
    }
  }
  function* ArrayType2(path2, current, next) {
    if (!(0, guard_12.IsArray)(next))
      return yield CreateUpdate(path2, next);
    for (let i2 = 0; i2 < Math.min(current.length, next.length); i2++) {
      yield* Visit2(`${path2}/${i2}`, current[i2], next[i2]);
    }
    for (let i2 = 0; i2 < next.length; i2++) {
      if (i2 < current.length)
        continue;
      yield CreateInsert(`${path2}/${i2}`, next[i2]);
    }
    for (let i2 = current.length - 1; i2 >= 0; i2--) {
      if (i2 < next.length)
        continue;
      yield CreateDelete(`${path2}/${i2}`);
    }
  }
  function* TypedArrayType2(path2, current, next) {
    if (!(0, guard_12.IsTypedArray)(next) || current.length !== next.length || Object.getPrototypeOf(current).constructor.name !== Object.getPrototypeOf(next).constructor.name)
      return yield CreateUpdate(path2, next);
    for (let i2 = 0; i2 < Math.min(current.length, next.length); i2++) {
      yield* Visit2(`${path2}/${i2}`, current[i2], next[i2]);
    }
  }
  function* ValueType2(path2, current, next) {
    if (current === next)
      return;
    yield CreateUpdate(path2, next);
  }
  function* Visit2(path2, current, next) {
    if ((0, guard_12.IsPlainObject)(current))
      return yield* ObjectType2(path2, current, next);
    if ((0, guard_12.IsArray)(current))
      return yield* ArrayType2(path2, current, next);
    if ((0, guard_12.IsTypedArray)(current))
      return yield* TypedArrayType2(path2, current, next);
    if ((0, guard_12.IsValueType)(current))
      return yield* ValueType2(path2, current, next);
    throw new ValueDeltaUnableToDiffUnknownValue(current);
  }
  function Diff(current, next) {
    return [...Visit2("", current, next)];
  }
  exports2.Diff = Diff;
  function IsRootUpdate(edits) {
    return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
  }
  function IsIdentity(edits) {
    return edits.length === 0;
  }
  function Patch(current, edits) {
    if (IsRootUpdate(edits)) {
      return (0, clone_12.Clone)(edits[0].value);
    }
    if (IsIdentity(edits)) {
      return (0, clone_12.Clone)(current);
    }
    const clone2 = (0, clone_12.Clone)(current);
    for (const edit of edits) {
      switch (edit.type) {
        case "insert": {
          pointer_12.ValuePointer.Set(clone2, edit.path, edit.value);
          break;
        }
        case "update": {
          pointer_12.ValuePointer.Set(clone2, edit.path, edit.value);
          break;
        }
        case "delete": {
          pointer_12.ValuePointer.Delete(clone2, edit.path);
          break;
        }
      }
    }
    return clone2;
  }
  exports2.Patch = Patch;
})(delta);
var value = {};
var mutate = {};
Object.defineProperty(mutate, "__esModule", { value: true });
mutate.Mutate = mutate.ValueMutateInvalidRootMutationError = mutate.ValueMutateTypeMismatchError = void 0;
const guard_1$7 = guard;
const pointer_1 = pointer;
const clone_1$2 = clone;
class ValueMutateTypeMismatchError extends Error {
  constructor() {
    super("Cannot assign due type mismatch of assignable values");
  }
}
mutate.ValueMutateTypeMismatchError = ValueMutateTypeMismatchError;
class ValueMutateInvalidRootMutationError extends Error {
  constructor() {
    super("Only object and array types can be mutated at the root level");
  }
}
mutate.ValueMutateInvalidRootMutationError = ValueMutateInvalidRootMutationError;
function ObjectType$1(root, path2, current, next) {
  if (!(0, guard_1$7.IsPlainObject)(current)) {
    pointer_1.ValuePointer.Set(root, path2, (0, clone_1$2.Clone)(next));
  } else {
    const currentKeys = Object.keys(current);
    const nextKeys = Object.keys(next);
    for (const currentKey of currentKeys) {
      if (!nextKeys.includes(currentKey)) {
        delete current[currentKey];
      }
    }
    for (const nextKey of nextKeys) {
      if (!currentKeys.includes(nextKey)) {
        current[nextKey] = null;
      }
    }
    for (const nextKey of nextKeys) {
      Visit$4(root, `${path2}/${nextKey}`, current[nextKey], next[nextKey]);
    }
  }
}
function ArrayType$1(root, path2, current, next) {
  if (!(0, guard_1$7.IsArray)(current)) {
    pointer_1.ValuePointer.Set(root, path2, (0, clone_1$2.Clone)(next));
  } else {
    for (let index = 0; index < next.length; index++) {
      Visit$4(root, `${path2}/${index}`, current[index], next[index]);
    }
    current.splice(next.length);
  }
}
function TypedArrayType$1(root, path2, current, next) {
  if ((0, guard_1$7.IsTypedArray)(current) && current.length === next.length) {
    for (let i2 = 0; i2 < current.length; i2++) {
      current[i2] = next[i2];
    }
  } else {
    pointer_1.ValuePointer.Set(root, path2, (0, clone_1$2.Clone)(next));
  }
}
function ValueType$1(root, path2, current, next) {
  if (current === next)
    return;
  pointer_1.ValuePointer.Set(root, path2, next);
}
function Visit$4(root, path2, current, next) {
  if ((0, guard_1$7.IsArray)(next))
    return ArrayType$1(root, path2, current, next);
  if ((0, guard_1$7.IsTypedArray)(next))
    return TypedArrayType$1(root, path2, current, next);
  if ((0, guard_1$7.IsPlainObject)(next))
    return ObjectType$1(root, path2, current, next);
  if ((0, guard_1$7.IsValueType)(next))
    return ValueType$1(root, path2, current, next);
}
function IsNonMutableValue(value2) {
  return (0, guard_1$7.IsTypedArray)(value2) || (0, guard_1$7.IsValueType)(value2);
}
function IsMismatchedValue(current, next) {
  return (0, guard_1$7.IsPlainObject)(current) && (0, guard_1$7.IsArray)(next) || (0, guard_1$7.IsArray)(current) && (0, guard_1$7.IsPlainObject)(next);
}
function Mutate(current, next) {
  if (IsNonMutableValue(current) || IsNonMutableValue(next))
    throw new ValueMutateInvalidRootMutationError();
  if (IsMismatchedValue(current, next))
    throw new ValueMutateTypeMismatchError();
  Visit$4(current, "", current, next);
}
mutate.Mutate = Mutate;
var equal = {};
Object.defineProperty(equal, "__esModule", { value: true });
equal.Equal = void 0;
const guard_1$6 = guard;
function ObjectType(left, right) {
  if (!(0, guard_1$6.IsPlainObject)(right))
    return false;
  const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
  const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
  if (leftKeys.length !== rightKeys.length)
    return false;
  return leftKeys.every((key) => Equal(left[key], right[key]));
}
function DateType(left, right) {
  return (0, guard_1$6.IsDate)(right) && left.getTime() === right.getTime();
}
function ArrayType(left, right) {
  if (!(0, guard_1$6.IsArray)(right) || left.length !== right.length)
    return false;
  return left.every((value2, index) => Equal(value2, right[index]));
}
function TypedArrayType(left, right) {
  if (!(0, guard_1$6.IsTypedArray)(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
    return false;
  return left.every((value2, index) => Equal(value2, right[index]));
}
function ValueType(left, right) {
  return left === right;
}
function Equal(left, right) {
  if ((0, guard_1$6.IsPlainObject)(left))
    return ObjectType(left, right);
  if ((0, guard_1$6.IsDate)(left))
    return DateType(left, right);
  if ((0, guard_1$6.IsTypedArray)(left))
    return TypedArrayType(left, right);
  if ((0, guard_1$6.IsArray)(left))
    return ArrayType(left, right);
  if ((0, guard_1$6.IsValueType)(left))
    return ValueType(left, right);
  throw new Error("ValueEquals: Unable to compare value");
}
equal.Equal = Equal;
var cast = {};
var create = {};
var check = {};
var system = {};
(function(exports2) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ValueErrorType = void 0;
  var errors_12 = requireErrors();
  Object.defineProperty(exports2, "ValueErrorType", { enumerable: true, get: function() {
    return errors_12.ValueErrorType;
  } });
  __exportStar(requireSystem(), exports2);
})(system);
Object.defineProperty(check, "__esModule", { value: true });
check.Check = check.ValueCheckUnknownTypeError = void 0;
const guard_1$5 = guard;
const index_1$1 = system;
const deref_1$5 = deref;
const hash_1$1 = hash$1;
const Types$5 = typebox;
class ValueCheckUnknownTypeError extends Types$5.TypeBoxError {
  constructor(schema) {
    super(`Unknown type`);
    this.schema = schema;
  }
}
check.ValueCheckUnknownTypeError = ValueCheckUnknownTypeError;
function IsAnyOrUnknown(schema) {
  return schema[Types$5.Kind] === "Any" || schema[Types$5.Kind] === "Unknown";
}
function IsDefined(value2) {
  return value2 !== void 0;
}
function TAny$1(schema, references, value2) {
  return true;
}
function TArray$3(schema, references, value2) {
  if (!(0, guard_1$5.IsArray)(value2))
    return false;
  if (IsDefined(schema.minItems) && !(value2.length >= schema.minItems)) {
    return false;
  }
  if (IsDefined(schema.maxItems) && !(value2.length <= schema.maxItems)) {
    return false;
  }
  if (!value2.every((value3) => Visit$3(schema.items, references, value3))) {
    return false;
  }
  if (schema.uniqueItems === true && !function() {
    const set = /* @__PURE__ */ new Set();
    for (const element of value2) {
      const hashed = (0, hash_1$1.Hash)(element);
      if (set.has(hashed)) {
        return false;
      } else {
        set.add(hashed);
      }
    }
    return true;
  }()) {
    return false;
  }
  if (!(IsDefined(schema.contains) || (0, guard_1$5.IsNumber)(schema.minContains) || (0, guard_1$5.IsNumber)(schema.maxContains))) {
    return true;
  }
  const containsSchema = IsDefined(schema.contains) ? schema.contains : Types$5.Type.Never();
  const containsCount = value2.reduce((acc, value3) => Visit$3(containsSchema, references, value3) ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    return false;
  }
  if ((0, guard_1$5.IsNumber)(schema.minContains) && containsCount < schema.minContains) {
    return false;
  }
  if ((0, guard_1$5.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {
    return false;
  }
  return true;
}
function TAsyncIterator$1(schema, references, value2) {
  return (0, guard_1$5.IsAsyncIterator)(value2);
}
function TBigInt$2(schema, references, value2) {
  if (!(0, guard_1$5.IsBigInt)(value2))
    return false;
  if (IsDefined(schema.exclusiveMaximum) && !(value2 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value2 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value2 <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value2 >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value2 % schema.multipleOf === BigInt(0))) {
    return false;
  }
  return true;
}
function TBoolean$2(schema, references, value2) {
  return (0, guard_1$5.IsBoolean)(value2);
}
function TConstructor$2(schema, references, value2) {
  return Visit$3(schema.returns, references, value2.prototype);
}
function TDate$2(schema, references, value2) {
  if (!(0, guard_1$5.IsDate)(value2))
    return false;
  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value2.getTime() < schema.exclusiveMaximumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value2.getTime() > schema.exclusiveMinimumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.maximumTimestamp) && !(value2.getTime() <= schema.maximumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.minimumTimestamp) && !(value2.getTime() >= schema.minimumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.multipleOfTimestamp) && !(value2.getTime() % schema.multipleOfTimestamp === 0)) {
    return false;
  }
  return true;
}
function TFunction$1(schema, references, value2) {
  return (0, guard_1$5.IsFunction)(value2);
}
function TInteger$2(schema, references, value2) {
  if (!(0, guard_1$5.IsInteger)(value2)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMaximum) && !(value2 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value2 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value2 <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value2 >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value2 % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function TIntersect$3(schema, references, value2) {
  const check1 = schema.allOf.every((schema2) => Visit$3(schema2, references, value2));
  if (schema.unevaluatedProperties === false) {
    const keyPattern = new RegExp(Types$5.KeyResolver.ResolvePattern(schema));
    const check2 = Object.getOwnPropertyNames(value2).every((key) => keyPattern.test(key));
    return check1 && check2;
  } else if (Types$5.TypeGuard.TSchema(schema.unevaluatedProperties)) {
    const keyCheck = new RegExp(Types$5.KeyResolver.ResolvePattern(schema));
    const check2 = Object.getOwnPropertyNames(value2).every((key) => keyCheck.test(key) || Visit$3(schema.unevaluatedProperties, references, value2[key]));
    return check1 && check2;
  } else {
    return check1;
  }
}
function TIterator$1(schema, references, value2) {
  return (0, guard_1$5.IsIterator)(value2);
}
function TLiteral$2(schema, references, value2) {
  return value2 === schema.const;
}
function TNever$2(schema, references, value2) {
  return false;
}
function TNot$1(schema, references, value2) {
  return !Visit$3(schema.not, references, value2);
}
function TNull$2(schema, references, value2) {
  return (0, guard_1$5.IsNull)(value2);
}
function TNumber$2(schema, references, value2) {
  if (!index_1$1.TypeSystemPolicy.IsNumberLike(value2))
    return false;
  if (IsDefined(schema.exclusiveMaximum) && !(value2 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value2 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value2 >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value2 <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value2 % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function TObject$3(schema, references, value2) {
  if (!index_1$1.TypeSystemPolicy.IsObjectLike(value2))
    return false;
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value2).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value2).length <= schema.maxProperties)) {
    return false;
  }
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      if (!Visit$3(property, references, value2[knownKey])) {
        return false;
      }
      if ((Types$5.ExtendsUndefined.Check(property) || IsAnyOrUnknown(property)) && !(knownKey in value2)) {
        return false;
      }
    } else {
      if (index_1$1.TypeSystemPolicy.IsExactOptionalProperty(value2, knownKey) && !Visit$3(property, references, value2[knownKey])) {
        return false;
      }
    }
  }
  if (schema.additionalProperties === false) {
    const valueKeys = Object.getOwnPropertyNames(value2);
    if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
      return true;
    } else {
      return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
    }
  } else if (typeof schema.additionalProperties === "object") {
    const valueKeys = Object.getOwnPropertyNames(value2);
    return valueKeys.every((key) => knownKeys.includes(key) || Visit$3(schema.additionalProperties, references, value2[key]));
  } else {
    return true;
  }
}
function TPromise$1(schema, references, value2) {
  return (0, guard_1$5.IsPromise)(value2);
}
function TRecord$3(schema, references, value2) {
  if (!index_1$1.TypeSystemPolicy.IsRecordLike(value2)) {
    return false;
  }
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value2).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value2).length <= schema.maxProperties)) {
    return false;
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  const check1 = Object.entries(value2).every(([key, value3]) => {
    return regex.test(key) ? Visit$3(patternSchema, references, value3) : true;
  });
  const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value2).every(([key, value3]) => {
    return !regex.test(key) ? Visit$3(schema.additionalProperties, references, value3) : true;
  }) : true;
  const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value2).every((key) => {
    return regex.test(key);
  }) : true;
  return check1 && check2 && check3;
}
function TRef$3(schema, references, value2) {
  return Visit$3((0, deref_1$5.Deref)(schema, references), references, value2);
}
function TString$2(schema, references, value2) {
  if (!(0, guard_1$5.IsString)(value2)) {
    return false;
  }
  if (IsDefined(schema.minLength)) {
    if (!(value2.length >= schema.minLength))
      return false;
  }
  if (IsDefined(schema.maxLength)) {
    if (!(value2.length <= schema.maxLength))
      return false;
  }
  if (IsDefined(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value2))
      return false;
  }
  if (IsDefined(schema.format)) {
    if (!Types$5.FormatRegistry.Has(schema.format))
      return false;
    const func = Types$5.FormatRegistry.Get(schema.format);
    return func(value2);
  }
  return true;
}
function TSymbol$2(schema, references, value2) {
  return (0, guard_1$5.IsSymbol)(value2);
}
function TTemplateLiteral$1(schema, references, value2) {
  return (0, guard_1$5.IsString)(value2) && new RegExp(schema.pattern).test(value2);
}
function TThis$3(schema, references, value2) {
  return Visit$3((0, deref_1$5.Deref)(schema, references), references, value2);
}
function TTuple$3(schema, references, value2) {
  if (!(0, guard_1$5.IsArray)(value2)) {
    return false;
  }
  if (schema.items === void 0 && !(value2.length === 0)) {
    return false;
  }
  if (!(value2.length === schema.maxItems)) {
    return false;
  }
  if (!schema.items) {
    return true;
  }
  for (let i2 = 0; i2 < schema.items.length; i2++) {
    if (!Visit$3(schema.items[i2], references, value2[i2]))
      return false;
  }
  return true;
}
function TUndefined$2(schema, references, value2) {
  return (0, guard_1$5.IsUndefined)(value2);
}
function TUnion$3(schema, references, value2) {
  return schema.anyOf.some((inner) => Visit$3(inner, references, value2));
}
function TUint8Array$1(schema, references, value2) {
  if (!(0, guard_1$5.IsUint8Array)(value2)) {
    return false;
  }
  if (IsDefined(schema.maxByteLength) && !(value2.length <= schema.maxByteLength)) {
    return false;
  }
  if (IsDefined(schema.minByteLength) && !(value2.length >= schema.minByteLength)) {
    return false;
  }
  return true;
}
function TUnknown$1(schema, references, value2) {
  return true;
}
function TVoid$1(schema, references, value2) {
  return index_1$1.TypeSystemPolicy.IsVoidLike(value2);
}
function TKind$1(schema, references, value2) {
  if (!Types$5.TypeRegistry.Has(schema[Types$5.Kind]))
    return false;
  const func = Types$5.TypeRegistry.Get(schema[Types$5.Kind]);
  return func(schema, value2);
}
function Visit$3(schema, references, value2) {
  const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Types$5.Kind]) {
    case "Any":
      return TAny$1();
    case "Array":
      return TArray$3(schema_, references_, value2);
    case "AsyncIterator":
      return TAsyncIterator$1(schema_, references_, value2);
    case "BigInt":
      return TBigInt$2(schema_, references_, value2);
    case "Boolean":
      return TBoolean$2(schema_, references_, value2);
    case "Constructor":
      return TConstructor$2(schema_, references_, value2);
    case "Date":
      return TDate$2(schema_, references_, value2);
    case "Function":
      return TFunction$1(schema_, references_, value2);
    case "Integer":
      return TInteger$2(schema_, references_, value2);
    case "Intersect":
      return TIntersect$3(schema_, references_, value2);
    case "Iterator":
      return TIterator$1(schema_, references_, value2);
    case "Literal":
      return TLiteral$2(schema_, references_, value2);
    case "Never":
      return TNever$2();
    case "Not":
      return TNot$1(schema_, references_, value2);
    case "Null":
      return TNull$2(schema_, references_, value2);
    case "Number":
      return TNumber$2(schema_, references_, value2);
    case "Object":
      return TObject$3(schema_, references_, value2);
    case "Promise":
      return TPromise$1(schema_, references_, value2);
    case "Record":
      return TRecord$3(schema_, references_, value2);
    case "Ref":
      return TRef$3(schema_, references_, value2);
    case "String":
      return TString$2(schema_, references_, value2);
    case "Symbol":
      return TSymbol$2(schema_, references_, value2);
    case "TemplateLiteral":
      return TTemplateLiteral$1(schema_, references_, value2);
    case "This":
      return TThis$3(schema_, references_, value2);
    case "Tuple":
      return TTuple$3(schema_, references_, value2);
    case "Undefined":
      return TUndefined$2(schema_, references_, value2);
    case "Union":
      return TUnion$3(schema_, references_, value2);
    case "Uint8Array":
      return TUint8Array$1(schema_, references_, value2);
    case "Unknown":
      return TUnknown$1();
    case "Void":
      return TVoid$1(schema_, references_, value2);
    default:
      if (!Types$5.TypeRegistry.Has(schema_[Types$5.Kind]))
        throw new ValueCheckUnknownTypeError(schema_);
      return TKind$1(schema_, references_, value2);
  }
}
function Check(...args) {
  return args.length === 3 ? Visit$3(args[0], args[1], args[2]) : Visit$3(args[0], [], args[1]);
}
check.Check = Check;
Object.defineProperty(create, "__esModule", { value: true });
create.Create = create.ValueCreateRecursiveInstantiationError = create.ValueCreateTempateLiteralTypeError = create.ValueCreateIntersectTypeError = create.ValueCreateNotTypeError = create.ValueCreateNeverTypeError = create.ValueCreateUnknownTypeError = void 0;
const guard_1$4 = guard;
const check_1$3 = check;
const deref_1$4 = deref;
const Types$4 = typebox;
class ValueCreateUnknownTypeError extends Types$4.TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}
create.ValueCreateUnknownTypeError = ValueCreateUnknownTypeError;
class ValueCreateNeverTypeError extends Types$4.TypeBoxError {
  constructor(schema) {
    super("Never types cannot be created");
    this.schema = schema;
  }
}
create.ValueCreateNeverTypeError = ValueCreateNeverTypeError;
class ValueCreateNotTypeError extends Types$4.TypeBoxError {
  constructor(schema) {
    super("Not types must have a default value");
    this.schema = schema;
  }
}
create.ValueCreateNotTypeError = ValueCreateNotTypeError;
class ValueCreateIntersectTypeError extends Types$4.TypeBoxError {
  constructor(schema) {
    super("Intersect produced invalid value. Consider using a default value.");
    this.schema = schema;
  }
}
create.ValueCreateIntersectTypeError = ValueCreateIntersectTypeError;
class ValueCreateTempateLiteralTypeError extends Types$4.TypeBoxError {
  constructor(schema) {
    super("Can only create template literal values from patterns that produce finite sequences. Consider using a default value.");
    this.schema = schema;
  }
}
create.ValueCreateTempateLiteralTypeError = ValueCreateTempateLiteralTypeError;
class ValueCreateRecursiveInstantiationError extends Types$4.TypeBoxError {
  constructor(schema, recursiveMaxDepth2) {
    super("Value cannot be created as recursive type may produce value of infinite size. Consider using a default.");
    this.schema = schema;
    this.recursiveMaxDepth = recursiveMaxDepth2;
  }
}
create.ValueCreateRecursiveInstantiationError = ValueCreateRecursiveInstantiationError;
function TAny(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    return {};
  }
}
function TArray$2(schema, references) {
  if (schema.uniqueItems === true && !(0, guard_1$4.HasPropertyKey)(schema, "default")) {
    throw new Error("ValueCreate.Array: Array with the uniqueItems constraint requires a default value");
  } else if ("contains" in schema && !(0, guard_1$4.HasPropertyKey)(schema, "default")) {
    throw new Error("ValueCreate.Array: Array with the contains constraint requires a default value");
  } else if ("default" in schema) {
    return schema.default;
  } else if (schema.minItems !== void 0) {
    return Array.from({ length: schema.minItems }).map((item) => {
      return Visit$2(schema.items, references);
    });
  } else {
    return [];
  }
}
function TAsyncIterator(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    return /* @__PURE__ */ async function* () {
    }();
  }
}
function TBigInt$1(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    return BigInt(0);
  }
}
function TBoolean$1(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    return false;
  }
}
function TConstructor$1(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    const value2 = Visit$2(schema.returns, references);
    if (typeof value2 === "object" && !Array.isArray(value2)) {
      return class {
        constructor() {
          for (const [key, val] of Object.entries(value2)) {
            const self2 = this;
            self2[key] = val;
          }
        }
      };
    } else {
      return class {
      };
    }
  }
}
function TDate$1(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else if (schema.minimumTimestamp !== void 0) {
    return new Date(schema.minimumTimestamp);
  } else {
    return /* @__PURE__ */ new Date();
  }
}
function TFunction(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    return () => Visit$2(schema.returns, references);
  }
}
function TInteger$1(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else if (schema.minimum !== void 0) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function TIntersect$2(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    const value2 = schema.allOf.reduce((acc, schema2) => {
      const next = Visit$2(schema2, references);
      return typeof next === "object" ? { ...acc, ...next } : next;
    }, {});
    if (!(0, check_1$3.Check)(schema, references, value2))
      throw new ValueCreateIntersectTypeError(schema);
    return value2;
  }
}
function TIterator(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    return /* @__PURE__ */ function* () {
    }();
  }
}
function TLiteral$1(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    return schema.const;
  }
}
function TNever$1(schema, references) {
  throw new ValueCreateNeverTypeError(schema);
}
function TNot(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    throw new ValueCreateNotTypeError(schema);
  }
}
function TNull$1(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    return null;
  }
}
function TNumber$1(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else if (schema.minimum !== void 0) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function TObject$2(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    const required = new Set(schema.required);
    return schema.default || Object.entries(schema.properties).reduce((acc, [key, schema2]) => {
      return required.has(key) ? { ...acc, [key]: Visit$2(schema2, references) } : { ...acc };
    }, {});
  }
}
function TPromise(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    return Promise.resolve(Visit$2(schema.item, references));
  }
}
function TRecord$2(schema, references) {
  const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else if (!(keyPattern === Types$4.PatternStringExact || keyPattern === Types$4.PatternNumberExact)) {
    const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
    return propertyKeys.reduce((acc, key) => {
      return { ...acc, [key]: Visit$2(valueSchema, references) };
    }, {});
  } else {
    return {};
  }
}
function TRef$2(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    return Visit$2((0, deref_1$4.Deref)(schema, references), references);
  }
}
function TString$1(schema, references) {
  if (schema.pattern !== void 0) {
    if (!(0, guard_1$4.HasPropertyKey)(schema, "default")) {
      throw new Error("ValueCreate.String: String types with patterns must specify a default value");
    } else {
      return schema.default;
    }
  } else if (schema.format !== void 0) {
    if (!(0, guard_1$4.HasPropertyKey)(schema, "default")) {
      throw new Error("ValueCreate.String: String types with formats must specify a default value");
    } else {
      return schema.default;
    }
  } else {
    if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else if (schema.minLength !== void 0) {
      return Array.from({ length: schema.minLength }).map(() => ".").join("");
    } else {
      return "";
    }
  }
}
function TSymbol$1(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else if ("value" in schema) {
    return Symbol.for(schema.value);
  } else {
    return Symbol();
  }
}
function TTemplateLiteral(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  }
  const expression = Types$4.TemplateLiteralParser.ParseExact(schema.pattern);
  if (!Types$4.TemplateLiteralFinite.Check(expression))
    throw new ValueCreateTempateLiteralTypeError(schema);
  const sequence = Types$4.TemplateLiteralGenerator.Generate(expression);
  return sequence.next().value;
}
function TThis$2(schema, references) {
  if (recursiveDepth++ > recursiveMaxDepth)
    throw new ValueCreateRecursiveInstantiationError(schema, recursiveMaxDepth);
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    return Visit$2((0, deref_1$4.Deref)(schema, references), references);
  }
}
function TTuple$2(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  }
  if (schema.items === void 0) {
    return [];
  } else {
    return Array.from({ length: schema.minItems }).map((_, index) => Visit$2(schema.items[index], references));
  }
}
function TUndefined$1(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    return void 0;
  }
}
function TUnion$2(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else if (schema.anyOf.length === 0) {
    throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
  } else {
    return Visit$2(schema.anyOf[0], references);
  }
}
function TUint8Array(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else if (schema.minByteLength !== void 0) {
    return new Uint8Array(schema.minByteLength);
  } else {
    return new Uint8Array(0);
  }
}
function TUnknown(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    return {};
  }
}
function TVoid(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    return void 0;
  }
}
function TKind(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    throw new Error("User defined types must specify a default value");
  }
}
function Visit$2(schema, references) {
  const references_ = (0, guard_1$4.IsString)(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Types$4.Kind]) {
    case "Any":
      return TAny(schema_);
    case "Array":
      return TArray$2(schema_, references_);
    case "AsyncIterator":
      return TAsyncIterator(schema_);
    case "BigInt":
      return TBigInt$1(schema_);
    case "Boolean":
      return TBoolean$1(schema_);
    case "Constructor":
      return TConstructor$1(schema_, references_);
    case "Date":
      return TDate$1(schema_);
    case "Function":
      return TFunction(schema_, references_);
    case "Integer":
      return TInteger$1(schema_);
    case "Intersect":
      return TIntersect$2(schema_, references_);
    case "Iterator":
      return TIterator(schema_);
    case "Literal":
      return TLiteral$1(schema_);
    case "Never":
      return TNever$1(schema_);
    case "Not":
      return TNot(schema_);
    case "Null":
      return TNull$1(schema_);
    case "Number":
      return TNumber$1(schema_);
    case "Object":
      return TObject$2(schema_, references_);
    case "Promise":
      return TPromise(schema_, references_);
    case "Record":
      return TRecord$2(schema_, references_);
    case "Ref":
      return TRef$2(schema_, references_);
    case "String":
      return TString$1(schema_);
    case "Symbol":
      return TSymbol$1(schema_);
    case "TemplateLiteral":
      return TTemplateLiteral(schema_);
    case "This":
      return TThis$2(schema_, references_);
    case "Tuple":
      return TTuple$2(schema_, references_);
    case "Undefined":
      return TUndefined$1(schema_);
    case "Union":
      return TUnion$2(schema_, references_);
    case "Uint8Array":
      return TUint8Array(schema_);
    case "Unknown":
      return TUnknown(schema_);
    case "Void":
      return TVoid(schema_);
    default:
      if (!Types$4.TypeRegistry.Has(schema_[Types$4.Kind]))
        throw new ValueCreateUnknownTypeError(schema_);
      return TKind(schema_);
  }
}
const recursiveMaxDepth = 512;
let recursiveDepth = 0;
function Create(...args) {
  recursiveDepth = 0;
  return args.length === 2 ? Visit$2(args[0], args[1]) : Visit$2(args[0], []);
}
create.Create = Create;
Object.defineProperty(cast, "__esModule", { value: true });
cast.Cast = cast.Default = cast.DefaultClone = cast.ValueCastUnknownTypeError = cast.ValueCastRecursiveTypeError = cast.ValueCastNeverTypeError = cast.ValueCastArrayUniqueItemsTypeError = void 0;
const guard_1$3 = guard;
const create_1 = create;
const check_1$2 = check;
const clone_1$1 = clone;
const deref_1$3 = deref;
const Types$3 = typebox;
class ValueCastArrayUniqueItemsTypeError extends Types$3.TypeBoxError {
  constructor(schema, value2) {
    super("Array cast produced invalid data due to uniqueItems constraint");
    this.schema = schema;
    this.value = value2;
  }
}
cast.ValueCastArrayUniqueItemsTypeError = ValueCastArrayUniqueItemsTypeError;
class ValueCastNeverTypeError extends Types$3.TypeBoxError {
  constructor(schema) {
    super("Never types cannot be cast");
    this.schema = schema;
  }
}
cast.ValueCastNeverTypeError = ValueCastNeverTypeError;
class ValueCastRecursiveTypeError extends Types$3.TypeBoxError {
  constructor(schema) {
    super("Cannot cast recursive schemas");
    this.schema = schema;
  }
}
cast.ValueCastRecursiveTypeError = ValueCastRecursiveTypeError;
class ValueCastUnknownTypeError extends Types$3.TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}
cast.ValueCastUnknownTypeError = ValueCastUnknownTypeError;
var UnionCastCreate;
(function(UnionCastCreate2) {
  function Score(schema, references, value2) {
    if (schema[Types$3.Kind] === "Object" && typeof value2 === "object" && !(0, guard_1$3.IsNull)(value2)) {
      const object = schema;
      const keys = Object.getOwnPropertyNames(value2);
      const entries = Object.entries(object.properties);
      const [point, max] = [1 / entries.length, entries.length];
      return entries.reduce((acc, [key, schema2]) => {
        const literal = schema2[Types$3.Kind] === "Literal" && schema2.const === value2[key] ? max : 0;
        const checks = (0, check_1$2.Check)(schema2, references, value2[key]) ? point : 0;
        const exists = keys.includes(key) ? point : 0;
        return acc + (literal + checks + exists);
      }, 0);
    } else {
      return (0, check_1$2.Check)(schema, references, value2) ? 1 : 0;
    }
  }
  function Select(union, references, value2) {
    let [select, best] = [union.anyOf[0], 0];
    for (const schema of union.anyOf) {
      const score = Score(schema, references, value2);
      if (score > best) {
        select = schema;
        best = score;
      }
    }
    return select;
  }
  function Create2(union, references, value2) {
    if ("default" in union) {
      return union.default;
    } else {
      const schema = Select(union, references, value2);
      return Cast(schema, references, value2);
    }
  }
  UnionCastCreate2.Create = Create2;
})(UnionCastCreate || (UnionCastCreate = {}));
function DefaultClone(schema, references, value2) {
  return (0, check_1$2.Check)(schema, references, value2) ? (0, clone_1$1.Clone)(value2) : (0, create_1.Create)(schema, references);
}
cast.DefaultClone = DefaultClone;
function Default$1(schema, references, value2) {
  return (0, check_1$2.Check)(schema, references, value2) ? value2 : (0, create_1.Create)(schema, references);
}
cast.Default = Default$1;
function TArray$1(schema, references, value2) {
  if ((0, check_1$2.Check)(schema, references, value2))
    return (0, clone_1$1.Clone)(value2);
  const created = (0, guard_1$3.IsArray)(value2) ? (0, clone_1$1.Clone)(value2) : (0, create_1.Create)(schema, references);
  const minimum = (0, guard_1$3.IsNumber)(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
  const maximum = (0, guard_1$3.IsNumber)(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
  const casted = maximum.map((value3) => Visit$1(schema.items, references, value3));
  if (schema.uniqueItems !== true)
    return casted;
  const unique = [...new Set(casted)];
  if (!(0, check_1$2.Check)(schema, references, unique))
    throw new ValueCastArrayUniqueItemsTypeError(schema, unique);
  return unique;
}
function TConstructor(schema, references, value2) {
  if ((0, check_1$2.Check)(schema, references, value2))
    return (0, create_1.Create)(schema, references);
  const required = new Set(schema.returns.required || []);
  const result = function() {
  };
  for (const [key, property] of Object.entries(schema.returns.properties)) {
    if (!required.has(key) && value2.prototype[key] === void 0)
      continue;
    result.prototype[key] = Visit$1(property, references, value2.prototype[key]);
  }
  return result;
}
function TIntersect$1(schema, references, value2) {
  const created = (0, create_1.Create)(schema, references);
  const mapped = (0, guard_1$3.IsPlainObject)(created) && (0, guard_1$3.IsPlainObject)(value2) ? { ...created, ...value2 } : value2;
  return (0, check_1$2.Check)(schema, references, mapped) ? mapped : (0, create_1.Create)(schema, references);
}
function TNever(schema, references, value2) {
  throw new ValueCastNeverTypeError(schema);
}
function TObject$1(schema, references, value2) {
  if ((0, check_1$2.Check)(schema, references, value2))
    return value2;
  if (value2 === null || typeof value2 !== "object")
    return (0, create_1.Create)(schema, references);
  const required = new Set(schema.required || []);
  const result = {};
  for (const [key, property] of Object.entries(schema.properties)) {
    if (!required.has(key) && value2[key] === void 0)
      continue;
    result[key] = Visit$1(property, references, value2[key]);
  }
  if (typeof schema.additionalProperties === "object") {
    const propertyNames = Object.getOwnPropertyNames(schema.properties);
    for (const propertyName of Object.getOwnPropertyNames(value2)) {
      if (propertyNames.includes(propertyName))
        continue;
      result[propertyName] = Visit$1(schema.additionalProperties, references, value2[propertyName]);
    }
  }
  return result;
}
function TRecord$1(schema, references, value2) {
  if ((0, check_1$2.Check)(schema, references, value2))
    return (0, clone_1$1.Clone)(value2);
  if (value2 === null || typeof value2 !== "object" || Array.isArray(value2) || value2 instanceof Date)
    return (0, create_1.Create)(schema, references);
  const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const subschema = schema.patternProperties[subschemaPropertyName];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value2)) {
    result[propKey] = Visit$1(subschema, references, propValue);
  }
  return result;
}
function TRef$1(schema, references, value2) {
  return Visit$1((0, deref_1$3.Deref)(schema, references), references, value2);
}
function TThis$1(schema, references, value2) {
  return Visit$1((0, deref_1$3.Deref)(schema, references), references, value2);
}
function TTuple$1(schema, references, value2) {
  if ((0, check_1$2.Check)(schema, references, value2))
    return (0, clone_1$1.Clone)(value2);
  if (!(0, guard_1$3.IsArray)(value2))
    return (0, create_1.Create)(schema, references);
  if (schema.items === void 0)
    return [];
  return schema.items.map((schema2, index) => Visit$1(schema2, references, value2[index]));
}
function TUnion$1(schema, references, value2) {
  return (0, check_1$2.Check)(schema, references, value2) ? (0, clone_1$1.Clone)(value2) : UnionCastCreate.Create(schema, references, value2);
}
function Visit$1(schema, references, value2) {
  const references_ = (0, guard_1$3.IsString)(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Types$3.Kind]) {
    case "Array":
      return TArray$1(schema_, references_, value2);
    case "Constructor":
      return TConstructor(schema_, references_, value2);
    case "Intersect":
      return TIntersect$1(schema_, references_, value2);
    case "Never":
      return TNever(schema_);
    case "Object":
      return TObject$1(schema_, references_, value2);
    case "Record":
      return TRecord$1(schema_, references_, value2);
    case "Ref":
      return TRef$1(schema_, references_, value2);
    case "This":
      return TThis$1(schema_, references_, value2);
    case "Tuple":
      return TTuple$1(schema_, references_, value2);
    case "Union":
      return TUnion$1(schema_, references_, value2);
    case "Date":
    case "Symbol":
    case "Uint8Array":
      return DefaultClone(schema, references, value2);
    case "Any":
    case "AsyncIterator":
    case "BigInt":
    case "Boolean":
    case "Function":
    case "Integer":
    case "Iterator":
    case "Literal":
    case "Not":
    case "Null":
    case "Number":
    case "Promise":
    case "String":
    case "TemplateLiteral":
    case "Undefined":
    case "Unknown":
    case "Void":
      return Default$1(schema_, references_, value2);
    default:
      if (!Types$3.TypeRegistry.Has(schema_[Types$3.Kind]))
        throw new ValueCastUnknownTypeError(schema_);
      return Default$1(schema_, references_, value2);
  }
}
function Cast(...args) {
  return args.length === 3 ? Visit$1(args[0], args[1], args[2]) : Visit$1(args[0], [], args[1]);
}
cast.Cast = Cast;
var convert = {};
Object.defineProperty(convert, "__esModule", { value: true });
convert.Convert = convert.Default = convert.ValueConvertUnknownTypeError = void 0;
const guard_1$2 = guard;
const clone_1 = clone;
const check_1$1 = check;
const deref_1$2 = deref;
const Types$2 = typebox;
class ValueConvertUnknownTypeError extends Types$2.TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}
convert.ValueConvertUnknownTypeError = ValueConvertUnknownTypeError;
function IsStringNumeric(value2) {
  return (0, guard_1$2.IsString)(value2) && !isNaN(value2) && !isNaN(parseFloat(value2));
}
function IsValueToString(value2) {
  return (0, guard_1$2.IsBigInt)(value2) || (0, guard_1$2.IsBoolean)(value2) || (0, guard_1$2.IsNumber)(value2);
}
function IsValueTrue(value2) {
  return value2 === true || (0, guard_1$2.IsNumber)(value2) && value2 === 1 || (0, guard_1$2.IsBigInt)(value2) && value2 === BigInt("1") || (0, guard_1$2.IsString)(value2) && (value2.toLowerCase() === "true" || value2 === "1");
}
function IsValueFalse(value2) {
  return value2 === false || (0, guard_1$2.IsNumber)(value2) && (value2 === 0 || Object.is(value2, -0)) || (0, guard_1$2.IsBigInt)(value2) && value2 === BigInt("0") || (0, guard_1$2.IsString)(value2) && (value2.toLowerCase() === "false" || value2 === "0" || value2 === "-0");
}
function IsTimeStringWithTimeZone(value2) {
  return (0, guard_1$2.IsString)(value2) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value2);
}
function IsTimeStringWithoutTimeZone(value2) {
  return (0, guard_1$2.IsString)(value2) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value2);
}
function IsDateTimeStringWithTimeZone(value2) {
  return (0, guard_1$2.IsString)(value2) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value2);
}
function IsDateTimeStringWithoutTimeZone(value2) {
  return (0, guard_1$2.IsString)(value2) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value2);
}
function IsDateString(value2) {
  return (0, guard_1$2.IsString)(value2) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value2);
}
function TryConvertLiteralString(value2, target) {
  const conversion = TryConvertString(value2);
  return conversion === target ? conversion : value2;
}
function TryConvertLiteralNumber(value2, target) {
  const conversion = TryConvertNumber(value2);
  return conversion === target ? conversion : value2;
}
function TryConvertLiteralBoolean(value2, target) {
  const conversion = TryConvertBoolean(value2);
  return conversion === target ? conversion : value2;
}
function TryConvertLiteral(schema, value2) {
  if (typeof schema.const === "string") {
    return TryConvertLiteralString(value2, schema.const);
  } else if (typeof schema.const === "number") {
    return TryConvertLiteralNumber(value2, schema.const);
  } else if (typeof schema.const === "boolean") {
    return TryConvertLiteralBoolean(value2, schema.const);
  } else {
    return (0, clone_1.Clone)(value2);
  }
}
function TryConvertBoolean(value2) {
  return IsValueTrue(value2) ? true : IsValueFalse(value2) ? false : value2;
}
function TryConvertBigInt(value2) {
  return IsStringNumeric(value2) ? BigInt(parseInt(value2)) : (0, guard_1$2.IsNumber)(value2) ? BigInt(value2 | 0) : IsValueFalse(value2) ? BigInt(0) : IsValueTrue(value2) ? BigInt(1) : value2;
}
function TryConvertString(value2) {
  return IsValueToString(value2) ? value2.toString() : (0, guard_1$2.IsSymbol)(value2) && value2.description !== void 0 ? value2.description.toString() : value2;
}
function TryConvertNumber(value2) {
  return IsStringNumeric(value2) ? parseFloat(value2) : IsValueTrue(value2) ? 1 : IsValueFalse(value2) ? 0 : value2;
}
function TryConvertInteger(value2) {
  return IsStringNumeric(value2) ? parseInt(value2) : (0, guard_1$2.IsNumber)(value2) ? value2 | 0 : IsValueTrue(value2) ? 1 : IsValueFalse(value2) ? 0 : value2;
}
function TryConvertNull(value2) {
  return (0, guard_1$2.IsString)(value2) && value2.toLowerCase() === "null" ? null : value2;
}
function TryConvertUndefined(value2) {
  return (0, guard_1$2.IsString)(value2) && value2 === "undefined" ? void 0 : value2;
}
function TryConvertDate(value2) {
  return (0, guard_1$2.IsDate)(value2) ? value2 : (0, guard_1$2.IsNumber)(value2) ? new Date(value2) : IsValueTrue(value2) ? /* @__PURE__ */ new Date(1) : IsValueFalse(value2) ? /* @__PURE__ */ new Date(0) : IsStringNumeric(value2) ? new Date(parseInt(value2)) : IsTimeStringWithoutTimeZone(value2) ? /* @__PURE__ */ new Date(`1970-01-01T${value2}.000Z`) : IsTimeStringWithTimeZone(value2) ? /* @__PURE__ */ new Date(`1970-01-01T${value2}`) : IsDateTimeStringWithoutTimeZone(value2) ? /* @__PURE__ */ new Date(`${value2}.000Z`) : IsDateTimeStringWithTimeZone(value2) ? new Date(value2) : IsDateString(value2) ? /* @__PURE__ */ new Date(`${value2}T00:00:00.000Z`) : value2;
}
function Default(value2) {
  return value2;
}
convert.Default = Default;
function TArray(schema, references, value2) {
  if ((0, guard_1$2.IsArray)(value2)) {
    return value2.map((value3) => Visit(schema.items, references, value3));
  }
  return value2;
}
function TBigInt(schema, references, value2) {
  return TryConvertBigInt(value2);
}
function TBoolean(schema, references, value2) {
  return TryConvertBoolean(value2);
}
function TDate(schema, references, value2) {
  return TryConvertDate(value2);
}
function TInteger(schema, references, value2) {
  return TryConvertInteger(value2);
}
function TIntersect(schema, references, value2) {
  return schema.allOf.every((schema2) => Types$2.TypeGuard.TObject(schema2)) ? Visit(Types$2.Type.Composite(schema.allOf), references, value2) : Visit(schema.allOf[0], references, value2);
}
function TLiteral(schema, references, value2) {
  return TryConvertLiteral(schema, value2);
}
function TNull(schema, references, value2) {
  return TryConvertNull(value2);
}
function TNumber(schema, references, value2) {
  return TryConvertNumber(value2);
}
function TObject(schema, references, value2) {
  if ((0, guard_1$2.IsObject)(value2))
    return Object.getOwnPropertyNames(schema.properties).reduce((acc, key) => {
      return value2[key] !== void 0 ? { ...acc, [key]: Visit(schema.properties[key], references, value2[key]) } : { ...acc };
    }, value2);
  return value2;
}
function TRecord(schema, references, value2) {
  const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[propertyKey];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value2)) {
    result[propKey] = Visit(property, references, propValue);
  }
  return result;
}
function TRef(schema, references, value2) {
  return Visit((0, deref_1$2.Deref)(schema, references), references, value2);
}
function TString(schema, references, value2) {
  return TryConvertString(value2);
}
function TSymbol(schema, references, value2) {
  return (0, guard_1$2.IsString)(value2) || (0, guard_1$2.IsNumber)(value2) ? Symbol(value2) : value2;
}
function TThis(schema, references, value2) {
  return Visit((0, deref_1$2.Deref)(schema, references), references, value2);
}
function TTuple(schema, references, value2) {
  if ((0, guard_1$2.IsArray)(value2) && !(0, guard_1$2.IsUndefined)(schema.items)) {
    return value2.map((value3, index) => {
      return index < schema.items.length ? Visit(schema.items[index], references, value3) : value3;
    });
  }
  return value2;
}
function TUndefined(schema, references, value2) {
  return TryConvertUndefined(value2);
}
function TUnion(schema, references, value2) {
  for (const subschema of schema.anyOf) {
    const converted = Visit(subschema, references, value2);
    if ((0, check_1$1.Check)(subschema, references, converted)) {
      return converted;
    }
  }
  return value2;
}
function Visit(schema, references, value2) {
  const references_ = (0, guard_1$2.IsString)(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Types$2.Kind]) {
    case "Array":
      return TArray(schema_, references_, value2);
    case "BigInt":
      return TBigInt(schema_, references_, value2);
    case "Boolean":
      return TBoolean(schema_, references_, value2);
    case "Date":
      return TDate(schema_, references_, value2);
    case "Integer":
      return TInteger(schema_, references_, value2);
    case "Intersect":
      return TIntersect(schema_, references_, value2);
    case "Literal":
      return TLiteral(schema_, references_, value2);
    case "Null":
      return TNull(schema_, references_, value2);
    case "Number":
      return TNumber(schema_, references_, value2);
    case "Object":
      return TObject(schema_, references_, value2);
    case "Record":
      return TRecord(schema_, references_, value2);
    case "Ref":
      return TRef(schema_, references_, value2);
    case "String":
      return TString(schema_, references_, value2);
    case "Symbol":
      return TSymbol(schema_, references_, value2);
    case "This":
      return TThis(schema_, references_, value2);
    case "Tuple":
      return TTuple(schema_, references_, value2);
    case "Undefined":
      return TUndefined(schema_, references_, value2);
    case "Union":
      return TUnion(schema_, references_, value2);
    case "Any":
    case "AsyncIterator":
    case "Constructor":
    case "Function":
    case "Iterator":
    case "Never":
    case "Promise":
    case "TemplateLiteral":
    case "Uint8Array":
    case "Unknown":
    case "Void":
      return Default(value2);
    default:
      if (!Types$2.TypeRegistry.Has(schema_[Types$2.Kind]))
        throw new ValueConvertUnknownTypeError(schema_);
      return Default(value2);
  }
}
function Convert(...args) {
  return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
}
convert.Convert = Convert;
var transform = {};
Object.defineProperty(transform, "__esModule", { value: true });
transform.EncodeTransform = transform.DecodeTransform = transform.HasTransform = transform.TransformEncodeError = transform.TransformDecodeError = transform.TransformEncodeCheckError = transform.TransformDecodeCheckError = void 0;
const guard_1$1 = guard;
const deref_1$1 = deref;
const check_1 = check;
const Types$1 = typebox;
class TransformDecodeCheckError extends Types$1.TypeBoxError {
  constructor(schema, value2, error) {
    super(`Unable to decode due to invalid value`);
    this.schema = schema;
    this.value = value2;
    this.error = error;
  }
}
transform.TransformDecodeCheckError = TransformDecodeCheckError;
class TransformEncodeCheckError extends Types$1.TypeBoxError {
  constructor(schema, value2, error) {
    super(`Unable to encode due to invalid value`);
    this.schema = schema;
    this.value = value2;
    this.error = error;
  }
}
transform.TransformEncodeCheckError = TransformEncodeCheckError;
class TransformDecodeError extends Types$1.TypeBoxError {
  constructor(schema, value2, error) {
    super(`${error instanceof Error ? error.message : "Unknown error"}`);
    this.schema = schema;
    this.value = value2;
  }
}
transform.TransformDecodeError = TransformDecodeError;
class TransformEncodeError extends Types$1.TypeBoxError {
  constructor(schema, value2, error) {
    super(`${error instanceof Error ? error.message : "Unknown error"}`);
    this.schema = schema;
    this.value = value2;
  }
}
transform.TransformEncodeError = TransformEncodeError;
var HasTransform;
(function(HasTransform2) {
  function TArray2(schema, references) {
    return Types$1.TypeGuard.TTransform(schema) || Visit2(schema.items, references);
  }
  function TAsyncIterator2(schema, references) {
    return Types$1.TypeGuard.TTransform(schema) || Visit2(schema.items, references);
  }
  function TConstructor2(schema, references) {
    return Types$1.TypeGuard.TTransform(schema) || Visit2(schema.returns, references) || schema.parameters.some((schema2) => Visit2(schema2, references));
  }
  function TFunction2(schema, references) {
    return Types$1.TypeGuard.TTransform(schema) || Visit2(schema.returns, references) || schema.parameters.some((schema2) => Visit2(schema2, references));
  }
  function TIntersect2(schema, references) {
    return Types$1.TypeGuard.TTransform(schema) || Types$1.TypeGuard.TTransform(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit2(schema2, references));
  }
  function TIterator2(schema, references) {
    return Types$1.TypeGuard.TTransform(schema) || Visit2(schema.items, references);
  }
  function TNot2(schema, references) {
    return Types$1.TypeGuard.TTransform(schema) || Visit2(schema.not, references);
  }
  function TObject2(schema, references) {
    return Types$1.TypeGuard.TTransform(schema) || Object.values(schema.properties).some((schema2) => Visit2(schema2, references)) || Types$1.TypeGuard.TSchema(schema.additionalProperties) && Visit2(schema.additionalProperties, references);
  }
  function TPromise2(schema, references) {
    return Types$1.TypeGuard.TTransform(schema) || Visit2(schema.item, references);
  }
  function TRecord2(schema, references) {
    const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const property = schema.patternProperties[pattern2];
    return Types$1.TypeGuard.TTransform(schema) || Visit2(property, references) || Types$1.TypeGuard.TSchema(schema.additionalProperties) && Types$1.TypeGuard.TTransform(schema.additionalProperties);
  }
  function TRef2(schema, references) {
    if (Types$1.TypeGuard.TTransform(schema))
      return true;
    return Visit2((0, deref_1$1.Deref)(schema, references), references);
  }
  function TThis2(schema, references) {
    if (Types$1.TypeGuard.TTransform(schema))
      return true;
    return Visit2((0, deref_1$1.Deref)(schema, references), references);
  }
  function TTuple2(schema, references) {
    return Types$1.TypeGuard.TTransform(schema) || !(0, guard_1$1.IsUndefined)(schema.items) && schema.items.some((schema2) => Visit2(schema2, references));
  }
  function TUnion2(schema, references) {
    return Types$1.TypeGuard.TTransform(schema) || schema.anyOf.some((schema2) => Visit2(schema2, references));
  }
  function Visit2(schema, references) {
    const references_ = (0, guard_1$1.IsString)(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    if (schema.$id && visited.has(schema.$id))
      return false;
    if (schema.$id)
      visited.add(schema.$id);
    switch (schema[Types$1.Kind]) {
      case "Array":
        return TArray2(schema_, references_);
      case "AsyncIterator":
        return TAsyncIterator2(schema_, references_);
      case "Constructor":
        return TConstructor2(schema_, references_);
      case "Function":
        return TFunction2(schema_, references_);
      case "Intersect":
        return TIntersect2(schema_, references_);
      case "Iterator":
        return TIterator2(schema_, references_);
      case "Not":
        return TNot2(schema_, references_);
      case "Object":
        return TObject2(schema_, references_);
      case "Promise":
        return TPromise2(schema_, references_);
      case "Record":
        return TRecord2(schema_, references_);
      case "Ref":
        return TRef2(schema_, references_);
      case "This":
        return TThis2(schema_, references_);
      case "Tuple":
        return TTuple2(schema_, references_);
      case "Union":
        return TUnion2(schema_, references_);
      default:
        return Types$1.TypeGuard.TTransform(schema);
    }
  }
  const visited = /* @__PURE__ */ new Set();
  function Has(schema, references) {
    visited.clear();
    return Visit2(schema, references);
  }
  HasTransform2.Has = Has;
})(HasTransform || (transform.HasTransform = HasTransform = {}));
var DecodeTransform;
(function(DecodeTransform2) {
  function Default2(schema, value2) {
    try {
      return Types$1.TypeGuard.TTransform(schema) ? schema[Types$1.Transform].Decode(value2) : value2;
    } catch (error) {
      throw new TransformDecodeError(schema, value2, error);
    }
  }
  function TArray2(schema, references, value2) {
    return (0, guard_1$1.IsArray)(value2) ? Default2(schema, value2.map((value3) => Visit2(schema.items, references, value3))) : Default2(schema, value2);
  }
  function TIntersect2(schema, references, value2) {
    if (!(0, guard_1$1.IsPlainObject)(value2) || (0, guard_1$1.IsValueType)(value2))
      return Default2(schema, value2);
    const knownKeys = Types$1.KeyResolver.ResolveKeys(schema, { includePatterns: false });
    const knownProperties = knownKeys.reduce((value3, key) => {
      return key in value3 ? { ...value3, [key]: Visit2(Types$1.IndexedAccessor.Resolve(schema, [key]), references, value3[key]) } : value3;
    }, value2);
    if (!Types$1.TypeGuard.TTransform(schema.unevaluatedProperties)) {
      return Default2(schema, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const unevaluatedProperties = schema.unevaluatedProperties;
    const unknownProperties = unknownKeys.reduce((value3, key) => {
      return !knownKeys.includes(key) ? { ...value3, [key]: Default2(unevaluatedProperties, value3[key]) } : value3;
    }, knownProperties);
    return Default2(schema, unknownProperties);
  }
  function TNot2(schema, references, value2) {
    return Default2(schema, Visit2(schema.not, references, value2));
  }
  function TObject2(schema, references, value2) {
    if (!(0, guard_1$1.IsPlainObject)(value2))
      return Default2(schema, value2);
    const knownKeys = Types$1.KeyResolver.ResolveKeys(schema, { includePatterns: false });
    const knownProperties = knownKeys.reduce((value3, key) => {
      return key in value3 ? { ...value3, [key]: Visit2(schema.properties[key], references, value3[key]) } : value3;
    }, value2);
    if (!Types$1.TypeGuard.TSchema(schema.additionalProperties)) {
      return Default2(schema, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    const unknownProperties = unknownKeys.reduce((value3, key) => {
      return !knownKeys.includes(key) ? { ...value3, [key]: Default2(additionalProperties, value3[key]) } : value3;
    }, knownProperties);
    return Default2(schema, unknownProperties);
  }
  function TRecord2(schema, references, value2) {
    if (!(0, guard_1$1.IsPlainObject)(value2))
      return Default2(schema, value2);
    const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const knownKeys = new RegExp(pattern2);
    const knownProperties = Object.getOwnPropertyNames(value2).reduce((value3, key) => {
      return knownKeys.test(key) ? { ...value3, [key]: Visit2(schema.patternProperties[pattern2], references, value3[key]) } : value3;
    }, value2);
    if (!Types$1.TypeGuard.TSchema(schema.additionalProperties)) {
      return Default2(schema, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    const unknownProperties = unknownKeys.reduce((value3, key) => {
      return !knownKeys.test(key) ? { ...value3, [key]: Default2(additionalProperties, value3[key]) } : value3;
    }, knownProperties);
    return Default2(schema, unknownProperties);
  }
  function TRef2(schema, references, value2) {
    const target = (0, deref_1$1.Deref)(schema, references);
    return Default2(schema, Visit2(target, references, value2));
  }
  function TThis2(schema, references, value2) {
    const target = (0, deref_1$1.Deref)(schema, references);
    return Default2(schema, Visit2(target, references, value2));
  }
  function TTuple2(schema, references, value2) {
    return (0, guard_1$1.IsArray)(value2) && (0, guard_1$1.IsArray)(schema.items) ? Default2(schema, schema.items.map((schema2, index) => Visit2(schema2, references, value2[index]))) : Default2(schema, value2);
  }
  function TUnion2(schema, references, value2) {
    const defaulted = Default2(schema, value2);
    for (const subschema of schema.anyOf) {
      if (!(0, check_1.Check)(subschema, references, defaulted))
        continue;
      return Visit2(subschema, references, defaulted);
    }
    return defaulted;
  }
  function Visit2(schema, references, value2) {
    const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema[Types$1.Kind]) {
      case "Array":
        return TArray2(schema_, references_, value2);
      case "Intersect":
        return TIntersect2(schema_, references_, value2);
      case "Not":
        return TNot2(schema_, references_, value2);
      case "Object":
        return TObject2(schema_, references_, value2);
      case "Record":
        return TRecord2(schema_, references_, value2);
      case "Ref":
        return TRef2(schema_, references_, value2);
      case "Symbol":
        return Default2(schema_, value2);
      case "This":
        return TThis2(schema_, references_, value2);
      case "Tuple":
        return TTuple2(schema_, references_, value2);
      case "Union":
        return TUnion2(schema_, references_, value2);
      default:
        return Default2(schema_, value2);
    }
  }
  function Decode(schema, references, value2) {
    return Visit2(schema, references, value2);
  }
  DecodeTransform2.Decode = Decode;
})(DecodeTransform || (transform.DecodeTransform = DecodeTransform = {}));
var EncodeTransform;
(function(EncodeTransform2) {
  function Default2(schema, value2) {
    try {
      return Types$1.TypeGuard.TTransform(schema) ? schema[Types$1.Transform].Encode(value2) : value2;
    } catch (error) {
      throw new TransformEncodeError(schema, value2, error);
    }
  }
  function TArray2(schema, references, value2) {
    const defaulted = Default2(schema, value2);
    return (0, guard_1$1.IsArray)(defaulted) ? defaulted.map((value3) => Visit2(schema.items, references, value3)) : defaulted;
  }
  function TIntersect2(schema, references, value2) {
    const defaulted = Default2(schema, value2);
    if (!(0, guard_1$1.IsPlainObject)(value2) || (0, guard_1$1.IsValueType)(value2))
      return defaulted;
    const knownKeys = Types$1.KeyResolver.ResolveKeys(schema, { includePatterns: false });
    const knownProperties = knownKeys.reduce((value3, key) => {
      return key in defaulted ? { ...value3, [key]: Visit2(Types$1.IndexedAccessor.Resolve(schema, [key]), references, value3[key]) } : value3;
    }, defaulted);
    if (!Types$1.TypeGuard.TTransform(schema.unevaluatedProperties)) {
      return Default2(schema, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const unevaluatedProperties = schema.unevaluatedProperties;
    return unknownKeys.reduce((value3, key) => {
      return !knownKeys.includes(key) ? { ...value3, [key]: Default2(unevaluatedProperties, value3[key]) } : value3;
    }, knownProperties);
  }
  function TNot2(schema, references, value2) {
    return Default2(schema.not, Default2(schema, value2));
  }
  function TObject2(schema, references, value2) {
    const defaulted = Default2(schema, value2);
    if (!(0, guard_1$1.IsPlainObject)(value2))
      return defaulted;
    const knownKeys = Types$1.KeyResolver.ResolveKeys(schema, { includePatterns: false });
    const knownProperties = knownKeys.reduce((value3, key) => {
      return key in value3 ? { ...value3, [key]: Visit2(schema.properties[key], references, value3[key]) } : value3;
    }, defaulted);
    if (!Types$1.TypeGuard.TSchema(schema.additionalProperties)) {
      return knownProperties;
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    return unknownKeys.reduce((value3, key) => {
      return !knownKeys.includes(key) ? { ...value3, [key]: Default2(additionalProperties, value3[key]) } : value3;
    }, knownProperties);
  }
  function TRecord2(schema, references, value2) {
    const defaulted = Default2(schema, value2);
    if (!(0, guard_1$1.IsPlainObject)(value2))
      return defaulted;
    const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const knownKeys = new RegExp(pattern2);
    const knownProperties = Object.getOwnPropertyNames(value2).reduce((value3, key) => {
      return knownKeys.test(key) ? { ...value3, [key]: Visit2(schema.patternProperties[pattern2], references, value3[key]) } : value3;
    }, defaulted);
    if (!Types$1.TypeGuard.TSchema(schema.additionalProperties)) {
      return Default2(schema, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    return unknownKeys.reduce((value3, key) => {
      return !knownKeys.test(key) ? { ...value3, [key]: Default2(additionalProperties, value3[key]) } : value3;
    }, knownProperties);
  }
  function TRef2(schema, references, value2) {
    const target = (0, deref_1$1.Deref)(schema, references);
    const resolved = Visit2(target, references, value2);
    return Default2(schema, resolved);
  }
  function TThis2(schema, references, value2) {
    const target = (0, deref_1$1.Deref)(schema, references);
    const resolved = Visit2(target, references, value2);
    return Default2(schema, resolved);
  }
  function TTuple2(schema, references, value2) {
    const value1 = Default2(schema, value2);
    return (0, guard_1$1.IsArray)(schema.items) ? schema.items.map((schema2, index) => Visit2(schema2, references, value1[index])) : [];
  }
  function TUnion2(schema, references, value2) {
    for (const subschema of schema.anyOf) {
      if (!(0, check_1.Check)(subschema, references, value2))
        continue;
      const value1 = Visit2(subschema, references, value2);
      return Default2(schema, value1);
    }
    for (const subschema of schema.anyOf) {
      const value1 = Visit2(subschema, references, value2);
      if (!(0, check_1.Check)(schema, references, value1))
        continue;
      return Default2(schema, value1);
    }
    return Default2(schema, value2);
  }
  function Visit2(schema, references, value2) {
    const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema[Types$1.Kind]) {
      case "Array":
        return TArray2(schema_, references_, value2);
      case "Intersect":
        return TIntersect2(schema_, references_, value2);
      case "Not":
        return TNot2(schema_, references_, value2);
      case "Object":
        return TObject2(schema_, references_, value2);
      case "Record":
        return TRecord2(schema_, references_, value2);
      case "Ref":
        return TRef2(schema_, references_, value2);
      case "This":
        return TThis2(schema_, references_, value2);
      case "Tuple":
        return TTuple2(schema_, references_, value2);
      case "Union":
        return TUnion2(schema_, references_, value2);
      default:
        return Default2(schema_, value2);
    }
  }
  function Encode(schema, references, value2) {
    return Visit2(schema, references, value2);
  }
  EncodeTransform2.Encode = Encode;
})(EncodeTransform || (transform.EncodeTransform = EncodeTransform = {}));
Object.defineProperty(value, "__esModule", { value: true });
value.Value = void 0;
const ValueErrors = errors$1;
const ValueMutate = mutate;
const ValueHash = hash$1;
const ValueEqual = equal;
const ValueCast = cast;
const ValueClone = clone;
const ValueConvert = convert;
const ValueCreate = create;
const ValueCheck = check;
const ValueDelta = delta;
const ValueTransform = transform;
var Value;
(function(Value2) {
  function Cast2(...args) {
    return ValueCast.Cast.apply(ValueCast, args);
  }
  Value2.Cast = Cast2;
  function Create2(...args) {
    return ValueCreate.Create.apply(ValueCreate, args);
  }
  Value2.Create = Create2;
  function Check2(...args) {
    return ValueCheck.Check.apply(ValueCheck, args);
  }
  Value2.Check = Check2;
  function Convert2(...args) {
    return ValueConvert.Convert.apply(ValueConvert, args);
  }
  Value2.Convert = Convert2;
  function Clone2(value2) {
    return ValueClone.Clone(value2);
  }
  Value2.Clone = Clone2;
  function Decode(...args) {
    const [schema, references, value2] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
    if (!Check2(schema, references, value2))
      throw new ValueTransform.TransformDecodeCheckError(schema, value2, Errors(schema, references, value2).First());
    return ValueTransform.DecodeTransform.Decode(schema, references, value2);
  }
  Value2.Decode = Decode;
  function Encode(...args) {
    const [schema, references, value2] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
    const encoded = ValueTransform.EncodeTransform.Encode(schema, references, value2);
    if (!Check2(schema, references, encoded))
      throw new ValueTransform.TransformEncodeCheckError(schema, value2, Errors(schema, references, value2).First());
    return encoded;
  }
  Value2.Encode = Encode;
  function Errors(...args) {
    return ValueErrors.Errors.apply(ValueErrors, args);
  }
  Value2.Errors = Errors;
  function Equal2(left, right) {
    return ValueEqual.Equal(left, right);
  }
  Value2.Equal = Equal2;
  function Diff(current, next) {
    return ValueDelta.Diff(current, next);
  }
  Value2.Diff = Diff;
  function Hash2(value2) {
    return ValueHash.Hash(value2);
  }
  Value2.Hash = Hash2;
  function Patch(current, edits) {
    return ValueDelta.Patch(current, edits);
  }
  Value2.Patch = Patch;
  function Mutate2(current, next) {
    ValueMutate.Mutate(current, next);
  }
  Value2.Mutate = Mutate2;
})(Value || (value.Value = Value = {}));
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Value = exports2.ValuePointer = exports2.Delete = exports2.Update = exports2.Insert = exports2.Edit = exports2.ValueErrorIterator = exports2.ValueErrorType = void 0;
  var index_12 = errors$1;
  Object.defineProperty(exports2, "ValueErrorType", { enumerable: true, get: function() {
    return index_12.ValueErrorType;
  } });
  Object.defineProperty(exports2, "ValueErrorIterator", { enumerable: true, get: function() {
    return index_12.ValueErrorIterator;
  } });
  var delta_1 = delta;
  Object.defineProperty(exports2, "Edit", { enumerable: true, get: function() {
    return delta_1.Edit;
  } });
  Object.defineProperty(exports2, "Insert", { enumerable: true, get: function() {
    return delta_1.Insert;
  } });
  Object.defineProperty(exports2, "Update", { enumerable: true, get: function() {
    return delta_1.Update;
  } });
  Object.defineProperty(exports2, "Delete", { enumerable: true, get: function() {
    return delta_1.Delete;
  } });
  var pointer_12 = pointer;
  Object.defineProperty(exports2, "ValuePointer", { enumerable: true, get: function() {
    return pointer_12.ValuePointer;
  } });
  var value_1 = value;
  Object.defineProperty(exports2, "Value", { enumerable: true, get: function() {
    return value_1.Value;
  } });
})(value$1);
const resolveMessageLintRules = (args) => {
  const result = {
    data: [],
    errors: []
  };
  for (const rule of args.messageLintRules) {
    if (value$1.Value.Check(MessageLintRule, rule) === false) {
      const errors2 = [...value$1.Value.Errors(MessageLintRule, rule)];
      result.errors.push(new MessageLintRuleIsInvalidError({
        id: rule.id,
        errors: errors2
      }));
      continue;
    } else {
      result.data.push(rule);
    }
  }
  return result;
};
function createImport(args) {
  return (uri) => $import(uri, args);
}
async function $import(uri, options) {
  let moduleAsText;
  if (uri.startsWith("http")) {
    moduleAsText = await (await fetch(uri)).text();
  } else {
    moduleAsText = await options.readFile(uri, {
      encoding: "utf-8"
    });
  }
  const moduleWithMimeType = "data:application/javascript," + encodeURIComponent(moduleAsText);
  try {
    return await import(
      /* @vite-ignore */
      moduleWithMimeType
    );
  } catch (error) {
    if (error instanceof SyntaxError && uri.includes("jsdelivr")) {
      error.message += dedent`\n\n
Are you sure that the file exists on JSDelivr?

The error indicates that the imported file does not exist on JSDelivr. For non-existent files, JSDelivr returns a 404 text that JS cannot parse as a module and throws a SyntaxError.
			`;
    }
    throw new ModuleImportError({ module: uri, cause: error });
  }
}
const actions = {
  defaultMerge: Symbol("deepmerge-ts: default merge"),
  skip: Symbol("deepmerge-ts: skip")
};
({
  defaultMerge: actions.defaultMerge
});
function defaultMetaDataUpdater(previousMeta, metaMeta) {
  return metaMeta;
}
function getObjectType(object) {
  if (typeof object !== "object" || object === null) {
    return 0;
  }
  if (Array.isArray(object)) {
    return 2;
  }
  if (isRecord(object)) {
    return 1;
  }
  if (object instanceof Set) {
    return 3;
  }
  if (object instanceof Map) {
    return 4;
  }
  return 5;
}
function getKeys(objects) {
  const keys = /* @__PURE__ */ new Set();
  for (const object of objects) {
    for (const key of [
      ...Object.keys(object),
      ...Object.getOwnPropertySymbols(object)
    ]) {
      keys.add(key);
    }
  }
  return keys;
}
function objectHasProperty(object, property) {
  return typeof object === "object" && Object.prototype.propertyIsEnumerable.call(object, property);
}
function getIterableOfIterables(iterables) {
  return {
    // eslint-disable-next-line functional/functional-parameters
    *[Symbol.iterator]() {
      for (const iterable of iterables) {
        for (const value2 of iterable) {
          yield value2;
        }
      }
    }
  };
}
const validRecordToStringValues = /* @__PURE__ */ new Set([
  "[object Object]",
  "[object Module]"
]);
function isRecord(value2) {
  if (!validRecordToStringValues.has(Object.prototype.toString.call(value2))) {
    return false;
  }
  const { constructor } = value2;
  if (constructor === void 0) {
    return true;
  }
  const prototype = constructor.prototype;
  if (prototype === null || typeof prototype !== "object" || !validRecordToStringValues.has(Object.prototype.toString.call(prototype))) {
    return false;
  }
  if (!prototype.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  return true;
}
function mergeRecords$2(values, utils, meta) {
  const result = {};
  for (const key of getKeys(values)) {
    const propValues = [];
    for (const value2 of values) {
      if (objectHasProperty(value2, key)) {
        propValues.push(value2[key]);
      }
    }
    if (propValues.length === 0) {
      continue;
    }
    const updatedMeta = utils.metaDataUpdater(meta, {
      key,
      parents: values
    });
    const propertyResult = mergeUnknowns(propValues, utils, updatedMeta);
    if (propertyResult === actions.skip) {
      continue;
    }
    if (key === "__proto__") {
      Object.defineProperty(result, key, {
        value: propertyResult,
        configurable: true,
        enumerable: true,
        writable: true
      });
    } else {
      result[key] = propertyResult;
    }
  }
  return result;
}
function mergeArrays$2(values) {
  return values.flat();
}
function mergeSets$2(values) {
  return new Set(getIterableOfIterables(values));
}
function mergeMaps$2(values) {
  return new Map(getIterableOfIterables(values));
}
function mergeOthers$2(values) {
  return values.at(-1);
}
var defaultMergeFunctions = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  mergeArrays: mergeArrays$2,
  mergeMaps: mergeMaps$2,
  mergeOthers: mergeOthers$2,
  mergeRecords: mergeRecords$2,
  mergeSets: mergeSets$2
});
function deepmerge(...objects) {
  return deepmergeCustom({})(...objects);
}
function deepmergeCustom(options, rootMetaData) {
  const utils = getUtils(options, customizedDeepmerge);
  function customizedDeepmerge(...objects) {
    return mergeUnknowns(objects, utils, rootMetaData);
  }
  return customizedDeepmerge;
}
function getUtils(options, customizedDeepmerge) {
  return {
    defaultMergeFunctions,
    mergeFunctions: {
      ...defaultMergeFunctions,
      ...Object.fromEntries(Object.entries(options).filter(([key, option]) => Object.hasOwn(defaultMergeFunctions, key)).map(([key, option]) => option === false ? [key, mergeOthers$2] : [key, option]))
    },
    metaDataUpdater: options.metaDataUpdater ?? defaultMetaDataUpdater,
    deepmerge: customizedDeepmerge,
    useImplicitDefaultMerging: options.enableImplicitDefaultMerging ?? false,
    actions
  };
}
function mergeUnknowns(values, utils, meta) {
  if (values.length === 0) {
    return void 0;
  }
  if (values.length === 1) {
    return mergeOthers$1(values, utils, meta);
  }
  const type = getObjectType(values[0]);
  if (type !== 0 && type !== 5) {
    for (let m_index = 1; m_index < values.length; m_index++) {
      if (getObjectType(values[m_index]) === type) {
        continue;
      }
      return mergeOthers$1(values, utils, meta);
    }
  }
  switch (type) {
    case 1: {
      return mergeRecords$1(values, utils, meta);
    }
    case 2: {
      return mergeArrays$1(values, utils, meta);
    }
    case 3: {
      return mergeSets$1(values, utils, meta);
    }
    case 4: {
      return mergeMaps$1(values, utils, meta);
    }
    default: {
      return mergeOthers$1(values, utils, meta);
    }
  }
}
function mergeRecords$1(values, utils, meta) {
  const result = utils.mergeFunctions.mergeRecords(values, utils, meta);
  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === void 0 && utils.mergeFunctions.mergeRecords !== utils.defaultMergeFunctions.mergeRecords) {
    return utils.defaultMergeFunctions.mergeRecords(values, utils, meta);
  }
  return result;
}
function mergeArrays$1(values, utils, meta) {
  const result = utils.mergeFunctions.mergeArrays(values, utils, meta);
  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === void 0 && utils.mergeFunctions.mergeArrays !== utils.defaultMergeFunctions.mergeArrays) {
    return utils.defaultMergeFunctions.mergeArrays(values);
  }
  return result;
}
function mergeSets$1(values, utils, meta) {
  const result = utils.mergeFunctions.mergeSets(values, utils, meta);
  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === void 0 && utils.mergeFunctions.mergeSets !== utils.defaultMergeFunctions.mergeSets) {
    return utils.defaultMergeFunctions.mergeSets(values);
  }
  return result;
}
function mergeMaps$1(values, utils, meta) {
  const result = utils.mergeFunctions.mergeMaps(values, utils, meta);
  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === void 0 && utils.mergeFunctions.mergeMaps !== utils.defaultMergeFunctions.mergeMaps) {
    return utils.defaultMergeFunctions.mergeMaps(values);
  }
  return result;
}
function mergeOthers$1(values, utils, meta) {
  const result = utils.mergeFunctions.mergeOthers(values, utils, meta);
  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === void 0 && utils.mergeFunctions.mergeOthers !== utils.defaultMergeFunctions.mergeOthers) {
    return utils.defaultMergeFunctions.mergeOthers(values);
  }
  return result;
}
var compiler$1 = {};
var compiler = {};
Object.defineProperty(compiler, "__esModule", { value: true });
compiler.TypeCompiler = compiler.Policy = compiler.TypeCompilerTypeGuardError = compiler.TypeCompilerUnknownTypeError = compiler.TypeCheck = void 0;
const transform_1 = transform;
const guard_1 = guard;
const errors_1 = requireErrors();
const index_1 = system;
const deref_1 = deref;
const hash_1 = hash$1;
const Types = typebox;
class TypeCheck {
  constructor(schema, references, checkFunc, code) {
    this.schema = schema;
    this.references = references;
    this.checkFunc = checkFunc;
    this.code = code;
    this.hasTransform = transform_1.HasTransform.Has(schema, references);
  }
  /** Returns the generated assertion code used to validate this type. */
  Code() {
    return this.code;
  }
  /** Returns an iterator for each error in this value. */
  Errors(value2) {
    return (0, errors_1.Errors)(this.schema, this.references, value2);
  }
  /** Returns true if the value matches the compiled type. */
  Check(value2) {
    return this.checkFunc(value2);
  }
  /** Decodes a value or throws if error */
  Decode(value2) {
    if (!this.checkFunc(value2))
      throw new transform_1.TransformDecodeCheckError(this.schema, value2, this.Errors(value2).First());
    return this.hasTransform ? transform_1.DecodeTransform.Decode(this.schema, this.references, value2) : value2;
  }
  /** Encodes a value or throws if error */
  Encode(value2) {
    const encoded = this.hasTransform ? transform_1.EncodeTransform.Encode(this.schema, this.references, value2) : value2;
    if (!this.checkFunc(encoded))
      throw new transform_1.TransformEncodeCheckError(this.schema, value2, this.Errors(value2).First());
    return encoded;
  }
}
compiler.TypeCheck = TypeCheck;
var Character;
(function(Character2) {
  function DollarSign(code) {
    return code === 36;
  }
  Character2.DollarSign = DollarSign;
  function IsUnderscore(code) {
    return code === 95;
  }
  Character2.IsUnderscore = IsUnderscore;
  function IsAlpha(code) {
    return code >= 65 && code <= 90 || code >= 97 && code <= 122;
  }
  Character2.IsAlpha = IsAlpha;
  function IsNumeric(code) {
    return code >= 48 && code <= 57;
  }
  Character2.IsNumeric = IsNumeric;
})(Character || (Character = {}));
var MemberExpression;
(function(MemberExpression2) {
  function IsFirstCharacterNumeric(value2) {
    if (value2.length === 0)
      return false;
    return Character.IsNumeric(value2.charCodeAt(0));
  }
  function IsAccessor(value2) {
    if (IsFirstCharacterNumeric(value2))
      return false;
    for (let i2 = 0; i2 < value2.length; i2++) {
      const code = value2.charCodeAt(i2);
      const check2 = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
      if (!check2)
        return false;
    }
    return true;
  }
  function EscapeHyphen(key) {
    return key.replace(/'/g, "\\'");
  }
  function Encode(object, key) {
    return IsAccessor(key) ? `${object}.${key}` : `${object}['${EscapeHyphen(key)}']`;
  }
  MemberExpression2.Encode = Encode;
})(MemberExpression || (MemberExpression = {}));
var Identifier;
(function(Identifier2) {
  function Encode($id) {
    const buffer = [];
    for (let i2 = 0; i2 < $id.length; i2++) {
      const code = $id.charCodeAt(i2);
      if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
        buffer.push($id.charAt(i2));
      } else {
        buffer.push(`_${code}_`);
      }
    }
    return buffer.join("").replace(/__/g, "_");
  }
  Identifier2.Encode = Encode;
})(Identifier || (Identifier = {}));
var LiteralString;
(function(LiteralString2) {
  function Escape(content) {
    return content.replace(/'/g, "\\'");
  }
  LiteralString2.Escape = Escape;
})(LiteralString || (LiteralString = {}));
class TypeCompilerUnknownTypeError extends Types.TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}
compiler.TypeCompilerUnknownTypeError = TypeCompilerUnknownTypeError;
class TypeCompilerTypeGuardError extends Types.TypeBoxError {
  constructor(schema) {
    super("Preflight validation check failed to guard for the given schema");
    this.schema = schema;
  }
}
compiler.TypeCompilerTypeGuardError = TypeCompilerTypeGuardError;
var Policy;
(function(Policy2) {
  function IsExactOptionalProperty(value2, key, expression) {
    return index_1.TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value2} ? ${expression} : true)` : `(${MemberExpression.Encode(value2, key)} !== undefined ? ${expression} : true)`;
  }
  Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value2) {
    return !index_1.TypeSystemPolicy.AllowArrayObject ? `(typeof ${value2} === 'object' && ${value2} !== null && !Array.isArray(${value2}))` : `(typeof ${value2} === 'object' && ${value2} !== null)`;
  }
  Policy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value2) {
    return !index_1.TypeSystemPolicy.AllowArrayObject ? `(typeof ${value2} === 'object' && ${value2} !== null && !Array.isArray(${value2}) && !(${value2} instanceof Date) && !(${value2} instanceof Uint8Array))` : `(typeof ${value2} === 'object' && ${value2} !== null && !(${value2} instanceof Date) && !(${value2} instanceof Uint8Array))`;
  }
  Policy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value2) {
    return !index_1.TypeSystemPolicy.AllowNaN ? `(typeof ${value2} === 'number' && Number.isFinite(${value2}))` : `typeof ${value2} === 'number'`;
  }
  Policy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value2) {
    return index_1.TypeSystemPolicy.AllowNullVoid ? `(${value2} === undefined || ${value2} === null)` : `${value2} === undefined`;
  }
  Policy2.IsVoidLike = IsVoidLike;
})(Policy || (compiler.Policy = Policy = {}));
var TypeCompiler;
(function(TypeCompiler2) {
  function IsAnyOrUnknown2(schema) {
    return schema[Types.Kind] === "Any" || schema[Types.Kind] === "Unknown";
  }
  function* TAny2(schema, references, value2) {
    yield "true";
  }
  function* TArray2(schema, references, value2) {
    yield `Array.isArray(${value2})`;
    const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
    if ((0, guard_1.IsNumber)(schema.maxItems))
      yield `${value2}.length <= ${schema.maxItems}`;
    if ((0, guard_1.IsNumber)(schema.minItems))
      yield `${value2}.length >= ${schema.minItems}`;
    const elementExpression = CreateExpression(schema.items, references, "value");
    yield `${value2}.every((${parameter}) => ${elementExpression})`;
    if (Types.TypeGuard.TSchema(schema.contains) || (0, guard_1.IsNumber)(schema.minContains) || (0, guard_1.IsNumber)(schema.maxContains)) {
      const containsSchema = Types.TypeGuard.TSchema(schema.contains) ? schema.contains : Types.Type.Never();
      const checkExpression = CreateExpression(containsSchema, references, "value");
      const checkMinContains = (0, guard_1.IsNumber)(schema.minContains) ? [`(count >= ${schema.minContains})`] : [];
      const checkMaxContains = (0, guard_1.IsNumber)(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [];
      const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
      const check2 = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
      yield `((${parameter}) => { ${checkCount}; return ${check2}})(${value2})`;
    }
    if (schema.uniqueItems === true) {
      const check2 = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
      const block = `const set = new Set(); for(const element of value) { ${check2} }`;
      yield `((${parameter}) => { ${block} )(${value2})`;
    }
  }
  function* TAsyncIterator2(schema, references, value2) {
    yield `(typeof value === 'object' && Symbol.asyncIterator in ${value2})`;
  }
  function* TBigInt2(schema, references, value2) {
    yield `(typeof ${value2} === 'bigint')`;
    if ((0, guard_1.IsBigInt)(schema.exclusiveMaximum))
      yield `${value2} < BigInt(${schema.exclusiveMaximum})`;
    if ((0, guard_1.IsBigInt)(schema.exclusiveMinimum))
      yield `${value2} > BigInt(${schema.exclusiveMinimum})`;
    if ((0, guard_1.IsBigInt)(schema.maximum))
      yield `${value2} <= BigInt(${schema.maximum})`;
    if ((0, guard_1.IsBigInt)(schema.minimum))
      yield `${value2} >= BigInt(${schema.minimum})`;
    if ((0, guard_1.IsBigInt)(schema.multipleOf))
      yield `(${value2} % BigInt(${schema.multipleOf})) === 0`;
  }
  function* TBoolean2(schema, references, value2) {
    yield `(typeof ${value2} === 'boolean')`;
  }
  function* TConstructor2(schema, references, value2) {
    yield* Visit2(schema.returns, references, `${value2}.prototype`);
  }
  function* TDate2(schema, references, value2) {
    yield `(${value2} instanceof Date) && Number.isFinite(${value2}.getTime())`;
    if ((0, guard_1.IsNumber)(schema.exclusiveMaximumTimestamp))
      yield `${value2}.getTime() < ${schema.exclusiveMaximumTimestamp}`;
    if ((0, guard_1.IsNumber)(schema.exclusiveMinimumTimestamp))
      yield `${value2}.getTime() > ${schema.exclusiveMinimumTimestamp}`;
    if ((0, guard_1.IsNumber)(schema.maximumTimestamp))
      yield `${value2}.getTime() <= ${schema.maximumTimestamp}`;
    if ((0, guard_1.IsNumber)(schema.minimumTimestamp))
      yield `${value2}.getTime() >= ${schema.minimumTimestamp}`;
    if ((0, guard_1.IsNumber)(schema.multipleOfTimestamp))
      yield `(${value2}.getTime() % ${schema.multipleOfTimestamp}) === 0`;
  }
  function* TFunction2(schema, references, value2) {
    yield `(typeof ${value2} === 'function')`;
  }
  function* TInteger2(schema, references, value2) {
    yield `(typeof ${value2} === 'number' && Number.isInteger(${value2}))`;
    if ((0, guard_1.IsNumber)(schema.exclusiveMaximum))
      yield `${value2} < ${schema.exclusiveMaximum}`;
    if ((0, guard_1.IsNumber)(schema.exclusiveMinimum))
      yield `${value2} > ${schema.exclusiveMinimum}`;
    if ((0, guard_1.IsNumber)(schema.maximum))
      yield `${value2} <= ${schema.maximum}`;
    if ((0, guard_1.IsNumber)(schema.minimum))
      yield `${value2} >= ${schema.minimum}`;
    if ((0, guard_1.IsNumber)(schema.multipleOf))
      yield `(${value2} % ${schema.multipleOf}) === 0`;
  }
  function* TIntersect2(schema, references, value2) {
    const check1 = schema.allOf.map((schema2) => CreateExpression(schema2, references, value2)).join(" && ");
    if (schema.unevaluatedProperties === false) {
      const keyCheck = CreateVariable(`${new RegExp(Types.KeyResolver.ResolvePattern(schema))};`);
      const check2 = `Object.getOwnPropertyNames(${value2}).every(key => ${keyCheck}.test(key))`;
      yield `(${check1} && ${check2})`;
    } else if (Types.TypeGuard.TSchema(schema.unevaluatedProperties)) {
      const keyCheck = CreateVariable(`${new RegExp(Types.KeyResolver.ResolvePattern(schema))};`);
      const check2 = `Object.getOwnPropertyNames(${value2}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value2}[key]`)})`;
      yield `(${check1} && ${check2})`;
    } else {
      yield `(${check1})`;
    }
  }
  function* TIterator2(schema, references, value2) {
    yield `(typeof value === 'object' && Symbol.iterator in ${value2})`;
  }
  function* TLiteral2(schema, references, value2) {
    if (typeof schema.const === "number" || typeof schema.const === "boolean") {
      yield `(${value2} === ${schema.const})`;
    } else {
      yield `(${value2} === '${LiteralString.Escape(schema.const)}')`;
    }
  }
  function* TNever2(schema, references, value2) {
    yield `false`;
  }
  function* TNot2(schema, references, value2) {
    const expression = CreateExpression(schema.not, references, value2);
    yield `(!${expression})`;
  }
  function* TNull2(schema, references, value2) {
    yield `(${value2} === null)`;
  }
  function* TNumber2(schema, references, value2) {
    yield Policy.IsNumberLike(value2);
    if ((0, guard_1.IsNumber)(schema.exclusiveMaximum))
      yield `${value2} < ${schema.exclusiveMaximum}`;
    if ((0, guard_1.IsNumber)(schema.exclusiveMinimum))
      yield `${value2} > ${schema.exclusiveMinimum}`;
    if ((0, guard_1.IsNumber)(schema.maximum))
      yield `${value2} <= ${schema.maximum}`;
    if ((0, guard_1.IsNumber)(schema.minimum))
      yield `${value2} >= ${schema.minimum}`;
    if ((0, guard_1.IsNumber)(schema.multipleOf))
      yield `(${value2} % ${schema.multipleOf}) === 0`;
  }
  function* TObject2(schema, references, value2) {
    yield Policy.IsObjectLike(value2);
    if ((0, guard_1.IsNumber)(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value2}).length >= ${schema.minProperties}`;
    if ((0, guard_1.IsNumber)(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value2}).length <= ${schema.maxProperties}`;
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    for (const knownKey of knownKeys) {
      const memberExpression = MemberExpression.Encode(value2, knownKey);
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        yield* Visit2(property, references, memberExpression);
        if (Types.ExtendsUndefined.Check(property) || IsAnyOrUnknown2(property))
          yield `('${knownKey}' in ${value2})`;
      } else {
        const expression = CreateExpression(property, references, memberExpression);
        yield Policy.IsExactOptionalProperty(value2, knownKey, expression);
      }
    }
    if (schema.additionalProperties === false) {
      if (schema.required && schema.required.length === knownKeys.length) {
        yield `Object.getOwnPropertyNames(${value2}).length === ${knownKeys.length}`;
      } else {
        const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `Object.getOwnPropertyNames(${value2}).every(key => ${keys}.includes(key))`;
      }
    }
    if (typeof schema.additionalProperties === "object") {
      const expression = CreateExpression(schema.additionalProperties, references, `${value2}[key]`);
      const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
      yield `(Object.getOwnPropertyNames(${value2}).every(key => ${keys}.includes(key) || ${expression}))`;
    }
  }
  function* TPromise2(schema, references, value2) {
    yield `(typeof value === 'object' && typeof ${value2}.then === 'function')`;
  }
  function* TRecord2(schema, references, value2) {
    yield Policy.IsRecordLike(value2);
    if ((0, guard_1.IsNumber)(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value2}).length >= ${schema.minProperties}`;
    if ((0, guard_1.IsNumber)(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value2}).length <= ${schema.maxProperties}`;
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const variable = CreateVariable(`${new RegExp(patternKey)}`);
    const check1 = CreateExpression(patternSchema, references, "value");
    const check2 = Types.TypeGuard.TSchema(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value2) : schema.additionalProperties === false ? "false" : "true";
    const expression = `(${variable}.test(key) ? ${check1} : ${check2})`;
    yield `(Object.entries(${value2}).every(([key, value]) => ${expression}))`;
  }
  function* TRef2(schema, references, value2) {
    const target = (0, deref_1.Deref)(schema, references);
    if (state.functions.has(schema.$ref))
      return yield `${CreateFunctionName(schema.$ref)}(${value2})`;
    yield* Visit2(target, references, value2);
  }
  function* TString2(schema, references, value2) {
    yield `(typeof ${value2} === 'string')`;
    if ((0, guard_1.IsNumber)(schema.maxLength))
      yield `${value2}.length <= ${schema.maxLength}`;
    if ((0, guard_1.IsNumber)(schema.minLength))
      yield `${value2}.length >= ${schema.minLength}`;
    if (schema.pattern !== void 0) {
      const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
      yield `${variable}.test(${value2})`;
    }
    if (schema.format !== void 0) {
      yield `format('${schema.format}', ${value2})`;
    }
  }
  function* TSymbol2(schema, references, value2) {
    yield `(typeof ${value2} === 'symbol')`;
  }
  function* TTemplateLiteral2(schema, references, value2) {
    yield `(typeof ${value2} === 'string')`;
    const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
    yield `${variable}.test(${value2})`;
  }
  function* TThis2(schema, references, value2) {
    yield `${CreateFunctionName(schema.$ref)}(${value2})`;
  }
  function* TTuple2(schema, references, value2) {
    yield `Array.isArray(${value2})`;
    if (schema.items === void 0)
      return yield `${value2}.length === 0`;
    yield `(${value2}.length === ${schema.maxItems})`;
    for (let i2 = 0; i2 < schema.items.length; i2++) {
      const expression = CreateExpression(schema.items[i2], references, `${value2}[${i2}]`);
      yield `${expression}`;
    }
  }
  function* TUndefined2(schema, references, value2) {
    yield `${value2} === undefined`;
  }
  function* TUnion2(schema, references, value2) {
    const expressions = schema.anyOf.map((schema2) => CreateExpression(schema2, references, value2));
    yield `(${expressions.join(" || ")})`;
  }
  function* TUint8Array2(schema, references, value2) {
    yield `${value2} instanceof Uint8Array`;
    if ((0, guard_1.IsNumber)(schema.maxByteLength))
      yield `(${value2}.length <= ${schema.maxByteLength})`;
    if ((0, guard_1.IsNumber)(schema.minByteLength))
      yield `(${value2}.length >= ${schema.minByteLength})`;
  }
  function* TUnknown2(schema, references, value2) {
    yield "true";
  }
  function* TVoid2(schema, references, value2) {
    yield Policy.IsVoidLike(value2);
  }
  function* TKind2(schema, references, value2) {
    const instance = state.instances.size;
    state.instances.set(instance, schema);
    yield `kind('${schema[Types.Kind]}', ${instance}, ${value2})`;
  }
  function* Visit2(schema, references, value2, useHoisting = true) {
    const references_ = (0, guard_1.IsString)(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    if (useHoisting && (0, guard_1.IsString)(schema.$id)) {
      const functionName = CreateFunctionName(schema.$id);
      if (state.functions.has(functionName)) {
        return yield `${functionName}(${value2})`;
      } else {
        const functionCode = CreateFunction(functionName, schema, references, "value", false);
        state.functions.set(functionName, functionCode);
        return yield `${functionName}(${value2})`;
      }
    }
    switch (schema_[Types.Kind]) {
      case "Any":
        return yield* TAny2();
      case "Array":
        return yield* TArray2(schema_, references_, value2);
      case "AsyncIterator":
        return yield* TAsyncIterator2(schema_, references_, value2);
      case "BigInt":
        return yield* TBigInt2(schema_, references_, value2);
      case "Boolean":
        return yield* TBoolean2(schema_, references_, value2);
      case "Constructor":
        return yield* TConstructor2(schema_, references_, value2);
      case "Date":
        return yield* TDate2(schema_, references_, value2);
      case "Function":
        return yield* TFunction2(schema_, references_, value2);
      case "Integer":
        return yield* TInteger2(schema_, references_, value2);
      case "Intersect":
        return yield* TIntersect2(schema_, references_, value2);
      case "Iterator":
        return yield* TIterator2(schema_, references_, value2);
      case "Literal":
        return yield* TLiteral2(schema_, references_, value2);
      case "Never":
        return yield* TNever2();
      case "Not":
        return yield* TNot2(schema_, references_, value2);
      case "Null":
        return yield* TNull2(schema_, references_, value2);
      case "Number":
        return yield* TNumber2(schema_, references_, value2);
      case "Object":
        return yield* TObject2(schema_, references_, value2);
      case "Promise":
        return yield* TPromise2(schema_, references_, value2);
      case "Record":
        return yield* TRecord2(schema_, references_, value2);
      case "Ref":
        return yield* TRef2(schema_, references_, value2);
      case "String":
        return yield* TString2(schema_, references_, value2);
      case "Symbol":
        return yield* TSymbol2(schema_, references_, value2);
      case "TemplateLiteral":
        return yield* TTemplateLiteral2(schema_, references_, value2);
      case "This":
        return yield* TThis2(schema_, references_, value2);
      case "Tuple":
        return yield* TTuple2(schema_, references_, value2);
      case "Undefined":
        return yield* TUndefined2(schema_, references_, value2);
      case "Union":
        return yield* TUnion2(schema_, references_, value2);
      case "Uint8Array":
        return yield* TUint8Array2(schema_, references_, value2);
      case "Unknown":
        return yield* TUnknown2();
      case "Void":
        return yield* TVoid2(schema_, references_, value2);
      default:
        if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
          throw new TypeCompilerUnknownTypeError(schema);
        return yield* TKind2(schema_, references_, value2);
    }
  }
  const state = {
    language: "javascript",
    functions: /* @__PURE__ */ new Map(),
    variables: /* @__PURE__ */ new Map(),
    instances: /* @__PURE__ */ new Map()
    // exterior kind instances
  };
  function CreateExpression(schema, references, value2, useHoisting = true) {
    return `(${[...Visit2(schema, references, value2, useHoisting)].join(" && ")})`;
  }
  function CreateFunctionName($id) {
    return `check_${Identifier.Encode($id)}`;
  }
  function CreateVariable(expression) {
    const variableName = `local_${state.variables.size}`;
    state.variables.set(variableName, `const ${variableName} = ${expression}`);
    return variableName;
  }
  function CreateFunction(name2, schema, references, value2, useHoisting = true) {
    const [newline, pad] = ["\n", (length) => "".padStart(length, " ")];
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const expression = [...Visit2(schema, references, value2, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
    return `function ${name2}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})
}`;
  }
  function CreateParameter(name2, type) {
    const annotation = state.language === "typescript" ? `: ${type}` : "";
    return `${name2}${annotation}`;
  }
  function CreateReturns(type) {
    return state.language === "typescript" ? `: ${type}` : "";
  }
  function Build(schema, references, options) {
    const functionCode = CreateFunction("check", schema, references, "value");
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const functions = [...state.functions.values()];
    const variables = [...state.variables.values()];
    const checkFunction = (0, guard_1.IsString)(schema.$id) ? `return function check(${parameter})${returns} {
  return ${CreateFunctionName(schema.$id)}(value)
}` : `return ${functionCode}`;
    return [...variables, ...functions, checkFunction].join("\n");
  }
  function Code(...args) {
    const defaults = { language: "javascript" };
    const [schema, references, options] = args.length === 2 && (0, guard_1.IsArray)(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !(0, guard_1.IsArray)(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
    state.language = options.language;
    state.variables.clear();
    state.functions.clear();
    state.instances.clear();
    if (!Types.TypeGuard.TSchema(schema))
      throw new TypeCompilerTypeGuardError(schema);
    for (const schema2 of references)
      if (!Types.TypeGuard.TSchema(schema2))
        throw new TypeCompilerTypeGuardError(schema2);
    return Build(schema, references);
  }
  TypeCompiler2.Code = Code;
  function Compile(schema, references = []) {
    const generatedCode = Code(schema, references, { language: "javascript" });
    const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
    const instances = new Map(state.instances);
    function typeRegistryFunction(kind, instance, value2) {
      if (!Types.TypeRegistry.Has(kind) || !instances.has(instance))
        return false;
      const checkFunc = Types.TypeRegistry.Get(kind);
      const schema2 = instances.get(instance);
      return checkFunc(schema2, value2);
    }
    function formatRegistryFunction(format, value2) {
      if (!Types.FormatRegistry.Has(format))
        return false;
      const checkFunc = Types.FormatRegistry.Get(format);
      return checkFunc(value2);
    }
    function hashFunction(value2) {
      return (0, hash_1.Hash)(value2);
    }
    const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
    return new TypeCheck(schema, references, checkFunction, generatedCode);
  }
  TypeCompiler2.Compile = Compile;
})(TypeCompiler || (compiler.TypeCompiler = TypeCompiler = {}));
(function(exports2) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ValueErrorIterator = exports2.ValueErrorType = void 0;
  var index_12 = errors$1;
  Object.defineProperty(exports2, "ValueErrorType", { enumerable: true, get: function() {
    return index_12.ValueErrorType;
  } });
  Object.defineProperty(exports2, "ValueErrorIterator", { enumerable: true, get: function() {
    return index_12.ValueErrorIterator;
  } });
  __exportStar(compiler, exports2);
})(compiler$1);
const PluginCompiler = compiler$1.TypeCompiler.Compile(Plugin);
const resolvePlugins = async (args) => {
  const result = {
    data: {
      loadMessages: void 0,
      saveMessages: void 0,
      customApi: {}
    },
    errors: []
  };
  for (const plugin of args.plugins) {
    const errors2 = [...PluginCompiler.Errors(plugin)];
    const hasInvalidId = errors2.some((error) => error.path === "/id");
    if (hasInvalidId) {
      result.errors.push(new PluginHasInvalidIdError({ id: plugin.id }));
    }
    if (errors2.length > 0) {
      result.errors.push(new PluginHasInvalidSchemaError({
        id: plugin.id,
        errors: errors2
      }));
    }
    if (typeof plugin.loadMessages === "function" && result.data.loadMessages !== void 0) {
      result.errors.push(new PluginLoadMessagesFunctionAlreadyDefinedError({ id: plugin.id }));
    }
    if (typeof plugin.saveMessages === "function" && result.data.saveMessages !== void 0) {
      result.errors.push(new PluginSaveMessagesFunctionAlreadyDefinedError({ id: plugin.id }));
    }
    if (typeof plugin.addCustomApi === "function") {
      const { data: customApi, error } = tryCatch(() => plugin.addCustomApi({
        settings: args.settings
      }));
      if (error) {
        result.errors.push(new PluginReturnedInvalidCustomApiError({ id: plugin.id, cause: error }));
      } else if (typeof customApi !== "object") {
        result.errors.push(new PluginReturnedInvalidCustomApiError({
          id: plugin.id,
          cause: new Error(`The return value must be an object. Received "${typeof customApi}".`)
        }));
      }
    }
    if (result.errors.length > 0) {
      continue;
    }
    if (typeof plugin.loadMessages === "function") {
      result.data.loadMessages = (_args) => plugin.loadMessages({
        ..._args
        // renoved nodeishFs from args because we need to pass custom wrapped fs that establishes a watcher
      });
    }
    if (typeof plugin.saveMessages === "function") {
      result.data.saveMessages = (_args) => plugin.saveMessages({
        ..._args,
        nodeishFs: args.nodeishFs
      });
    }
    if (typeof plugin.addCustomApi === "function") {
      const { data: customApi } = tryCatch(() => plugin.addCustomApi({
        settings: args.settings
      }));
      if (customApi) {
        result.data.customApi = deepmerge(result.data.customApi, customApi);
      }
    }
  }
  if (typeof result.data.loadMessages !== "function" || typeof result.data.saveMessages !== "function") {
    result.errors.push(new PluginsDoNotProvideLoadOrSaveMessagesError());
  }
  return result;
};
const validatedModuleSettings = (args) => {
  if (args.settingsSchema && args.moduleSettings) {
    const hasValidSettings = value$1.Value.Check(args.settingsSchema, args.moduleSettings);
    if (hasValidSettings === false) {
      const errors2 = [...value$1.Value.Errors(args.settingsSchema, args.moduleSettings)];
      return errors2;
    }
  }
  return "isValid";
};
const ModuleCompiler = compiler$1.TypeCompiler.Compile(InlangModule);
const resolveModules = async (args) => {
  var _a;
  const _import = args._import ?? createImport({ readFile: args.nodeishFs.readFile });
  const moduleErrors = [];
  const allPlugins = [];
  const allMessageLintRules = [];
  const meta = [];
  for (const module of args.settings.modules) {
    const importedModule = await tryCatch(() => _import(module));
    if (importedModule.error) {
      moduleErrors.push(new ModuleImportError({
        module,
        cause: importedModule.error
      }));
      continue;
    }
    if (((_a = importedModule.data) == null ? void 0 : _a.default) === void 0) {
      moduleErrors.push(new ModuleHasNoExportsError({
        module
      }));
      continue;
    }
    const isValidModule = ModuleCompiler.Check(importedModule.data);
    if (isValidModule === false) {
      const errors2 = [...ModuleCompiler.Errors(importedModule.data)];
      moduleErrors.push(new ModuleExportIsInvalidError({
        module,
        errors: errors2
      }));
      continue;
    }
    const result = validatedModuleSettings({
      settingsSchema: importedModule.data.default.settingsSchema,
      moduleSettings: args.settings[importedModule.data.default.id]
    });
    if (result !== "isValid") {
      moduleErrors.push(new ModuleSettingsAreInvalidError({ module, errors: result }));
      continue;
    }
    meta.push({
      module,
      id: importedModule.data.default.id
    });
    if (importedModule.data.default.id.startsWith("plugin.")) {
      allPlugins.push(importedModule.data.default);
    } else if (importedModule.data.default.id.startsWith("messageLintRule.")) {
      allMessageLintRules.push(importedModule.data.default);
    } else {
      moduleErrors.push(new ModuleError(`Unimplemented module type ${importedModule.data.default.id}.The module has not been installed.`, { module }));
    }
  }
  const resolvedPlugins = await resolvePlugins({
    plugins: allPlugins,
    settings: args.settings,
    nodeishFs: args.nodeishFs
  });
  const resolvedLintRules = resolveMessageLintRules({ messageLintRules: allMessageLintRules });
  return {
    meta,
    messageLintRules: allMessageLintRules,
    plugins: allPlugins,
    resolvedPluginApi: resolvedPlugins.data,
    errors: [...moduleErrors, ...resolvedLintRules.errors, ...resolvedPlugins.errors]
  };
};
function assertValidProjectPath(projectPath) {
  if (!isAbsolutePath(projectPath)) {
    throw new Error(`Expected an absolute path but received "${projectPath}".`);
  }
  if (!isInlangProjectPath(projectPath)) {
    throw new Error(`Expected a path ending in "{name}.inlang" but received "${projectPath}".

Valid examples: 
- "/path/to/micky-mouse.inlang"
- "/path/to/green-elephant.inlang
`);
  }
}
function isInlangProjectPath(path2) {
  return /[^\\/]+\.inlang$/.test(path2);
}
function isAbsolutePath(path2) {
  return /^\/|^[A-Za-z]:[\\/]/.test(path2);
}
class ProjectSettingsInvalidError extends Error {
  constructor(options) {
    super(`The project settings are invalid:

${options.errors.filter((error) => error.path).map((error) => `"${error.path}":

${error.message}`).join("\n")}`);
    this.name = "ProjectSettingsInvalidError";
  }
}
class ProjectSettingsFileJSONSyntaxError extends Error {
  constructor(options) {
    super(`The settings file at "${options.path}" is not a valid JSON file:

${options.cause}`, options);
    this.name = "ProjectSettingsFileJSONSyntaxError";
  }
}
class ProjectSettingsFileNotFoundError extends Error {
  constructor(options) {
    super(`The file at "${options.path}" could not be read. Does the file exists?`, options);
    this.name = "ProjectSettingsFileNotFoundError";
  }
}
class PluginSaveMessagesError extends Error {
  constructor(options) {
    super(`An error occured in saveMessages() caused by ${options.cause}.`, options);
    this.name = "PluginSaveMessagesError";
  }
}
class PluginLoadMessagesError extends Error {
  constructor(options) {
    super(`An error occured in loadMessages() caused by ${options.cause}.`, options);
    this.name = "PluginLoadMessagesError";
  }
}
const equalFn = (a, b) => a === b;
const signalOptions = {
  equals: equalFn
};
let runEffects = runQueue;
const STALE = 1;
const PENDING = 2;
const UNOWNED = {
  owned: null,
  cleanups: null,
  context: null,
  owner: null
};
var Owner = null;
let Transition = null;
let Listener = null;
let Updates = null;
let Effects = null;
let ExecCount = 0;
function createRoot$1(fn, detachedOwner) {
  const listener = Listener, owner = Owner, unowned = fn.length === 0, root = unowned ? UNOWNED : {
    owned: null,
    cleanups: null,
    context: null,
    owner: detachedOwner === void 0 ? owner : detachedOwner
  }, updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root)));
  Owner = root;
  Listener = null;
  try {
    return runUpdates(updateFn, true);
  } finally {
    Listener = listener;
    Owner = owner;
  }
}
function createSignal$1(value2, options) {
  options = options ? Object.assign({}, signalOptions, options) : signalOptions;
  const s = {
    value: value2,
    observers: null,
    observerSlots: null,
    comparator: options.equals || void 0
  };
  const setter = (value3) => {
    if (typeof value3 === "function") {
      value3 = value3(s.value);
    }
    return writeSignal(s, value3);
  };
  return [readSignal.bind(s), setter];
}
function createEffect$1(fn, value2, options) {
  runEffects = runUserEffects;
  const c = createComputation(fn, value2, false, STALE);
  c.user = true;
  Effects ? Effects.push(c) : updateComputation(c);
}
function batch$1(fn) {
  return runUpdates(fn, false);
}
function untrack(fn) {
  if (Listener === null)
    return fn();
  const listener = Listener;
  Listener = null;
  try {
    return fn();
  } finally {
    Listener = listener;
  }
}
function onCleanup$1(fn) {
  if (Owner === null)
    ;
  else if (Owner.cleanups === null)
    Owner.cleanups = [fn];
  else
    Owner.cleanups.push(fn);
  return fn;
}
function getListener$1() {
  return Listener;
}
function readSignal() {
  const runningTransition = Transition;
  if (this.sources && (this.state || runningTransition)) {
    if (this.state === STALE || runningTransition)
      updateComputation(this);
    else {
      const updates = Updates;
      Updates = null;
      runUpdates(() => lookUpstream(this), false);
      Updates = updates;
    }
  }
  if (Listener) {
    const sSlot = this.observers ? this.observers.length : 0;
    if (!Listener.sources) {
      Listener.sources = [this];
      Listener.sourceSlots = [sSlot];
    } else {
      Listener.sources.push(this);
      Listener.sourceSlots.push(sSlot);
    }
    if (!this.observers) {
      this.observers = [Listener];
      this.observerSlots = [Listener.sources.length - 1];
    } else {
      this.observers.push(Listener);
      this.observerSlots.push(Listener.sources.length - 1);
    }
  }
  return this.value;
}
function writeSignal(node2, value2, isComp) {
  let current = node2.value;
  if (!node2.comparator || !node2.comparator(current, value2)) {
    node2.value = value2;
    if (node2.observers && node2.observers.length) {
      runUpdates(() => {
        for (let i2 = 0; i2 < node2.observers.length; i2 += 1) {
          const o = node2.observers[i2];
          const TransitionRunning = Transition && Transition.running;
          if (TransitionRunning && Transition.disposed.has(o))
            ;
          if (TransitionRunning && !o.tState || !TransitionRunning && !o.state) {
            if (o.pure)
              Updates.push(o);
            else
              Effects.push(o);
            if (o.observers)
              markDownstream(o);
          }
          if (TransitionRunning)
            ;
          else
            o.state = STALE;
        }
        if (Updates.length > 1e6) {
          Updates = [];
          if (false)
            ;
          throw new Error();
        }
      }, false);
    }
  }
  return value2;
}
function updateComputation(node2) {
  if (!node2.fn)
    return;
  cleanNode(node2);
  const owner = Owner, listener = Listener, time = ExecCount;
  Listener = Owner = node2;
  runComputation(node2, node2.value, time);
  Listener = listener;
  Owner = owner;
}
function runComputation(node2, value2, time) {
  let nextValue;
  try {
    nextValue = node2.fn(value2);
  } catch (err) {
    if (node2.pure) {
      {
        node2.state = STALE;
        node2.owned && node2.owned.forEach(cleanNode);
        node2.owned = null;
      }
    }
    node2.updatedAt = time + 1;
    return handleError(err);
  }
  if (!node2.updatedAt || node2.updatedAt <= time) {
    if (node2.updatedAt != null && "observers" in node2) {
      writeSignal(node2, nextValue);
    } else
      node2.value = nextValue;
    node2.updatedAt = time;
  }
}
function createComputation(fn, init, pure, state = STALE, options) {
  const c = {
    fn,
    state,
    updatedAt: null,
    owned: null,
    sources: null,
    sourceSlots: null,
    cleanups: null,
    value: init,
    owner: Owner,
    context: null,
    pure
  };
  if (Owner === null)
    ;
  else if (Owner !== UNOWNED) {
    {
      if (!Owner.owned)
        Owner.owned = [c];
      else
        Owner.owned.push(c);
    }
  }
  return c;
}
function runTop(node2) {
  const runningTransition = Transition;
  if (node2.state === 0 || runningTransition)
    return;
  if (node2.state === PENDING || runningTransition)
    return lookUpstream(node2);
  if (node2.suspense && untrack(node2.suspense.inFallback))
    return node2.suspense.effects.push(node2);
  const ancestors = [node2];
  while ((node2 = node2.owner) && (!node2.updatedAt || node2.updatedAt < ExecCount)) {
    if (node2.state || runningTransition)
      ancestors.push(node2);
  }
  for (let i2 = ancestors.length - 1; i2 >= 0; i2--) {
    node2 = ancestors[i2];
    if (node2.state === STALE || runningTransition) {
      updateComputation(node2);
    } else if (node2.state === PENDING || runningTransition) {
      const updates = Updates;
      Updates = null;
      runUpdates(() => lookUpstream(node2, ancestors[0]), false);
      Updates = updates;
    }
  }
}
function runUpdates(fn, init) {
  if (Updates)
    return fn();
  let wait = false;
  if (!init)
    Updates = [];
  if (Effects)
    wait = true;
  else
    Effects = [];
  ExecCount++;
  try {
    const res = fn();
    completeUpdates(wait);
    return res;
  } catch (err) {
    if (!wait)
      Effects = null;
    Updates = null;
    handleError(err);
  }
}
function completeUpdates(wait) {
  if (Updates) {
    runQueue(Updates);
    Updates = null;
  }
  if (wait)
    return;
  const e = Effects;
  Effects = null;
  if (e.length)
    runUpdates(() => runEffects(e), false);
}
function runQueue(queue) {
  for (let i2 = 0; i2 < queue.length; i2++)
    runTop(queue[i2]);
}
function runUserEffects(queue) {
  let i2, userLength = 0;
  for (i2 = 0; i2 < queue.length; i2++) {
    const e = queue[i2];
    if (!e.user)
      runTop(e);
    else
      queue[userLength++] = e;
  }
  for (i2 = 0; i2 < userLength; i2++)
    runTop(queue[i2]);
}
function lookUpstream(node2, ignore) {
  const runningTransition = Transition;
  node2.state = 0;
  for (let i2 = 0; i2 < node2.sources.length; i2 += 1) {
    const source = node2.sources[i2];
    if (source.sources) {
      if (source.state === STALE || runningTransition) {
        if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount))
          runTop(source);
      } else if (source.state === PENDING || runningTransition)
        lookUpstream(source, ignore);
    }
  }
}
function markDownstream(node2) {
  const runningTransition = Transition;
  for (let i2 = 0; i2 < node2.observers.length; i2 += 1) {
    const o = node2.observers[i2];
    if (!o.state || runningTransition) {
      o.state = PENDING;
      if (o.pure)
        Updates.push(o);
      else
        Effects.push(o);
      o.observers && markDownstream(o);
    }
  }
}
function cleanNode(node2) {
  let i2;
  if (node2.sources) {
    while (node2.sources.length) {
      const source = node2.sources.pop(), index = node2.sourceSlots.pop(), obs = source.observers;
      if (obs && obs.length) {
        const n = obs.pop(), s = source.observerSlots.pop();
        if (index < obs.length) {
          n.sourceSlots[s] = index;
          obs[index] = n;
          source.observerSlots[index] = s;
        }
      }
    }
  }
  if (node2.owned) {
    for (i2 = 0; i2 < node2.owned.length; i2++)
      cleanNode(node2.owned[i2]);
    node2.owned = null;
  }
  if (node2.cleanups) {
    for (i2 = 0; i2 < node2.cleanups.length; i2++)
      node2.cleanups[i2]();
    node2.cleanups = null;
  }
  node2.state = 0;
  node2.context = null;
}
function castError(err) {
  if (err instanceof Error || typeof err === "string")
    return err;
  return new Error("Unknown error");
}
function handleError(err) {
  err = castError(err);
  throw err;
}
const createSignal = createSignal$1;
const createRoot = createRoot$1;
const createEffect = createEffect$1;
const batch = batch$1;
const getListener = getListener$1;
const onCleanup = onCleanup$1;
var triggerOptions = { equals: false };
var triggerCacheOptions = triggerOptions;
var TriggerCache = class {
  #map;
  constructor(mapConstructor = Map) {
    this.#map = new mapConstructor();
  }
  dirty(key) {
    var _a;
    (_a = this.#map.get(key)) == null ? void 0 : _a.$$();
  }
  track(key) {
    if (!getListener())
      return;
    let trigger = this.#map.get(key);
    if (!trigger) {
      const [$, $$] = createSignal(void 0, triggerCacheOptions);
      this.#map.set(key, trigger = { $, $$, n: 1 });
    } else
      trigger.n++;
    onCleanup(() => {
      if (trigger.n-- === 1)
        queueMicrotask(() => trigger.n === 0 && this.#map.delete(key));
    });
    trigger.$();
  }
};
var $KEYS = Symbol("track-keys");
var ReactiveMap = class extends Map {
  #keyTriggers = new TriggerCache();
  #valueTriggers = new TriggerCache();
  constructor(initial) {
    super();
    if (initial)
      for (const v of initial)
        super.set(v[0], v[1]);
  }
  // reads
  has(key) {
    this.#keyTriggers.track(key);
    return super.has(key);
  }
  get(key) {
    this.#valueTriggers.track(key);
    return super.get(key);
  }
  get size() {
    this.#keyTriggers.track($KEYS);
    return super.size;
  }
  keys() {
    this.#keyTriggers.track($KEYS);
    return super.keys();
  }
  values() {
    this.#keyTriggers.track($KEYS);
    for (const v of super.keys())
      this.#valueTriggers.track(v);
    return super.values();
  }
  entries() {
    this.#keyTriggers.track($KEYS);
    for (const v of super.keys())
      this.#valueTriggers.track(v);
    return super.entries();
  }
  // writes
  set(key, value2) {
    batch(() => {
      if (super.has(key)) {
        if (super.get(key) === value2)
          return;
      } else {
        this.#keyTriggers.dirty(key);
        this.#keyTriggers.dirty($KEYS);
      }
      this.#valueTriggers.dirty(key);
      super.set(key, value2);
    });
    return this;
  }
  delete(key) {
    const r = super.delete(key);
    if (r) {
      batch(() => {
        this.#keyTriggers.dirty(key);
        this.#keyTriggers.dirty($KEYS);
        this.#valueTriggers.dirty(key);
      });
    }
    return r;
  }
  clear() {
    if (super.size) {
      batch(() => {
        for (const v of super.keys()) {
          this.#keyTriggers.dirty(v);
          this.#valueTriggers.dirty(v);
        }
        super.clear();
        this.#keyTriggers.dirty($KEYS);
      });
    }
  }
  // callback
  forEach(callbackfn) {
    this.#keyTriggers.track($KEYS);
    super.forEach((value2, key) => callbackfn(value2, key, this));
  }
  [Symbol.iterator]() {
    return this.entries();
  }
};
function createMessagesQuery(messages) {
  const index = new ReactiveMap();
  const defaultAliasIndex = new ReactiveMap();
  createEffect(() => {
    index.clear();
    for (const message of structuredClone(messages())) {
      index.set(message.id, message);
      if ("default" in message.alias) {
        defaultAliasIndex.set(message.alias.default, message);
      }
    }
  });
  const get = (args) => index.get(args.where.id);
  const getByDefaultAlias = (alias) => defaultAliasIndex.get(alias);
  return {
    create: ({ data }) => {
      if (index.has(data.id))
        return false;
      index.set(data.id, data);
      if ("default" in data.alias) {
        defaultAliasIndex.set(data.alias.default, data);
      }
      return true;
    },
    get: Object.assign(get, {
      subscribe: (args, callback) => createSubscribable(() => get(args)).subscribe(callback)
    }),
    getByDefaultAlias: Object.assign(getByDefaultAlias, {
      subscribe: (alias, callback) => createSubscribable(() => getByDefaultAlias(alias)).subscribe(callback)
    }),
    includedMessageIds: createSubscribable(() => {
      return [...index.keys()];
    }),
    getAll: createSubscribable(() => {
      return [...index.values()];
    }),
    update: ({ where, data }) => {
      const message = index.get(where.id);
      if (message === void 0)
        return false;
      index.set(where.id, { ...message, ...data });
      return true;
    },
    upsert: ({ where, data }) => {
      const message = index.get(where.id);
      if (message === void 0) {
        index.set(where.id, data);
        if ("default" in data.alias) {
          defaultAliasIndex.set(data.alias.default, data);
        }
      } else {
        index.set(where.id, { ...message, ...data });
      }
      return true;
    },
    delete: ({ where }) => {
      const message = index.get(where.id);
      if (message === void 0)
        return false;
      if ("default" in message.alias) {
        defaultAliasIndex.delete(message.alias.default);
      }
      index.delete(where.id);
      return true;
    }
  };
}
class MessagedLintRuleThrowedError extends Error {
  constructor(message, options) {
    super(message, options);
    this.name = "MessagedLintRuleThrowedError";
  }
}
const lintSingleMessage = async (args) => {
  const reports = [];
  const errors2 = [];
  const promises = args.rules.map(async (rule) => {
    var _a;
    const level = (_a = args.settings.messageLintRuleLevels) == null ? void 0 : _a[rule.id];
    if (level === void 0) {
      throw Error("No lint level provided for lint rule: " + rule.id);
    }
    try {
      await rule.run({
        message: args.message,
        settings: args.settings,
        report: (reportArgs) => {
          reports.push({
            ruleId: rule.id,
            level,
            messageId: reportArgs.messageId,
            languageTag: reportArgs.languageTag,
            body: reportArgs.body
          });
        }
      });
    } catch (error) {
      errors2.push(new MessagedLintRuleThrowedError(`Lint rule '${rule.id}' throwed while linting message "${args.message.id}".`, { cause: error }));
    }
  });
  await Promise.all(promises);
  return { data: reports, errors: errors2 };
};
function throttle(delay, callback, options) {
  var _ref = options || {}, _ref$noTrailing = _ref.noTrailing, noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing, _ref$noLeading = _ref.noLeading, noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading, _ref$debounceMode = _ref.debounceMode, debounceMode = _ref$debounceMode === void 0 ? void 0 : _ref$debounceMode;
  var timeoutID;
  var cancelled = false;
  var lastExec = 0;
  function clearExistingTimeout() {
    if (timeoutID) {
      clearTimeout(timeoutID);
    }
  }
  function cancel(options2) {
    var _ref2 = options2 || {}, _ref2$upcomingOnly = _ref2.upcomingOnly, upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;
    clearExistingTimeout();
    cancelled = !upcomingOnly;
  }
  function wrapper() {
    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
      arguments_[_key] = arguments[_key];
    }
    var self2 = this;
    var elapsed = Date.now() - lastExec;
    if (cancelled) {
      return;
    }
    function exec() {
      lastExec = Date.now();
      callback.apply(self2, arguments_);
    }
    function clear() {
      timeoutID = void 0;
    }
    if (!noLeading && debounceMode && !timeoutID) {
      exec();
    }
    clearExistingTimeout();
    if (debounceMode === void 0 && elapsed > delay) {
      if (noLeading) {
        lastExec = Date.now();
        if (!noTrailing) {
          timeoutID = setTimeout(debounceMode ? clear : exec, delay);
        }
      } else {
        exec();
      }
    } else if (noTrailing !== true) {
      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay - elapsed : delay);
    }
  }
  wrapper.cancel = cancel;
  return wrapper;
}
var src = { exports: {} };
var browser$1 = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs)
    return ms;
  hasRequiredMs = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse2(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name2) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name2 + (isPlural ? "s" : "");
  }
  return ms;
}
var common;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon)
    return common;
  hasRequiredCommon = 1;
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash2 = 0;
      for (let i2 = 0; i2 < namespace.length; i2++) {
        hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i2);
        hash2 |= 0;
      }
      return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace);
      debug2.extend = extend;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i2;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i2 = 0; i2 < len; i2++) {
        if (!split[i2]) {
          continue;
        }
        namespaces = split[i2].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name2) {
      if (name2[name2.length - 1] === "*") {
        return true;
      }
      let i2;
      let len;
      for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
        if (createDebug.skips[i2].test(name2)) {
          return false;
        }
      }
      for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
        if (createDebug.names[i2].test(name2)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce2(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common = setup;
  return common;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser)
    return browser$1.exports;
  hasRequiredBrowser = 1;
  (function(module, exports2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = requireCommon()(exports2);
    const { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  })(browser$1, browser$1.exports);
  return browser$1.exports;
}
var node = { exports: {} };
var hasFlag;
var hasRequiredHasFlag;
function requireHasFlag() {
  if (hasRequiredHasFlag)
    return hasFlag;
  hasRequiredHasFlag = 1;
  hasFlag = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
  return hasFlag;
}
var supportsColor_1;
var hasRequiredSupportsColor;
function requireSupportsColor() {
  if (hasRequiredSupportsColor)
    return supportsColor_1;
  hasRequiredSupportsColor = 1;
  const os2 = require$$0;
  const tty = require$$1;
  const hasFlag2 = requireHasFlag();
  const { env } = process;
  let flagForceColor;
  if (hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false") || hasFlag2("color=never")) {
    flagForceColor = 0;
  } else if (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) {
    flagForceColor = 1;
  }
  function envForceColor() {
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        return 1;
      }
      if (env.FORCE_COLOR === "false") {
        return 0;
      }
      return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
    const noFlagForceColor = envForceColor();
    if (noFlagForceColor !== void 0) {
      flagForceColor = noFlagForceColor;
    }
    const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
    if (forceColor === 0) {
      return 0;
    }
    if (sniffFlags) {
      if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor")) {
        return 3;
      }
      if (hasFlag2("color=256")) {
        return 2;
      }
    }
    if (haveStream && !streamIsTTY && forceColor === void 0) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os2.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE", "DRONE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version2 = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version2 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream, options = {}) {
    const level = supportsColor(stream, {
      streamIsTTY: stream && stream.isTTY,
      ...options
    });
    return translateLevel(level);
  }
  supportsColor_1 = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel({ isTTY: tty.isatty(1) }),
    stderr: getSupportLevel({ isTTY: tty.isatty(2) })
  };
  return supportsColor_1;
}
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode)
    return node.exports;
  hasRequiredNode = 1;
  (function(module, exports2) {
    const tty = require$$1;
    const util2 = require$$1$1;
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = requireSupportsColor();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name2, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name2} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name2 + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util2.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug2) {
      debug2.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i2 = 0; i2 < keys.length; i2++) {
        debug2.inspectOpts[keys[i2]] = exports2.inspectOpts[keys[i2]];
      }
    }
    module.exports = requireCommon()(exports2);
    const { formatters } = module.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  })(node, node.exports);
  return node.exports;
}
if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
  src.exports = requireBrowser();
} else {
  src.exports = requireNode();
}
var srcExports = src.exports;
const _debug$1 = /* @__PURE__ */ getDefaultExportFromCjs(srcExports);
const debug$1 = _debug$1("sdk:lintReports");
function sleep(ms2) {
  return new Promise((resolve) => setTimeout(resolve, ms2));
}
function createMessageLintReportsQuery(messagesQuery, settings, installedMessageLintRules, resolvedModules) {
  const index = /* @__PURE__ */ new Map();
  const modules = resolvedModules();
  const rulesArray = modules == null ? void 0 : modules.messageLintRules;
  const messageLintRuleLevels = Object.fromEntries(installedMessageLintRules().map((rule) => [rule.id, rule.level]));
  const settingsObject = () => {
    return {
      ...settings(),
      messageLintRuleLevels
    };
  };
  const messages = messagesQuery.getAll();
  const trackedMessages = /* @__PURE__ */ new Map();
  debug$1(`createMessageLintReportsQuery ${rulesArray == null ? void 0 : rulesArray.length} rules, ${messages.length} messages`);
  let lintMessageCount = 0;
  const throttledLogLintMessage = throttle(2e3, (messageId) => {
    debug$1(`lintSingleMessage: ${lintMessageCount} id: ${messageId}`);
  });
  createEffect(() => {
    const currentMessageIds = new Set(messagesQuery.includedMessageIds());
    const deletedTrackedMessages = [...trackedMessages].filter((tracked) => !currentMessageIds.has(tracked[0]));
    if (rulesArray) {
      for (const messageId of currentMessageIds) {
        if (!trackedMessages.has(messageId)) {
          createRoot((dispose) => {
            createEffect(() => {
              const message = messagesQuery.get({ where: { id: messageId } });
              if (!message) {
                return;
              }
              if (!(trackedMessages == null ? void 0 : trackedMessages.has(messageId))) {
                trackedMessages == null ? void 0 : trackedMessages.set(messageId, dispose);
              }
              lintSingleMessage({
                rules: rulesArray,
                settings: settingsObject(),
                messages,
                message
              }).then((report) => {
                lintMessageCount++;
                throttledLogLintMessage(messageId);
                if (report.errors.length === 0 && index.get(messageId) !== report.data) {
                  index.set(messageId, report.data);
                }
              });
            });
          });
        }
      }
      for (const deletedMessage of deletedTrackedMessages) {
        const deletedMessageId = deletedMessage[0];
        const messageEffectDisposeFunction = trackedMessages.get(deletedMessageId);
        if (messageEffectDisposeFunction) {
          messageEffectDisposeFunction();
          trackedMessages.delete(deletedMessageId);
          index.delete(deletedMessageId);
          debug$1(`delete lint message id: ${deletedMessageId}`);
        }
      }
    }
  });
  return {
    getAll: async () => {
      await sleep(0);
      return structuredClone([...index.values()].flat().length === 0 ? [] : [...index.values()].flat());
    },
    get: async (args) => {
      await sleep(0);
      return structuredClone(index.get(args.where.messageId) ?? []);
    }
  };
}
const migrate1to2 = (config2) => {
  const migrated = {
    $schema: "https://inlang.com/schema/project-settings",
    sourceLanguageTag: config2.sourceLanguageTag,
    languageTags: config2.languageTags,
    modules: config2.modules
  };
  if (config2.settings["project.messageLintRuleLevels"]) {
    migrated.messageLintRuleLevels = config2.settings["project.messageLintRuleLevels"];
  }
  for (const key in config2.settings) {
    if (key === "project.messageLintRuleLevels")
      continue;
    migrated[key] = config2.settings[key];
  }
  return migrated;
};
function migrateIfOutdated(schema) {
  if (schema.settings) {
    return migrate1to2(schema);
  }
  return schema;
}
function normalizePath(path2, stripTrailing) {
  if (path2 === "\\" || path2 === "/")
    return "/";
  const len = path2.length;
  if (len <= 1)
    return path2;
  let prefix = "";
  if (len > 4 && path2[3] === "\\") {
    const ch = path2[2];
    if ((ch === "?" || ch === ".") && path2.slice(0, 2) === "\\\\") {
      path2 = path2.slice(2);
      prefix = "//";
    }
  }
  const segs = path2.split(/[/\\]+/);
  const stack = [];
  for (const seg of segs) {
    if (seg === "..") {
      stack.pop();
    } else if (seg !== ".") {
      stack.push(seg);
    }
  }
  if (stripTrailing !== false && stack.at(-1) === "") {
    stack.pop();
  }
  return prefix + stack.join("/");
}
function normalPath(path2) {
  var _a;
  const dots = /(\/|^)(\.\/)+/g;
  const slashes = /\/+/g;
  const upreference = /(?<!\.\.)[^/]+\/\.\.\//;
  path2 = `/${path2}/`;
  path2 = path2.replace(/^\/\.\./, "");
  path2 = path2.replace(dots, "/").replace(slashes, "/");
  let match;
  while (match = (_a = path2.match(upreference)) == null ? void 0 : _a[0]) {
    path2 = path2.replace(match, "");
  }
  return path2;
}
function getDirname(path2) {
  return normalPath(path2.split("/").filter((x) => x).slice(0, -1).join("/") ?? path2);
}
function getBasename(path2) {
  return path2.split("/").filter((x) => x).at(-1) ?? path2;
}
const createNodeishFsWithAbsolutePaths = (args) => {
  if (!isAbsolutePath(args.projectPath)) {
    throw new Error(`Expected an absolute path but received "${args.projectPath}".`);
  }
  const basePath = normalizePath(args.projectPath).split("/").slice(0, -1).join("/");
  const makeAbsolute = (path2) => {
    if (isAbsolutePath(path2)) {
      return normalizePath(path2);
    }
    return normalizePath(basePath + "/" + path2);
  };
  return {
    // @ts-expect-error
    readFile: (path2, options) => args.nodeishFs.readFile(makeAbsolute(path2), options),
    readdir: (path2) => args.nodeishFs.readdir(makeAbsolute(path2)),
    mkdir: (path2, options) => args.nodeishFs.mkdir(makeAbsolute(path2), options),
    writeFile: (path2, data) => args.nodeishFs.writeFile(makeAbsolute(path2), data),
    stat: (path2) => args.nodeishFs.stat(makeAbsolute(path2)),
    rm: (path2) => args.nodeishFs.rm(makeAbsolute(path2)),
    rmdir: (path2) => args.nodeishFs.rmdir(makeAbsolute(path2)),
    watch: (path2, options) => args.nodeishFs.watch(makeAbsolute(path2), options),
    // This might be surprising when symlinks were intended to be relative
    symlink: (target, path2) => args.nodeishFs.symlink(makeAbsolute(target), makeAbsolute(path2)),
    unlink: (path2) => args.nodeishFs.unlink(makeAbsolute(path2)),
    readlink: (path2) => args.nodeishFs.readlink(makeAbsolute(path2)),
    lstat: (path2) => args.nodeishFs.lstat(makeAbsolute(path2))
  };
};
const maybeMigrateToDirectory = async (args) => {
  if (args.projectPath.endsWith("project.inlang") === false) {
    return;
  }
  const projectDirectory = await tryCatch(() => args.nodeishFs.stat(args.projectPath));
  if (projectDirectory.data) {
    return;
  }
  const settingsFile = await tryCatch(() => args.nodeishFs.readFile(args.projectPath + ".json", { encoding: "utf-8" }));
  if (settingsFile.error) {
    return;
  }
  await args.nodeishFs.mkdir(args.projectPath);
  await args.nodeishFs.writeFile(`${args.projectPath}/settings.json`, settingsFile.data);
  await args.nodeishFs.writeFile(args.projectPath + ".README.md", readme);
};
const readme = `
# DELETE THE \`project.inlang.json\` FILE

The \`project.inlang.json\` file is now contained in a project directory e.g. \`project.inlang/settings.json\`.


## What you need to do

1. Update the inlang CLI (if you use it) to use the new path \`project.inlang\` instead of \`project.inlang.json\`.
2. Delete the \`project.inlang.json\` file.


## Why is this happening?

See this RFC https://docs.google.com/document/d/1OYyA1wYfQRbIJOIBDliYoWjiUlkFBNxH_U2R4WpVRZ4/edit#heading=h.pecv6xb7ial6 
and the following GitHub issue for more information https://github.com/opral/monorepo/issues/1678.

- Monorepo support https://github.com/opral/monorepo/discussions/258. 
- Required for many other future features like caching, first class offline support, and more. 
- Stablize the inlang project format.
`;
function stringifyMessage(message) {
  const messageWithSortedKeys = {};
  for (const key of Object.keys(message).sort()) {
    messageWithSortedKeys[key] = message[key];
  }
  messageWithSortedKeys["variants"] = messageWithSortedKeys["variants"].sort((variantA, variantB) => {
    const languageComparison = variantA.languageTag.localeCompare(variantB.languageTag);
    if (languageComparison === 0) {
      return variantA.match.join("-").localeCompare(variantB.match.join("-"));
    }
    return languageComparison;
  });
  return JSON.stringify(messageWithSortedKeys, void 0, 4);
}
var murmurHash3js = { exports: {} };
(function(module, exports2) {
  (function(root, undefined$1) {
    var library = {
      "version": "3.0.1",
      "x86": {},
      "x64": {}
    };
    function _x86Multiply(m, n) {
      return (m & 65535) * n + (((m >>> 16) * n & 65535) << 16);
    }
    function _x86Rotl(m, n) {
      return m << n | m >>> 32 - n;
    }
    function _x86Fmix(h) {
      h ^= h >>> 16;
      h = _x86Multiply(h, 2246822507);
      h ^= h >>> 13;
      h = _x86Multiply(h, 3266489909);
      h ^= h >>> 16;
      return h;
    }
    function _x64Add(m, n) {
      m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
      n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
      var o = [0, 0, 0, 0];
      o[3] += m[3] + n[3];
      o[2] += o[3] >>> 16;
      o[3] &= 65535;
      o[2] += m[2] + n[2];
      o[1] += o[2] >>> 16;
      o[2] &= 65535;
      o[1] += m[1] + n[1];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[0] += m[0] + n[0];
      o[0] &= 65535;
      return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
    }
    function _x64Multiply(m, n) {
      m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
      n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
      var o = [0, 0, 0, 0];
      o[3] += m[3] * n[3];
      o[2] += o[3] >>> 16;
      o[3] &= 65535;
      o[2] += m[2] * n[3];
      o[1] += o[2] >>> 16;
      o[2] &= 65535;
      o[2] += m[3] * n[2];
      o[1] += o[2] >>> 16;
      o[2] &= 65535;
      o[1] += m[1] * n[3];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[1] += m[2] * n[2];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[1] += m[3] * n[1];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[0] += m[0] * n[3] + m[1] * n[2] + m[2] * n[1] + m[3] * n[0];
      o[0] &= 65535;
      return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
    }
    function _x64Rotl(m, n) {
      n %= 64;
      if (n === 32) {
        return [m[1], m[0]];
      } else if (n < 32) {
        return [m[0] << n | m[1] >>> 32 - n, m[1] << n | m[0] >>> 32 - n];
      } else {
        n -= 32;
        return [m[1] << n | m[0] >>> 32 - n, m[0] << n | m[1] >>> 32 - n];
      }
    }
    function _x64LeftShift(m, n) {
      n %= 64;
      if (n === 0) {
        return m;
      } else if (n < 32) {
        return [m[0] << n | m[1] >>> 32 - n, m[1] << n];
      } else {
        return [m[1] << n - 32, 0];
      }
    }
    function _x64Xor(m, n) {
      return [m[0] ^ n[0], m[1] ^ n[1]];
    }
    function _x64Fmix(h) {
      h = _x64Xor(h, [0, h[0] >>> 1]);
      h = _x64Multiply(h, [4283543511, 3981806797]);
      h = _x64Xor(h, [0, h[0] >>> 1]);
      h = _x64Multiply(h, [3301882366, 444984403]);
      h = _x64Xor(h, [0, h[0] >>> 1]);
      return h;
    }
    library.x86.hash32 = function(key, seed) {
      key = key || "";
      seed = seed || 0;
      var remainder = key.length % 4;
      var bytes = key.length - remainder;
      var h1 = seed;
      var k1 = 0;
      var c1 = 3432918353;
      var c2 = 461845907;
      for (var i2 = 0; i2 < bytes; i2 = i2 + 4) {
        k1 = key.charCodeAt(i2) & 255 | (key.charCodeAt(i2 + 1) & 255) << 8 | (key.charCodeAt(i2 + 2) & 255) << 16 | (key.charCodeAt(i2 + 3) & 255) << 24;
        k1 = _x86Multiply(k1, c1);
        k1 = _x86Rotl(k1, 15);
        k1 = _x86Multiply(k1, c2);
        h1 ^= k1;
        h1 = _x86Rotl(h1, 13);
        h1 = _x86Multiply(h1, 5) + 3864292196;
      }
      k1 = 0;
      switch (remainder) {
        case 3:
          k1 ^= (key.charCodeAt(i2 + 2) & 255) << 16;
        case 2:
          k1 ^= (key.charCodeAt(i2 + 1) & 255) << 8;
        case 1:
          k1 ^= key.charCodeAt(i2) & 255;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
      }
      h1 ^= key.length;
      h1 = _x86Fmix(h1);
      return h1 >>> 0;
    };
    library.x86.hash128 = function(key, seed) {
      key = key || "";
      seed = seed || 0;
      var remainder = key.length % 16;
      var bytes = key.length - remainder;
      var h1 = seed;
      var h2 = seed;
      var h3 = seed;
      var h4 = seed;
      var k1 = 0;
      var k2 = 0;
      var k3 = 0;
      var k4 = 0;
      var c1 = 597399067;
      var c2 = 2869860233;
      var c3 = 951274213;
      var c4 = 2716044179;
      for (var i2 = 0; i2 < bytes; i2 = i2 + 16) {
        k1 = key.charCodeAt(i2) & 255 | (key.charCodeAt(i2 + 1) & 255) << 8 | (key.charCodeAt(i2 + 2) & 255) << 16 | (key.charCodeAt(i2 + 3) & 255) << 24;
        k2 = key.charCodeAt(i2 + 4) & 255 | (key.charCodeAt(i2 + 5) & 255) << 8 | (key.charCodeAt(i2 + 6) & 255) << 16 | (key.charCodeAt(i2 + 7) & 255) << 24;
        k3 = key.charCodeAt(i2 + 8) & 255 | (key.charCodeAt(i2 + 9) & 255) << 8 | (key.charCodeAt(i2 + 10) & 255) << 16 | (key.charCodeAt(i2 + 11) & 255) << 24;
        k4 = key.charCodeAt(i2 + 12) & 255 | (key.charCodeAt(i2 + 13) & 255) << 8 | (key.charCodeAt(i2 + 14) & 255) << 16 | (key.charCodeAt(i2 + 15) & 255) << 24;
        k1 = _x86Multiply(k1, c1);
        k1 = _x86Rotl(k1, 15);
        k1 = _x86Multiply(k1, c2);
        h1 ^= k1;
        h1 = _x86Rotl(h1, 19);
        h1 += h2;
        h1 = _x86Multiply(h1, 5) + 1444728091;
        k2 = _x86Multiply(k2, c2);
        k2 = _x86Rotl(k2, 16);
        k2 = _x86Multiply(k2, c3);
        h2 ^= k2;
        h2 = _x86Rotl(h2, 17);
        h2 += h3;
        h2 = _x86Multiply(h2, 5) + 197830471;
        k3 = _x86Multiply(k3, c3);
        k3 = _x86Rotl(k3, 17);
        k3 = _x86Multiply(k3, c4);
        h3 ^= k3;
        h3 = _x86Rotl(h3, 15);
        h3 += h4;
        h3 = _x86Multiply(h3, 5) + 2530024501;
        k4 = _x86Multiply(k4, c4);
        k4 = _x86Rotl(k4, 18);
        k4 = _x86Multiply(k4, c1);
        h4 ^= k4;
        h4 = _x86Rotl(h4, 13);
        h4 += h1;
        h4 = _x86Multiply(h4, 5) + 850148119;
      }
      k1 = 0;
      k2 = 0;
      k3 = 0;
      k4 = 0;
      switch (remainder) {
        case 15:
          k4 ^= key.charCodeAt(i2 + 14) << 16;
        case 14:
          k4 ^= key.charCodeAt(i2 + 13) << 8;
        case 13:
          k4 ^= key.charCodeAt(i2 + 12);
          k4 = _x86Multiply(k4, c4);
          k4 = _x86Rotl(k4, 18);
          k4 = _x86Multiply(k4, c1);
          h4 ^= k4;
        case 12:
          k3 ^= key.charCodeAt(i2 + 11) << 24;
        case 11:
          k3 ^= key.charCodeAt(i2 + 10) << 16;
        case 10:
          k3 ^= key.charCodeAt(i2 + 9) << 8;
        case 9:
          k3 ^= key.charCodeAt(i2 + 8);
          k3 = _x86Multiply(k3, c3);
          k3 = _x86Rotl(k3, 17);
          k3 = _x86Multiply(k3, c4);
          h3 ^= k3;
        case 8:
          k2 ^= key.charCodeAt(i2 + 7) << 24;
        case 7:
          k2 ^= key.charCodeAt(i2 + 6) << 16;
        case 6:
          k2 ^= key.charCodeAt(i2 + 5) << 8;
        case 5:
          k2 ^= key.charCodeAt(i2 + 4);
          k2 = _x86Multiply(k2, c2);
          k2 = _x86Rotl(k2, 16);
          k2 = _x86Multiply(k2, c3);
          h2 ^= k2;
        case 4:
          k1 ^= key.charCodeAt(i2 + 3) << 24;
        case 3:
          k1 ^= key.charCodeAt(i2 + 2) << 16;
        case 2:
          k1 ^= key.charCodeAt(i2 + 1) << 8;
        case 1:
          k1 ^= key.charCodeAt(i2);
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
      }
      h1 ^= key.length;
      h2 ^= key.length;
      h3 ^= key.length;
      h4 ^= key.length;
      h1 += h2;
      h1 += h3;
      h1 += h4;
      h2 += h1;
      h3 += h1;
      h4 += h1;
      h1 = _x86Fmix(h1);
      h2 = _x86Fmix(h2);
      h3 = _x86Fmix(h3);
      h4 = _x86Fmix(h4);
      h1 += h2;
      h1 += h3;
      h1 += h4;
      h2 += h1;
      h3 += h1;
      h4 += h1;
      return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h2 >>> 0).toString(16)).slice(-8) + ("00000000" + (h3 >>> 0).toString(16)).slice(-8) + ("00000000" + (h4 >>> 0).toString(16)).slice(-8);
    };
    library.x64.hash128 = function(key, seed) {
      key = key || "";
      seed = seed || 0;
      var remainder = key.length % 16;
      var bytes = key.length - remainder;
      var h1 = [0, seed];
      var h2 = [0, seed];
      var k1 = [0, 0];
      var k2 = [0, 0];
      var c1 = [2277735313, 289559509];
      var c2 = [1291169091, 658871167];
      for (var i2 = 0; i2 < bytes; i2 = i2 + 16) {
        k1 = [key.charCodeAt(i2 + 4) & 255 | (key.charCodeAt(i2 + 5) & 255) << 8 | (key.charCodeAt(i2 + 6) & 255) << 16 | (key.charCodeAt(i2 + 7) & 255) << 24, key.charCodeAt(i2) & 255 | (key.charCodeAt(i2 + 1) & 255) << 8 | (key.charCodeAt(i2 + 2) & 255) << 16 | (key.charCodeAt(i2 + 3) & 255) << 24];
        k2 = [key.charCodeAt(i2 + 12) & 255 | (key.charCodeAt(i2 + 13) & 255) << 8 | (key.charCodeAt(i2 + 14) & 255) << 16 | (key.charCodeAt(i2 + 15) & 255) << 24, key.charCodeAt(i2 + 8) & 255 | (key.charCodeAt(i2 + 9) & 255) << 8 | (key.charCodeAt(i2 + 10) & 255) << 16 | (key.charCodeAt(i2 + 11) & 255) << 24];
        k1 = _x64Multiply(k1, c1);
        k1 = _x64Rotl(k1, 31);
        k1 = _x64Multiply(k1, c2);
        h1 = _x64Xor(h1, k1);
        h1 = _x64Rotl(h1, 27);
        h1 = _x64Add(h1, h2);
        h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 1390208809]);
        k2 = _x64Multiply(k2, c2);
        k2 = _x64Rotl(k2, 33);
        k2 = _x64Multiply(k2, c1);
        h2 = _x64Xor(h2, k2);
        h2 = _x64Rotl(h2, 31);
        h2 = _x64Add(h2, h1);
        h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 944331445]);
      }
      k1 = [0, 0];
      k2 = [0, 0];
      switch (remainder) {
        case 15:
          k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i2 + 14)], 48));
        case 14:
          k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i2 + 13)], 40));
        case 13:
          k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i2 + 12)], 32));
        case 12:
          k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i2 + 11)], 24));
        case 11:
          k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i2 + 10)], 16));
        case 10:
          k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i2 + 9)], 8));
        case 9:
          k2 = _x64Xor(k2, [0, key.charCodeAt(i2 + 8)]);
          k2 = _x64Multiply(k2, c2);
          k2 = _x64Rotl(k2, 33);
          k2 = _x64Multiply(k2, c1);
          h2 = _x64Xor(h2, k2);
        case 8:
          k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i2 + 7)], 56));
        case 7:
          k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i2 + 6)], 48));
        case 6:
          k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i2 + 5)], 40));
        case 5:
          k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i2 + 4)], 32));
        case 4:
          k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i2 + 3)], 24));
        case 3:
          k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i2 + 2)], 16));
        case 2:
          k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i2 + 1)], 8));
        case 1:
          k1 = _x64Xor(k1, [0, key.charCodeAt(i2)]);
          k1 = _x64Multiply(k1, c1);
          k1 = _x64Rotl(k1, 31);
          k1 = _x64Multiply(k1, c2);
          h1 = _x64Xor(h1, k1);
      }
      h1 = _x64Xor(h1, [0, key.length]);
      h2 = _x64Xor(h2, [0, key.length]);
      h1 = _x64Add(h1, h2);
      h2 = _x64Add(h2, h1);
      h1 = _x64Fmix(h1);
      h2 = _x64Fmix(h2);
      h1 = _x64Add(h1, h2);
      h2 = _x64Add(h2, h1);
      return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[1] >>> 0).toString(16)).slice(-8);
    };
    {
      if (module.exports) {
        exports2 = module.exports = library;
      }
      exports2.murmurHash3 = library;
    }
  })();
})(murmurHash3js, murmurHash3js.exports);
var murmurHash3jsExports = murmurHash3js.exports;
var murmurhash3js = murmurHash3jsExports;
const murmurhash3 = /* @__PURE__ */ getDefaultExportFromCjs(murmurhash3js);
const animals = [
  "albatross",
  "alligator",
  "alpaca",
  "anaconda",
  "angelfish",
  "ant",
  "anteater",
  "antelope",
  "ape",
  "baboon",
  "badger",
  "barbel",
  "bat",
  "bear",
  "beaver",
  "bee",
  "beetle",
  "bird",
  "bison",
  "blackbird",
  "boar",
  "bobcat",
  "bulldog",
  "bullock",
  "bumblebee",
  "butterfly",
  "buzzard",
  "camel",
  "canary",
  "capybara",
  "carp",
  "cat",
  "cheetah",
  "chicken",
  "chipmunk",
  "clownfish",
  "cobra",
  "cockroach",
  "cod",
  "cougar",
  "cow",
  "cowfish",
  "coyote",
  "crab",
  "crocodile",
  "crossbill",
  "crow",
  "cuckoo",
  "dachshund",
  "deer",
  "dingo",
  "dog",
  "dolphin",
  "donkey",
  "dove",
  "dragonfly",
  "duck",
  "eagle",
  "earthworm",
  "eel",
  "elephant",
  "elk",
  "emu",
  "falcon",
  "felix",
  "finch",
  "fireant",
  "firefox",
  "fish",
  "flamingo",
  "flea",
  "florian",
  "fly",
  "fox",
  "frog",
  "gadfly",
  "gazelle",
  "gecko",
  "gibbon",
  "giraffe",
  "goat",
  "goldfish",
  "goose",
  "gopher",
  "gorilla",
  "grebe",
  "grizzly",
  "gull",
  "guppy",
  "haddock",
  "halibut",
  "hamster",
  "hare",
  "hawk",
  "hedgehog",
  "herring",
  "hornet",
  "horse",
  "hound",
  "husky",
  "hyena",
  "ibex",
  "iguana",
  "impala",
  "insect",
  "jackal",
  "jackdaw",
  "jaguar",
  "jan",
  "jannes",
  "javelina",
  "jay",
  "jellyfish",
  "jurgen",
  "kangaroo",
  "kestrel",
  "kitten",
  "koala",
  "kudu",
  "ladybug",
  "lamb",
  "lark",
  "larva",
  "lemming",
  "lemur",
  "leopard",
  "liger",
  "lion",
  "lionfish",
  "lizard",
  "llama",
  "lobster",
  "loris",
  "lynx",
  "macaw",
  "maggot",
  "mallard",
  "mammoth",
  "manatee",
  "mantis",
  "mare",
  "marlin",
  "marmot",
  "marten",
  "martin",
  "mayfly",
  "meerkat",
  "midge",
  "millipede",
  "mink",
  "mole",
  "mongoose",
  "monkey",
  "moose",
  "moth",
  "mouse",
  "mule",
  "myna",
  "newt",
  "niklas",
  "nils",
  "nuthatch",
  "ocelot",
  "octopus",
  "okapi",
  "opossum",
  "orangutan",
  "oryx",
  "osprey",
  "ostrich",
  "otter",
  "owl",
  "ox",
  "panda",
  "panther",
  "parakeet",
  "parrot",
  "peacock",
  "pelican",
  "penguin",
  "pig",
  "pigeon",
  "piranha",
  "platypus",
  "polecat",
  "pony",
  "poodle",
  "porpoise",
  "puffin",
  "pug",
  "puma",
  "quail",
  "rabbit",
  "racoon",
  "rat",
  "raven",
  "ray",
  "reindeer",
  "robin",
  "rook",
  "rooster",
  "salmon",
  "samuel",
  "sawfish",
  "scallop",
  "seahorse",
  "seal",
  "shad",
  "shark",
  "sheep",
  "shell",
  "shrike",
  "shrimp",
  "skate",
  "skunk",
  "sloth",
  "slug",
  "snail",
  "snake",
  "sparrow",
  "spider",
  "squid",
  "squirrel",
  "starfish",
  "stingray",
  "stork",
  "swallow",
  "swan",
  "tadpole",
  "tapir",
  "termite",
  "tern",
  "thrush",
  "tiger",
  "toad",
  "tortoise",
  "toucan",
  "trout",
  "tuna",
  "turkey",
  "turtle",
  "vole",
  "vulture",
  "wallaby",
  "walrus",
  "warbler",
  "warthog",
  "wasp",
  "weasel",
  "whale",
  "wolf",
  "wombat",
  "worm",
  "wren",
  "yak",
  "zebra"
];
const adjectives = [
  "acidic",
  "active",
  "actual",
  "agent",
  "ago",
  "alert",
  "alive",
  "aloof",
  "antsy",
  "any",
  "aqua",
  "arable",
  "awake",
  "aware",
  "away",
  "awful",
  "bad",
  "bald",
  "basic",
  "best",
  "big",
  "bland",
  "blue",
  "bold",
  "born",
  "brave",
  "brief",
  "bright",
  "broad",
  "busy",
  "calm",
  "candid",
  "careful",
  "caring",
  "chunky",
  "civil",
  "clean",
  "clear",
  "close",
  "cool",
  "cozy",
  "crazy",
  "crisp",
  "cuddly",
  "curly",
  "cute",
  "dark",
  "day",
  "deft",
  "direct",
  "dirty",
  "dizzy",
  "drab",
  "dry",
  "due",
  "dull",
  "each",
  "early",
  "east",
  "elegant",
  "empty",
  "equal",
  "even",
  "every",
  "extra",
  "factual",
  "fair",
  "fancy",
  "few",
  "fine",
  "fit",
  "flaky",
  "flat",
  "fluffy",
  "formal",
  "frail",
  "free",
  "fresh",
  "front",
  "full",
  "fun",
  "funny",
  "fuzzy",
  "game",
  "gaudy",
  "giant",
  "glad",
  "good",
  "grand",
  "grassy",
  "gray",
  "great",
  "green",
  "gross",
  "happy",
  "heavy",
  "helpful",
  "heroic",
  "home",
  "honest",
  "hour",
  "house",
  "icy",
  "ideal",
  "inclusive",
  "inner",
  "jolly",
  "jumpy",
  "just",
  "keen",
  "key",
  "kind",
  "knotty",
  "known",
  "large",
  "last",
  "late",
  "lazy",
  "least",
  "left",
  "legal",
  "less",
  "level",
  "light",
  "lime",
  "livid",
  "lofty",
  "long",
  "loose",
  "lost",
  "loud",
  "loved",
  "low",
  "lower",
  "lucky",
  "mad",
  "main",
  "major",
  "male",
  "many",
  "maroon",
  "mealy",
  "mean",
  "mellow",
  "merry",
  "mild",
  "minor",
  "misty",
  "moving",
  "muddy",
  "mushy",
  "neat",
  "new",
  "next",
  "nice",
  "nimble",
  "noble",
  "noisy",
  "north",
  "novel",
  "odd",
  "ok",
  "only",
  "orange",
  "ornate",
  "patchy",
  "patient",
  "petty",
  "pink",
  "plain",
  "plane",
  "polite",
  "pretty",
  "proof",
  "proud",
  "quaint",
  "quick",
  "quiet",
  "raw",
  "real",
  "red",
  "round",
  "royal",
  "sad",
  "safe",
  "salty",
  "same",
  "sea",
  "seemly",
  "sharp",
  "short",
  "shy",
  "silly",
  "simple",
  "sleek",
  "slimy",
  "slow",
  "small",
  "smart",
  "smug",
  "soft",
  "solid",
  "sound",
  "sour",
  "spare",
  "spicy",
  "spry",
  "stale",
  "steep",
  "still",
  "stock",
  "stout",
  "strong",
  "suave",
  "such",
  "sunny",
  "super",
  "sweet",
  "swift",
  "tame",
  "tangy",
  "tasty",
  "teal",
  "teary",
  "tense",
  "that",
  "these",
  "this",
  "tidy",
  "tiny",
  "tired",
  "top",
  "topical",
  "tough",
  "trick",
  "trite",
  "true",
  "upper",
  "vexed",
  "vivid",
  "wacky",
  "warm",
  "watery",
  "weak",
  "weary",
  "weird",
  "white",
  "whole",
  "wide",
  "wild",
  "wise",
  "witty",
  "yummy",
  "zany",
  "zesty",
  "zippy"
];
const adverbs = [
  "ablaze",
  "about",
  "above",
  "abroad",
  "across",
  "adrift",
  "afloat",
  "after",
  "again",
  "ahead",
  "alike",
  "all",
  "almost",
  "alone",
  "along",
  "aloud",
  "always",
  "amazing",
  "anxious",
  "anywhere",
  "apart",
  "around",
  "arrogant",
  "aside",
  "asleep",
  "awkward",
  "back",
  "bashful",
  "beautiful",
  "before",
  "behind",
  "below",
  "beside",
  "besides",
  "beyond",
  "bitter",
  "bleak",
  "blissful",
  "boldly",
  "bravely",
  "briefly",
  "brightly",
  "brisk",
  "busily",
  "calmly",
  "carefully",
  "careless",
  "cautious",
  "certain",
  "cheerful",
  "clearly",
  "clever",
  "closely",
  "closer",
  "colorful",
  "common",
  "correct",
  "cross",
  "cruel",
  "curious",
  "daily",
  "dainty",
  "daring",
  "dear",
  "desperate",
  "diligent",
  "doubtful",
  "doubtless",
  "down",
  "downwards",
  "dreamily",
  "eager",
  "easily",
  "either",
  "elegantly",
  "else",
  "elsewhere",
  "enormous",
  "enough",
  "ever",
  "famous",
  "far",
  "fast",
  "fervent",
  "fierce",
  "fondly",
  "foolish",
  "forever",
  "forth",
  "fortunate",
  "forward",
  "frank",
  "freely",
  "frequent",
  "fully",
  "general",
  "generous",
  "gladly",
  "graceful",
  "grateful",
  "gratis",
  "half",
  "happily",
  "hard",
  "harsh",
  "hearty",
  "helpless",
  "here",
  "highly",
  "hitherto",
  "how",
  "however",
  "hurried",
  "immediate",
  "in",
  "indeed",
  "inland",
  "innocent",
  "inside",
  "instant",
  "intense",
  "inward",
  "jealous",
  "jovial",
  "joyful",
  "jubilant",
  "keenly",
  "kindly",
  "knowing",
  "lately",
  "lazily",
  "lightly",
  "likely",
  "little",
  "live",
  "loftily",
  "longing",
  "loosely",
  "loudly",
  "loving",
  "loyal",
  "luckily",
  "madly",
  "maybe",
  "meanwhile",
  "mocking",
  "monthly",
  "moreover",
  "much",
  "near",
  "neatly",
  "neither",
  "nervous",
  "never",
  "noisily",
  "normal",
  "not",
  "now",
  "nowadays",
  "nowhere",
  "oddly",
  "off",
  "official",
  "often",
  "on",
  "once",
  "open",
  "openly",
  "opposite",
  "otherwise",
  "out",
  "outside",
  "over",
  "overall",
  "overhead",
  "overnight",
  "overseas",
  "parallel",
  "partial",
  "past",
  "patiently",
  "perfect",
  "perhaps",
  "physical",
  "playful",
  "politely",
  "potential",
  "powerful",
  "presto",
  "profound",
  "prompt",
  "proper",
  "proudly",
  "punctual",
  "quickly",
  "quizzical",
  "rare",
  "ravenous",
  "ready",
  "really",
  "reckless",
  "regular",
  "repeated",
  "restful",
  "rightful",
  "rigid",
  "rude",
  "sadly",
  "safely",
  "scarce",
  "scary",
  "searching",
  "seeming",
  "seldom",
  "selfish",
  "separate",
  "serious",
  "shaky",
  "sheepish",
  "silent",
  "sleepy",
  "smooth",
  "softly",
  "solemn",
  "solidly",
  "sometimes",
  "speedy",
  "stealthy",
  "stern",
  "strict",
  "stubborn",
  "sudden",
  "supposed",
  "sweetly",
  "swiftly",
  "tender",
  "tensely",
  "thankful",
  "tight",
  "too",
  "twice",
  "under",
  "untrue",
  "uphill",
  "upward",
  "vaguely",
  "vainly",
  "vastly",
  "warmly",
  "wearily",
  "weekly",
  "well",
  "wisely",
  "within",
  "wrongly",
  "yonder"
];
const verbs = [
  "absorb",
  "accept",
  "achieve",
  "adapt",
  "adore",
  "advise",
  "affirm",
  "agree",
  "aid",
  "aim",
  "amaze",
  "amuse",
  "animate",
  "approve",
  "arise",
  "arrive",
  "ascend",
  "ask",
  "aspire",
  "assure",
  "attend",
  "bake",
  "bask",
  "beam",
  "believe",
  "belong",
  "bend",
  "blend",
  "bless",
  "blink",
  "bloom",
  "boil",
  "boost",
  "borrow",
  "breathe",
  "bubble",
  "build",
  "bump",
  "burn",
  "buy",
  "buzz",
  "care",
  "catch",
  "charm",
  "cheer",
  "cherish",
  "chop",
  "clap",
  "clasp",
  "climb",
  "clip",
  "coax",
  "comfort",
  "commend",
  "compose",
  "conquer",
  "cook",
  "create",
  "cry",
  "cuddle",
  "cure",
  "cut",
  "dance",
  "dare",
  "dart",
  "dash",
  "dazzle",
  "delight",
  "devour",
  "dial",
  "dig",
  "dine",
  "dream",
  "drip",
  "drop",
  "drum",
  "dust",
  "earn",
  "edit",
  "embrace",
  "emerge",
  "empower",
  "enchant",
  "endure",
  "engage",
  "enjoy",
  "enrich",
  "evoke",
  "exhale",
  "expand",
  "explore",
  "express",
  "fade",
  "fall",
  "favor",
  "fear",
  "feast",
  "feel",
  "fetch",
  "file",
  "find",
  "flip",
  "flop",
  "flow",
  "fold",
  "fond",
  "forgive",
  "foster",
  "fry",
  "fulfill",
  "gasp",
  "gaze",
  "gleam",
  "glow",
  "grace",
  "grasp",
  "greet",
  "grin",
  "grip",
  "grow",
  "gulp",
  "hack",
  "harbor",
  "heal",
  "heart",
  "hike",
  "hint",
  "honor",
  "hope",
  "hug",
  "hunt",
  "hurl",
  "hush",
  "imagine",
  "inspire",
  "intend",
  "jest",
  "jolt",
  "jump",
  "kick",
  "kiss",
  "laugh",
  "launch",
  "lead",
  "leap",
  "learn",
  "lend",
  "lift",
  "link",
  "list",
  "lock",
  "loop",
  "love",
  "mend",
  "mix",
  "mop",
  "nail",
  "nourish",
  "nudge",
  "nurture",
  "offer",
  "pat",
  "pause",
  "pave",
  "peek",
  "peel",
  "persist",
  "pet",
  "pick",
  "pinch",
  "play",
  "pop",
  "pout",
  "praise",
  "pray",
  "pride",
  "promise",
  "propel",
  "prosper",
  "pull",
  "push",
  "quell",
  "quiz",
  "race",
  "radiate",
  "read",
  "reap",
  "relish",
  "renew",
  "reside",
  "rest",
  "revive",
  "ripple",
  "rise",
  "roam",
  "roar",
  "rush",
  "sail",
  "savor",
  "scold",
  "scoop",
  "seek",
  "sew",
  "shine",
  "sing",
  "skip",
  "slide",
  "slurp",
  "smile",
  "snap",
  "snip",
  "soar",
  "spark",
  "spin",
  "splash",
  "sprout",
  "spur",
  "stab",
  "startle",
  "stir",
  "stop",
  "strive",
  "succeed",
  "support",
  "surge",
  "sway",
  "swim",
  "talk",
  "tap",
  "taste",
  "tear",
  "tend",
  "thrive",
  "tickle",
  "transform",
  "treasure",
  "treat",
  "trim",
  "trip",
  "trust",
  "twirl",
  "twist",
  "type",
  "urge",
  "value",
  "vent",
  "view",
  "walk",
  "wave",
  "win",
  "wish",
  "work",
  "yell",
  "zap",
  "zip",
  "zoom"
];
function humanIdHash(value2, offset = 0) {
  const seed = 42;
  const hash32 = murmurhash3.x86.hash32(value2, seed);
  const hash32WithOffset = hash32 + offset >>> 0;
  const part1 = hash32WithOffset >>> 24 & 255;
  const part2 = hash32WithOffset >>> 16 & 255;
  const part3 = hash32WithOffset >>> 8 & 255;
  const part4 = hash32WithOffset & 255;
  return `${adjectives[part1]}_${animals[part2]}_${verbs[part3]}_${adverbs[part4]}`;
}
const createNodeishFsWithWatcher = (args) => {
  const pathList = [];
  const makeWatcher = (path2) => {
    const abortController = new AbortController();
    (async () => {
      try {
        const watcher = args.nodeishFs.watch(path2, {
          signal: abortController.signal,
          persistent: false
        });
        if (watcher) {
          for await (const event of watcher) {
            args.updateMessages();
          }
        }
      } catch (err) {
        if (err.name === "AbortError")
          return;
        else if (err.code === "ENOENT")
          return;
        throw err;
      }
    })();
  };
  const readFileAndExtractPath = (path2, options) => {
    if (!pathList.includes(path2)) {
      makeWatcher(path2);
      pathList.push(path2);
    }
    return args.nodeishFs.readFile(path2, options);
  };
  return {
    // @ts-expect-error
    readFile: (path2, options) => readFileAndExtractPath(path2, options),
    rm: args.nodeishFs.rm,
    readdir: args.nodeishFs.readdir,
    mkdir: args.nodeishFs.mkdir,
    rmdir: args.nodeishFs.rmdir,
    writeFile: args.nodeishFs.writeFile,
    watch: args.nodeishFs.watch,
    stat: args.nodeishFs.stat
  };
};
async function hash(inputStr) {
  var _a;
  let usedCrypto;
  if (typeof crypto === "undefined" && typeof process !== "undefined" && ((_a = process == null ? void 0 : process.versions) == null ? void 0 : _a.node)) {
    const modName = "crypto";
    usedCrypto = await import(`node:${modName}`);
  } else if (typeof crypto !== "undefined") {
    usedCrypto = crypto;
  }
  if (!usedCrypto) {
    throw new Error("Could not find crypto features in runtime");
  }
  const idDigest = await usedCrypto.subtle.digest("SHA-256", new TextEncoder().encode(inputStr));
  return [...new Uint8Array(idDigest)].map((b) => ("00" + b.toString(16)).slice(-2)).join("");
}
async function maybeCreateFirstProjectId(args) {
  if (args.repo === void 0) {
    return;
  }
  try {
    await args.repo.nodeishFs.readFile(args.projectPath + "/project_id", {
      encoding: "utf-8"
    });
  } catch (error) {
    if (error.code === "ENOENT" && args.repo) {
      const projectId = await generateProjectId({ repo: args.repo, projectPath: args.projectPath });
      if (projectId) {
        await args.repo.nodeishFs.writeFile(args.projectPath + "/project_id", projectId).catch((error2) => {
          console.error("Failed to write project_id", error2);
        });
      }
    }
  }
}
async function generateProjectId(args) {
  if (!args.repo || !args.projectPath) {
    return void 0;
  }
  const firstCommitHash = await args.repo.getFirstCommitHash();
  if (firstCommitHash) {
    try {
      return await hash(`${firstCommitHash + args.projectPath}`);
    } catch (error) {
      console.error("Failed to generate project_id", error);
    }
  }
  return void 0;
}
const ENV_VARIABLES = {
  PUBLIC_POSTHOG_TOKEN: "phc_m5yJZCxjOGxF8CJvP5sQ3H0d76xpnLrsmiZHduT4jDz"
};
const capture$1 = async (event, args) => {
  try {
    await fetch("https://eu.posthog.com/capture/", {
      method: "POST",
      body: JSON.stringify({
        api_key: ENV_VARIABLES.PUBLIC_POSTHOG_TOKEN,
        event,
        // id is "unknown" because no user information is available
        distinct_id: "unknown",
        properties: {
          $groups: { project: args.projectId },
          ...args.properties
        }
      })
    });
  } catch (e) {
  }
};
const identifyProject = async (args) => {
  try {
    await fetch("https://eu.posthog.com/capture/", {
      method: "POST",
      body: JSON.stringify({
        api_key: ENV_VARIABLES.PUBLIC_POSTHOG_TOKEN,
        event: "$groupidentify",
        // id is "unknown" because no user information is available
        distinct_id: "unknown",
        properties: {
          $group_type: "project",
          $group_key: args.projectId,
          $group_set: {
            ...args.properties
          }
        }
      })
    });
  } catch (e) {
  }
};
const debug = _debug$1("loadProject");
const settingsCompiler = compiler$1.TypeCompiler.Compile(ProjectSettings);
async function loadProject(args) {
  const projectPath = normalizePath(args.projectPath);
  const messageStates = {
    messageDirtyFlags: {},
    messageLoadHash: {},
    isSaving: false,
    currentSaveMessagesViaPlugin: void 0,
    sheduledSaveMessages: void 0,
    isLoading: false,
    sheduledLoadMessagesViaPlugin: void 0
  };
  assertValidProjectPath(projectPath);
  const nodeishFs = createNodeishFsWithAbsolutePaths({
    projectPath,
    nodeishFs: args.repo.nodeishFs
  });
  await maybeMigrateToDirectory({ nodeishFs, projectPath });
  await maybeCreateFirstProjectId({ projectPath, repo: args.repo });
  return await createRoot(async () => {
    const { data: projectId } = await tryCatch(() => nodeishFs.readFile(args.projectPath + "/project_id", { encoding: "utf-8" }));
    const [initialized, markInitAsComplete, markInitAsFailed] = createAwaitable();
    const [settings, _setSettings] = createSignal();
    createEffect(() => {
      loadSettings({ settingsFilePath: projectPath + "/settings.json", nodeishFs }).then((settings2) => setSettings(settings2)).catch((err) => {
        markInitAsFailed(err);
      });
    });
    const writeSettingsToDisk = skipFirst((settings2) => _writeSettingsToDisk({ nodeishFs, settings: settings2, projectPath }));
    const setSettings = (settings2) => {
      try {
        const validatedSettings = parseSettings(settings2);
        _setSettings(validatedSettings);
        writeSettingsToDisk(validatedSettings);
        return { data: void 0 };
      } catch (error) {
        if (error instanceof ProjectSettingsInvalidError) {
          return { error };
        }
        throw new Error("Unhandled error in setSettings. This is an internal bug. Please file an issue.");
      }
    };
    const [resolvedModules, setResolvedModules] = createSignal();
    createEffect(() => {
      const _settings = settings();
      if (!_settings)
        return;
      resolveModules({ settings: _settings, nodeishFs, _import: args._import }).then((resolvedModules2) => {
        setResolvedModules(resolvedModules2);
      }).catch((err) => markInitAsFailed(err));
    });
    let settingsValue;
    createEffect(() => settingsValue = settings());
    const [messages, setMessages] = createSignal([]);
    const [loadMessagesViaPluginError, setLoadMessagesViaPluginError] = createSignal();
    const [saveMessagesViaPluginError, setSaveMessagesViaPluginError] = createSignal();
    const messagesQuery = createMessagesQuery(() => messages());
    const messageLockDirPath = projectPath + "/messagelock";
    createEffect(() => {
      const _resolvedModules = resolvedModules();
      if (!_resolvedModules)
        return;
      if (!_resolvedModules.resolvedPluginApi.loadMessages) {
        markInitAsFailed(void 0);
        return;
      }
      const _settings = settings();
      if (!_settings)
        return;
      const loadMessagePlugin = _resolvedModules.plugins.find((plugin) => plugin.loadMessages !== void 0);
      const fsWithWatcher = createNodeishFsWithWatcher({
        nodeishFs,
        // this message is called whenever a file changes that was read earlier by this filesystem
        // - the plugin loads messages -> reads the file messages.json -> start watching on messages.json -> updateMessages
        updateMessages: () => {
          debug("load messages because of a change in the message.json files");
          loadMessagesViaPlugin(
            fsWithWatcher,
            messageLockDirPath,
            messageStates,
            messagesQuery,
            settings(),
            // NOTE we bang here - we don't expect the settings to become null during the livetime of a project
            loadMessagePlugin
          ).catch((e) => setLoadMessagesViaPluginError(new PluginLoadMessagesError({ cause: e }))).then(() => {
            if (loadMessagesViaPluginError() !== void 0) {
              setLoadMessagesViaPluginError(void 0);
            }
          });
        }
      });
      loadMessagesViaPlugin(fsWithWatcher, messageLockDirPath, messageStates, messagesQuery, _settings, loadMessagePlugin).then(() => {
        markInitAsComplete();
      }).catch((err) => {
        markInitAsFailed(new PluginLoadMessagesError({ cause: err }));
      });
    });
    const installedMessageLintRules = () => {
      if (!resolvedModules())
        return [];
      return resolvedModules().messageLintRules.map((rule) => {
        var _a, _b, _c;
        return {
          id: rule.id,
          displayName: rule.displayName,
          description: rule.description,
          module: ((_b = (_a = resolvedModules()) == null ? void 0 : _a.meta.find((m) => m.id.includes(rule.id))) == null ? void 0 : _b.module) ?? "Unknown module. You stumbled on a bug in inlang's source code. Please open an issue.",
          // default to warning, see https://github.com/opral/monorepo/issues/1254
          level: ((_c = settingsValue["messageLintRuleLevels"]) == null ? void 0 : _c[rule.id]) ?? "warning",
          settingsSchema: rule.settingsSchema
        };
      });
    };
    const installedPlugins = () => {
      if (!resolvedModules())
        return [];
      return resolvedModules().plugins.map((plugin) => {
        var _a, _b;
        return {
          id: plugin.id,
          displayName: plugin.displayName,
          description: plugin.description,
          module: ((_b = (_a = resolvedModules()) == null ? void 0 : _a.meta.find((m) => m.id.includes(plugin.id))) == null ? void 0 : _b.module) ?? "Unknown module. You stumbled on a bug in inlang's source code. Please open an issue.",
          settingsSchema: plugin.settingsSchema
        };
      });
    };
    const initializeError = await initialized.catch((error) => error);
    const abortController = new AbortController();
    nodeishFs.watch("/", { signal: abortController.signal }) !== void 0;
    const trackedMessages = /* @__PURE__ */ new Map();
    let initialSetup = true;
    createEffect(() => {
      const _resolvedModules = resolvedModules();
      if (!_resolvedModules)
        return;
      const currentMessageIds = new Set(messagesQuery.includedMessageIds());
      const deletedTrackedMessages = [...trackedMessages].filter((tracked) => !currentMessageIds.has(tracked[0]));
      const saveMessagesPlugin = _resolvedModules.plugins.find((plugin) => plugin.saveMessages !== void 0);
      const loadMessagesPlugin = _resolvedModules.plugins.find((plugin) => plugin.loadMessages !== void 0);
      for (const messageId of currentMessageIds) {
        if (!trackedMessages.has(messageId)) {
          createRoot((dispose) => {
            createEffect(() => {
              const message = messagesQuery.get({ where: { id: messageId } });
              if (!message) {
                return;
              }
              if (!(trackedMessages == null ? void 0 : trackedMessages.has(messageId))) {
                trackedMessages == null ? void 0 : trackedMessages.set(messageId, dispose);
              }
              if (!initialSetup) {
                messageStates.messageDirtyFlags[message.id] = true;
                saveMessagesViaPlugin(nodeishFs, messageLockDirPath, messageStates, messagesQuery, settings(), saveMessagesPlugin, loadMessagesPlugin).catch((e) => setSaveMessagesViaPluginError(new PluginSaveMessagesError({ cause: e }))).then(() => {
                  if (saveMessagesViaPluginError() !== void 0) {
                    setSaveMessagesViaPluginError(void 0);
                  }
                });
              }
            });
          });
        }
      }
      for (const deletedMessage of deletedTrackedMessages) {
        const deletedMessageId = deletedMessage[0];
        const messageEffectDisposeFunction = trackedMessages.get(deletedMessageId);
        if (messageEffectDisposeFunction) {
          messageEffectDisposeFunction();
          trackedMessages.delete(deletedMessageId);
        }
        messageStates.messageDirtyFlags[deletedMessageId] = true;
      }
      if (deletedTrackedMessages.length > 0) {
        saveMessagesViaPlugin(nodeishFs, messageLockDirPath, messageStates, messagesQuery, settings(), saveMessagesPlugin, loadMessagesPlugin).catch((e) => setSaveMessagesViaPluginError(new PluginSaveMessagesError({ cause: e }))).then(() => {
          if (saveMessagesViaPluginError() !== void 0) {
            setSaveMessagesViaPluginError(void 0);
          }
        });
      }
      initialSetup = false;
    });
    const lintReportsQuery = createMessageLintReportsQuery(messagesQuery, settings, installedMessageLintRules, resolvedModules);
    let projectLoadedCapturedAlready = false;
    if (projectId && projectLoadedCapturedAlready === false) {
      projectLoadedCapturedAlready = true;
      await identifyProject({
        projectId,
        properties: {
          // using the id for now as a name but can be changed in the future
          // we need at least one property to make a project visible in the dashboard
          name: projectId
        }
      });
      await capture$1("SDK loaded project", {
        projectId,
        properties: {
          appId: args.appId,
          settings: settings(),
          installedPluginIds: installedPlugins().map((p) => p.id),
          installedMessageLintRuleIds: installedMessageLintRules().map((r) => r.id),
          numberOfMessages: messagesQuery.includedMessageIds().length
        }
      });
    }
    return {
      id: projectId,
      installed: {
        plugins: createSubscribable(() => installedPlugins()),
        messageLintRules: createSubscribable(() => installedMessageLintRules())
      },
      errors: createSubscribable(() => [
        ...initializeError ? [initializeError] : [],
        ...resolvedModules() ? resolvedModules().errors : [],
        ...loadMessagesViaPluginError() ? [loadMessagesViaPluginError()] : [],
        ...saveMessagesViaPluginError() ? [saveMessagesViaPluginError()] : []
        // have a query error exposed
        //...(lintErrors() ?? []),
      ]),
      settings: createSubscribable(() => settings()),
      setSettings,
      customApi: createSubscribable(() => {
        var _a;
        return ((_a = resolvedModules()) == null ? void 0 : _a.resolvedPluginApi.customApi) || {};
      }),
      query: {
        messages: messagesQuery,
        messageLintReports: lintReportsQuery
      }
    };
  });
}
const loadSettings = async (args) => {
  const { data: settingsFile, error: settingsFileError } = await tryCatch(async () => await args.nodeishFs.readFile(args.settingsFilePath, { encoding: "utf-8" }));
  if (settingsFileError)
    throw new ProjectSettingsFileNotFoundError({
      cause: settingsFileError,
      path: args.settingsFilePath
    });
  const json = tryCatch(() => JSON.parse(settingsFile));
  if (json.error) {
    throw new ProjectSettingsFileJSONSyntaxError({
      cause: json.error,
      path: args.settingsFilePath
    });
  }
  return parseSettings(json.data);
};
const parseSettings = (settings) => {
  const withMigration = migrateIfOutdated(settings);
  if (settingsCompiler.Check(withMigration) === false) {
    const typeErrors = [...settingsCompiler.Errors(settings)];
    if (typeErrors.length > 0) {
      throw new ProjectSettingsInvalidError({
        errors: typeErrors
      });
    }
  }
  const { sourceLanguageTag, languageTags } = settings;
  if (!languageTags.includes(sourceLanguageTag)) {
    throw new ProjectSettingsInvalidError({
      errors: [
        {
          message: `The sourceLanguageTag "${sourceLanguageTag}" is not included in the languageTags "${languageTags.join('", "')}". Please add it to the languageTags.`,
          type: compiler$1.ValueErrorType.String,
          schema: ProjectSettings,
          value: sourceLanguageTag,
          path: "sourceLanguageTag"
        }
      ]
    });
  }
  return withMigration;
};
const _writeSettingsToDisk = async (args) => {
  const { data: serializedSettings, error: serializeSettingsError } = tryCatch(() => (
    // TODO: this will probably not match the original formatting
    JSON.stringify(args.settings, void 0, 2)
  ));
  if (serializeSettingsError) {
    throw serializeSettingsError;
  }
  const { error: writeSettingsError } = await tryCatch(async () => args.nodeishFs.writeFile(args.projectPath + "/settings.json", serializedSettings));
  if (writeSettingsError) {
    throw writeSettingsError;
  }
};
const createAwaitable = () => {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return [promise, resolve, reject];
};
const makeTrulyAsync = (fn) => (async () => fn)();
function skipFirst(func) {
  let initial = false;
  return function(...args) {
    if (initial) {
      return func.apply(this, args);
    }
    initial = true;
  };
}
function createSubscribable(signal) {
  return Object.assign(signal, {
    subscribe: (callback) => {
      createEffect(() => {
        callback(signal());
      });
    }
  });
}
async function loadMessagesViaPlugin(fs2, lockDirPath, messageState, messagesQuery, settingsValue, loadPlugin) {
  var _a;
  const experimentalAliases = !!((_a = settingsValue.experimental) == null ? void 0 : _a.aliases);
  if (messageState.isLoading) {
    if (!messageState.sheduledLoadMessagesViaPlugin) {
      messageState.sheduledLoadMessagesViaPlugin = createAwaitable();
    }
    return messageState.sheduledLoadMessagesViaPlugin[0];
  }
  messageState.isLoading = true;
  let lockTime = void 0;
  try {
    lockTime = await acquireFileLock(fs2, lockDirPath, "loadMessage");
    const loadedMessages = await makeTrulyAsync(loadPlugin.loadMessages({
      settings: settingsValue,
      nodeishFs: fs2
    }));
    for (const loadedMessage of loadedMessages) {
      const loadedMessageClone = structuredClone(loadedMessage);
      const currentMessages = messagesQuery.getAll().filter((message) => (experimentalAliases ? message.alias["default"] : message.id) === loadedMessage.id);
      if (currentMessages.length > 1) {
        throw new Error("more than one message with the same id or alias found ");
      } else if (currentMessages.length === 1) {
        loadedMessageClone.alias = {};
        if (experimentalAliases) {
          loadedMessageClone.alias["default"] = loadedMessageClone.id;
          loadedMessageClone.id = currentMessages[0].id;
        }
        const importedEnecoded = stringifyMessage(loadedMessageClone);
        if (messageState.messageLoadHash[loadedMessageClone.id] === importedEnecoded) {
          debug("skipping upsert!");
          continue;
        }
        messagesQuery.update({ where: { id: loadedMessageClone.id }, data: loadedMessageClone });
        delete messageState.messageDirtyFlags[loadedMessageClone.id];
        messageState.messageLoadHash[loadedMessageClone.id] = importedEnecoded;
      } else {
        loadedMessageClone.alias = {};
        if (experimentalAliases) {
          loadedMessageClone.alias["default"] = loadedMessageClone.id;
          let currentOffset = 0;
          let messsageId;
          do {
            messsageId = humanIdHash(loadedMessageClone.id, currentOffset);
            if (messagesQuery.get({ where: { id: messsageId } })) {
              currentOffset += 1;
              messsageId = void 0;
            }
          } while (messsageId === void 0);
          loadedMessageClone.id = messsageId;
        }
        const importedEnecoded = stringifyMessage(loadedMessageClone);
        messagesQuery.create({ data: loadedMessageClone });
        delete messageState.messageDirtyFlags[loadedMessageClone.id];
        messageState.messageLoadHash[loadedMessageClone.id] = importedEnecoded;
      }
    }
    await releaseLock(fs2, lockDirPath, "loadMessage", lockTime);
    lockTime = void 0;
    debug("loadMessagesViaPlugin: " + loadedMessages.length + " Messages processed ");
    messageState.isLoading = false;
  } finally {
    if (lockTime !== void 0) {
      await releaseLock(fs2, lockDirPath, "loadMessage", lockTime);
    }
    messageState.isLoading = false;
  }
  const executingScheduledMessages = messageState.sheduledLoadMessagesViaPlugin;
  if (executingScheduledMessages) {
    messageState.sheduledLoadMessagesViaPlugin = void 0;
    loadMessagesViaPlugin(fs2, lockDirPath, messageState, messagesQuery, settingsValue, loadPlugin).then(() => {
      executingScheduledMessages[1]();
    }).catch((e) => {
      executingScheduledMessages[2](e);
    });
  }
}
async function saveMessagesViaPlugin(fs2, lockDirPath, messageState, messagesQuery, settingsValue, savePlugin, loadPlugin) {
  if (messageState.isSaving) {
    if (!messageState.sheduledSaveMessages) {
      messageState.sheduledSaveMessages = createAwaitable();
    }
    return messageState.sheduledSaveMessages[0];
  }
  messageState.isSaving = true;
  messageState.currentSaveMessagesViaPlugin = async function() {
    var _a;
    const saveMessageHashes = {};
    if (Object.keys(messageState.messageDirtyFlags).length == 0) {
      debug("save was skipped - no messages marked as dirty... build!");
      messageState.isSaving = false;
      return;
    }
    let messageDirtyFlagsBeforeSave;
    let lockTime;
    try {
      lockTime = await acquireFileLock(fs2, lockDirPath, "saveMessage");
      if (Object.keys(messageState.messageDirtyFlags).length == 0) {
        debug("save was skipped - no messages marked as dirty... releasing lock again");
        messageState.isSaving = false;
        return;
      }
      const currentMessages = messagesQuery.getAll();
      const messagesToExport = [];
      for (const message of currentMessages) {
        if (messageState.messageDirtyFlags[message.id]) {
          const importedEnecoded = stringifyMessage(message);
          saveMessageHashes[message.id] = importedEnecoded;
        }
        const fixedExportMessage = { ...message };
        if ((_a = settingsValue.experimental) == null ? void 0 : _a.aliases) {
          fixedExportMessage.id = fixedExportMessage.alias["default"] ?? fixedExportMessage.id;
        }
        messagesToExport.push(fixedExportMessage);
      }
      messageDirtyFlagsBeforeSave = { ...messageState.messageDirtyFlags };
      messageState.messageDirtyFlags = {};
      await savePlugin.saveMessages({
        settings: settingsValue,
        messages: messagesToExport,
        nodeishFs: fs2
      });
      for (const [messageId, messageHash] of Object.entries(saveMessageHashes)) {
        messageState.messageLoadHash[messageId] = messageHash;
      }
      if (lockTime !== void 0) {
        await releaseLock(fs2, lockDirPath, "saveMessage", lockTime);
        lockTime = void 0;
      }
      if (messageState.sheduledLoadMessagesViaPlugin) {
        debug("saveMessagesViaPlugin calling queued loadMessagesViaPlugin to share lock");
        await loadMessagesViaPlugin(fs2, lockDirPath, messageState, messagesQuery, settingsValue, loadPlugin);
      }
      messageState.isSaving = false;
    } catch (err) {
      if (messageDirtyFlagsBeforeSave !== void 0) {
        for (const dirtyMessageId of Object.keys(messageDirtyFlagsBeforeSave)) {
          messageState.messageDirtyFlags[dirtyMessageId] = true;
        }
      }
      if (lockTime !== void 0) {
        await releaseLock(fs2, lockDirPath, "saveMessage", lockTime);
        lockTime = void 0;
      }
      messageState.isSaving = false;
      throw new PluginSaveMessagesError({
        cause: err
      });
    } finally {
      if (lockTime !== void 0) {
        await releaseLock(fs2, lockDirPath, "saveMessage", lockTime);
        lockTime = void 0;
      }
      messageState.isSaving = false;
    }
  }();
  await messageState.currentSaveMessagesViaPlugin;
  if (messageState.sheduledSaveMessages) {
    const executingSheduledSaveMessages = messageState.sheduledSaveMessages;
    messageState.sheduledSaveMessages = void 0;
    saveMessagesViaPlugin(fs2, lockDirPath, messageState, messagesQuery, settingsValue, savePlugin, loadPlugin).then(() => {
      executingSheduledSaveMessages[1]();
    }).catch((e) => {
      executingSheduledSaveMessages[2](e);
    });
  }
}
const maxRetries = 10;
const nProbes = 50;
const probeInterval = 100;
async function acquireFileLock(fs2, lockDirPath, lockOrigin, tryCount = 0) {
  if (tryCount > maxRetries) {
    throw new Error(lockOrigin + " exceeded maximum Retries (5) to acquire lockfile " + tryCount);
  }
  try {
    debug(lockOrigin + " tries to acquire a lockfile Retry Nr.: " + tryCount);
    await fs2.mkdir(lockDirPath);
    const stats = await fs2.stat(lockDirPath);
    debug(lockOrigin + " acquired a lockfile Retry Nr.: " + tryCount);
    return stats.mtimeMs;
  } catch (error) {
    if (error.code !== "EEXIST") {
      throw error;
    }
  }
  let currentLockTime;
  try {
    const stats = await fs2.stat(lockDirPath);
    currentLockTime = stats.mtimeMs;
  } catch (fstatError) {
    if (fstatError.code === "ENOENT") {
      debug(lockOrigin + " tryCount++ lock file seems to be gone :) - lets try again " + tryCount);
      return acquireFileLock(fs2, lockDirPath, lockOrigin, tryCount + 1);
    }
    throw fstatError;
  }
  debug(lockOrigin + " tries to acquire a lockfile  - lock currently in use... starting probe phase " + tryCount);
  return new Promise((resolve, reject) => {
    let probeCounts = 0;
    const scheduleProbationTimeout = () => {
      setTimeout(async () => {
        probeCounts += 1;
        let lockFileStats = void 0;
        try {
          debug(lockOrigin + " tries to acquire a lockfile - check if the lock is free now " + tryCount);
          lockFileStats = await fs2.stat(lockDirPath);
        } catch (fstatError) {
          if (fstatError.code === "ENOENT") {
            debug(lockOrigin + " tryCount++ in Promise - tries to acquire a lockfile - lock file seems to be free now - try to acquire " + tryCount);
            const lock = acquireFileLock(fs2, lockDirPath, lockOrigin, tryCount + 1);
            return resolve(lock);
          }
          return reject(fstatError);
        }
        if (lockFileStats.mtimeMs === currentLockTime) {
          if (probeCounts >= nProbes) {
            debug(lockOrigin + " tries to acquire a lockfile  - lock not free - but stale lets drop it" + tryCount);
            try {
              await fs2.rmdir(lockDirPath);
            } catch (rmLockError) {
              if (rmLockError.code === "ENOENT")
                ;
              return reject(rmLockError);
            }
            try {
              debug(lockOrigin + " tryCount++ same locker - try to acquire again after removing stale lock " + tryCount);
              const lock = await acquireFileLock(fs2, lockDirPath, lockOrigin, tryCount + 1);
              return resolve(lock);
            } catch (lockAquireException) {
              return reject(lockAquireException);
            }
          } else {
            return scheduleProbationTimeout();
          }
        } else {
          try {
            debug(lockOrigin + " tryCount++ different locker - try to acquire again " + tryCount);
            const lock = await acquireFileLock(fs2, lockDirPath, lockOrigin, tryCount + 1);
            return resolve(lock);
          } catch (error) {
            return reject(error);
          }
        }
      }, probeInterval);
    };
    scheduleProbationTimeout();
  });
}
async function releaseLock(fs2, lockDirPath, lockOrigin, lockTime) {
  debug(lockOrigin + " releasing the lock ");
  try {
    const stats = await fs2.stat(lockDirPath);
    if (stats.mtimeMs === lockTime) {
      await fs2.rmdir(lockDirPath);
    }
  } catch (statError) {
    debug(lockOrigin + " couldn't release the lock");
    if (statError.code === "ENOENT") {
      debug(lockOrigin + " WARNING - the lock was released by a different process");
      return;
    }
    debug(statError);
    throw statError;
  }
}
function escapeForTemplateLiteral(text) {
  return text.replace(/\\/g, "\\\\").replace(/`/g, "\\`").replace(/\${/g, "\\${");
}
function escapeForSingleQuoteString(text) {
  return text.replace(/\\/g, "\\\\").replace(/'/g, "\\'");
}
function escapeForDoubleQuoteString(text) {
  return text.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
}
const KEYWORDS = [
  "break",
  "case",
  "catch",
  "class",
  "const",
  "continue",
  "debugger",
  "default",
  "delete",
  "do",
  "else",
  "export",
  "extends",
  "false",
  "finally",
  "for",
  "function",
  "if",
  "import",
  "in",
  "instanceof",
  "new",
  "null",
  "return",
  "super",
  "switch",
  "this",
  "throw",
  "true",
  "try",
  "typeof",
  "var",
  "void",
  "while",
  "with",
  //Strict mode reserved keywords
  "let",
  "static",
  "yield",
  "await",
  //Reserved keywords for future use
  "enum",
  "implements",
  "interface",
  "package",
  "private",
  "protected",
  "public"
];
function isValidJSIdentifier(str) {
  return !KEYWORDS.includes(str) && canBeUsedAsVariableName(str);
}
function canBeUsedAsVariableName(str) {
  if (str.trim() !== str) {
    return false;
  }
  try {
    new Function(str, "var " + str);
  } catch (_) {
    return false;
  }
  return true;
}
const backtick = (str) => `\`${str}\``;
const compilePattern = (pattern2) => {
  let result = "";
  const params = {};
  for (const element of pattern2) {
    switch (element.type) {
      case "Text":
        result += escapeForTemplateLiteral(element.value);
        break;
      case "VariableReference":
        if (isValidJSIdentifier(element.name)) {
          result += "${params." + element.name + "}";
        } else {
          result += "${params['" + escapeForSingleQuoteString(element.name) + "']}";
        }
        params[element.name] = "NonNullable<unknown>";
        break;
      default:
        throw new Error("Unknown pattern element type: " + element);
    }
  }
  return {
    params,
    compiled: backtick(result)
  };
};
const paramsType = (params, isMessagesIndex) => {
  if (Object.keys(params).length === 0) {
    return isMessagesIndex ? "@param {{}} params" : "";
  }
  const fieldTypes = [];
  for (const [name2, type] of Object.entries(params)) {
    if (isValidJSIdentifier(name2)) {
      fieldTypes.push(`${name2}: ${type}`);
    } else {
      fieldTypes.push(`'${escapeForSingleQuoteString(name2)}': ${type}`);
    }
  }
  return `@param {{ ${fieldTypes.join(", ")} }} params`;
};
function toStringUnion(iterable) {
  return [...iterable].map((item) => `"${escapeForDoubleQuoteString(item)}"`).join(" | ");
}
const optionsType = (args) => {
  return `@param {{ languageTag?: ${toStringUnion(args.languageTags) ?? "undefined"} }} options`;
};
function i(str) {
  var _a;
  str = str.replaceAll(/[^a-zA-Z0-9_]/g, "_");
  if ((_a = str[0]) == null ? void 0 : _a.match(/[0-9]/)) {
    str = "_" + str;
  }
  return str;
}
const compileMessage = (message, availableLanguageTags, sourceLanguageTag) => {
  if (!isValidJSIdentifier(message.id)) {
    throw new Error(
      `Cannot compile message with ID "${message.id}".

The message is not a valid JavaScript variable name. Please choose a different ID.

To detect this issue during linting, use the valid-js-identifier lint rule: https://inlang.com/m/teldgniy/messageLintRule-inlang-validJsIdentifier`
    );
  }
  const compiledPatterns = {};
  let params = {};
  for (const variant of message.variants) {
    if (compiledPatterns[variant.languageTag]) {
      throw new Error(
        `Duplicate language tag: ${variant.languageTag}. Multiple variants for one language tag are not supported in paraglide yet. `
      );
    }
    if (!availableLanguageTags.includes(variant.languageTag)) {
      throw new Error(
        `The language tag "${variant.languageTag}" is not included in the project's language tags but contained in of your messages. Please add the language tag to your project's language tags or delete the messages with the language tag "${variant.languageTag}" to avoid unexpected type errors.`
      );
    }
    const { compiled, params: variantParams } = compilePattern(variant.pattern);
    params = { ...params, ...variantParams };
    compiledPatterns[variant.languageTag] = compiled;
  }
  const resource = {
    index: messageIndexFunction({ message, params, availableLanguageTags })
  };
  for (const languageTag of availableLanguageTags) {
    const compiledPattern = compiledPatterns[languageTag];
    if (compiledPattern) {
      resource[languageTag] = messageFunction({ message, params, languageTag, compiledPattern });
    } else {
      const fallbackLanguage = lookup(languageTag, {
        languageTags: Object.keys(compiledPatterns),
        defaultLanguageTag: sourceLanguageTag
      });
      const compiledFallbackPattern = compiledPatterns[fallbackLanguage];
      resource[languageTag] = compiledFallbackPattern ? reexportMessage(message, fallbackLanguage) : messageIdFallback(message, languageTag);
    }
  }
  return resource;
};
const messageIndexFunction = (args) => {
  const hasParams = Object.keys(args.params).length > 0;
  return `/**
 * This message has been compiled by [inlang paraglide](https://inlang.com/m/gerre34r/library-inlang-paraglideJs).
 *
 * - Don't edit the message's code. Use [Sherlock (VS Code extension)](https://inlang.com/m/r7kp499g/app-inlang-ideExtension),
 *   the [web editor](https://inlang.com/m/tdozzpar/app-inlang-finkLocalizationEditor) instead, or edit the translation files manually.
 * 
 * - The params are NonNullable<unknown> because the inlang SDK does not provide information on the type of a param (yet).
 * 
 * ${paramsType(args.params, true)}
 * ${optionsType({ languageTags: args.availableLanguageTags })}
 * @returns {string}
 */
/* @__NO_SIDE_EFFECTS__ */
export const ${args.message.id} = (params ${hasParams ? "" : "= {}"}, options = {}) => {
	return {
${args.availableLanguageTags.sort((a, b) => a.localeCompare(b)).map((tag) => `		${isValidJSIdentifier(tag) ? tag : `"${tag}"`}: ${i(tag)}.${args.message.id}`).join(",\n")}
	}[options.languageTag ?? languageTag()](${hasParams ? "params" : ""})
}
${reexportAliases(args.message)}
`;
};
const messageFunction = (args) => {
  const hasParams = Object.keys(args.params).length > 0;
  return `
	
/**
 * ${paramsType(args.params, false)}
 * @returns {string}
 */
/* @__NO_SIDE_EFFECTS__ */
export const ${args.message.id} = (${hasParams ? "params" : ""}) => ${args.compiledPattern}
${reexportAliases(args.message)}
`;
};
function reexportMessage(message, fromLanguageTag) {
  const exports2 = [message.id];
  if (message.alias["default"] && message.id !== message.alias["default"]) {
    exports2.push(message.alias["default"]);
  }
  return `export { ${exports2.join(", ")} } from "./${fromLanguageTag}.js"`;
}
function messageIdFallback(message, languageTag) {
  return `/**
* Failed to resolve message ${message.id} for languageTag "${languageTag}". 
* @returns {string}
*/
/* @__NO_SIDE_EFFECTS__ */
export const ${message.id} = () => "${escapeForDoubleQuoteString(message.id)}"
${reexportAliases(message)}
`;
}
function reexportAliases(message) {
  let code = "";
  if (message.alias["default"] && message.id !== message.alias["default"]) {
    code += `
/**
 * Change the reference from the alias \`m.${message.alias["default"]}()\` to \`m.${message.id}()\`:
 * \`\`\`diff
 * - m.${message.alias["default"]}()
 * + m.${message.id}()
 * \`\`\`
 * ---
 * \`${message.alias["default"]}\` is an alias for the message \`${message.id}\`.
 * Referencing aliases instead of the message ID has downsides like:
 *
 * - The alias might be renamed in the future, breaking the code.
 * - Constant naming convention discussions.
 *
 * Read more about aliases and their downsides here 
 * @see inlang.com/link.
 * ---
 * @deprecated reference the message by id \`m.${message.id}()\` instead
 * 
 * @param {Parameters<typeof ${message.id}>} args
 * @returns {ReturnType<typeof ${message.id}>}
 */
export const ${message.alias["default"]} = (...args) => ${message.id}(...args);
`;
  }
  return code;
}
var main$1 = { exports: {} };
const name = "dotenv";
const version$1 = "16.4.5";
const description = "Loads environment variables from .env file";
const main = "lib/main.js";
const types = "lib/main.d.ts";
const exports = {
  ".": {
    types: "./lib/main.d.ts",
    require: "./lib/main.js",
    "default": "./lib/main.js"
  },
  "./config": "./config.js",
  "./config.js": "./config.js",
  "./lib/env-options": "./lib/env-options.js",
  "./lib/env-options.js": "./lib/env-options.js",
  "./lib/cli-options": "./lib/cli-options.js",
  "./lib/cli-options.js": "./lib/cli-options.js",
  "./package.json": "./package.json"
};
const scripts = {
  "dts-check": "tsc --project tests/types/tsconfig.json",
  lint: "standard",
  "lint-readme": "standard-markdown",
  pretest: "npm run lint && npm run dts-check",
  test: "tap tests/*.js --100 -Rspec",
  "test:coverage": "tap --coverage-report=lcov",
  prerelease: "npm test",
  release: "standard-version"
};
const repository = {
  type: "git",
  url: "git://github.com/motdotla/dotenv.git"
};
const funding = "https://dotenvx.com";
const keywords = [
  "dotenv",
  "env",
  ".env",
  "environment",
  "variables",
  "config",
  "settings"
];
const readmeFilename = "README.md";
const license = "BSD-2-Clause";
const devDependencies = {
  "@definitelytyped/dtslint": "^0.0.133",
  "@types/node": "^18.11.3",
  decache: "^4.6.1",
  sinon: "^14.0.1",
  standard: "^17.0.0",
  "standard-markdown": "^7.1.0",
  "standard-version": "^9.5.0",
  tap: "^16.3.0",
  tar: "^6.1.11",
  typescript: "^4.8.4"
};
const engines = {
  node: ">=12"
};
const browser = {
  fs: false
};
const require$$4 = {
  name,
  version: version$1,
  description,
  main,
  types,
  exports,
  scripts,
  repository,
  funding,
  keywords,
  readmeFilename,
  license,
  devDependencies,
  engines,
  browser
};
const fs = require$$0$1;
const path = require$$1$2;
const os = require$$0;
const crypto$1 = require$$3;
const packageJson = require$$4;
const version = packageJson.version;
const LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
function parse(src2) {
  const obj = {};
  let lines = src2.toString();
  lines = lines.replace(/\r\n?/mg, "\n");
  let match;
  while ((match = LINE.exec(lines)) != null) {
    const key = match[1];
    let value2 = match[2] || "";
    value2 = value2.trim();
    const maybeQuote = value2[0];
    value2 = value2.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
    if (maybeQuote === '"') {
      value2 = value2.replace(/\\n/g, "\n");
      value2 = value2.replace(/\\r/g, "\r");
    }
    obj[key] = value2;
  }
  return obj;
}
function _parseVault(options) {
  const vaultPath = _vaultPath(options);
  const result = DotenvModule.configDotenv({ path: vaultPath });
  if (!result.parsed) {
    const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
    err.code = "MISSING_DATA";
    throw err;
  }
  const keys = _dotenvKey(options).split(",");
  const length = keys.length;
  let decrypted;
  for (let i2 = 0; i2 < length; i2++) {
    try {
      const key = keys[i2].trim();
      const attrs = _instructions(result, key);
      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
      break;
    } catch (error) {
      if (i2 + 1 >= length) {
        throw error;
      }
    }
  }
  return DotenvModule.parse(decrypted);
}
function _log(message) {
  console.log(`[dotenv@${version}][INFO] ${message}`);
}
function _warn(message) {
  console.log(`[dotenv@${version}][WARN] ${message}`);
}
function _debug(message) {
  console.log(`[dotenv@${version}][DEBUG] ${message}`);
}
function _dotenvKey(options) {
  if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
    return options.DOTENV_KEY;
  }
  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
    return process.env.DOTENV_KEY;
  }
  return "";
}
function _instructions(result, dotenvKey) {
  let uri;
  try {
    uri = new URL(dotenvKey);
  } catch (error) {
    if (error.code === "ERR_INVALID_URL") {
      const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    throw error;
  }
  const key = uri.password;
  if (!key) {
    const err = new Error("INVALID_DOTENV_KEY: Missing key part");
    err.code = "INVALID_DOTENV_KEY";
    throw err;
  }
  const environment = uri.searchParams.get("environment");
  if (!environment) {
    const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
    err.code = "INVALID_DOTENV_KEY";
    throw err;
  }
  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
  const ciphertext = result.parsed[environmentKey];
  if (!ciphertext) {
    const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
    err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
    throw err;
  }
  return { ciphertext, key };
}
function _vaultPath(options) {
  let possibleVaultPath = null;
  if (options && options.path && options.path.length > 0) {
    if (Array.isArray(options.path)) {
      for (const filepath of options.path) {
        if (fs.existsSync(filepath)) {
          possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
        }
      }
    } else {
      possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
    }
  } else {
    possibleVaultPath = path.resolve(process.cwd(), ".env.vault");
  }
  if (fs.existsSync(possibleVaultPath)) {
    return possibleVaultPath;
  }
  return null;
}
function _resolveHome(envPath) {
  return envPath[0] === "~" ? path.join(os.homedir(), envPath.slice(1)) : envPath;
}
function _configVault(options) {
  _log("Loading env from encrypted .env.vault");
  const parsed = DotenvModule._parseVault(options);
  let processEnv = process.env;
  if (options && options.processEnv != null) {
    processEnv = options.processEnv;
  }
  DotenvModule.populate(processEnv, parsed, options);
  return { parsed };
}
function configDotenv(options) {
  const dotenvPath = path.resolve(process.cwd(), ".env");
  let encoding = "utf8";
  const debug2 = Boolean(options && options.debug);
  if (options && options.encoding) {
    encoding = options.encoding;
  } else {
    if (debug2) {
      _debug("No encoding is specified. UTF-8 is used by default");
    }
  }
  let optionPaths = [dotenvPath];
  if (options && options.path) {
    if (!Array.isArray(options.path)) {
      optionPaths = [_resolveHome(options.path)];
    } else {
      optionPaths = [];
      for (const filepath of options.path) {
        optionPaths.push(_resolveHome(filepath));
      }
    }
  }
  let lastError;
  const parsedAll = {};
  for (const path2 of optionPaths) {
    try {
      const parsed = DotenvModule.parse(fs.readFileSync(path2, { encoding }));
      DotenvModule.populate(parsedAll, parsed, options);
    } catch (e) {
      if (debug2) {
        _debug(`Failed to load ${path2} ${e.message}`);
      }
      lastError = e;
    }
  }
  let processEnv = process.env;
  if (options && options.processEnv != null) {
    processEnv = options.processEnv;
  }
  DotenvModule.populate(processEnv, parsedAll, options);
  if (lastError) {
    return { parsed: parsedAll, error: lastError };
  } else {
    return { parsed: parsedAll };
  }
}
function config(options) {
  if (_dotenvKey(options).length === 0) {
    return DotenvModule.configDotenv(options);
  }
  const vaultPath = _vaultPath(options);
  if (!vaultPath) {
    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
    return DotenvModule.configDotenv(options);
  }
  return DotenvModule._configVault(options);
}
function decrypt(encrypted, keyStr) {
  const key = Buffer.from(keyStr.slice(-64), "hex");
  let ciphertext = Buffer.from(encrypted, "base64");
  const nonce = ciphertext.subarray(0, 12);
  const authTag = ciphertext.subarray(-16);
  ciphertext = ciphertext.subarray(12, -16);
  try {
    const aesgcm = crypto$1.createDecipheriv("aes-256-gcm", key, nonce);
    aesgcm.setAuthTag(authTag);
    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
  } catch (error) {
    const isRange = error instanceof RangeError;
    const invalidKeyLength = error.message === "Invalid key length";
    const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
    if (isRange || invalidKeyLength) {
      const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    } else if (decryptionFailed) {
      const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
      err.code = "DECRYPTION_FAILED";
      throw err;
    } else {
      throw error;
    }
  }
}
function populate(processEnv, parsed, options = {}) {
  const debug2 = Boolean(options && options.debug);
  const override = Boolean(options && options.override);
  if (typeof parsed !== "object") {
    const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
    err.code = "OBJECT_REQUIRED";
    throw err;
  }
  for (const key of Object.keys(parsed)) {
    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
      if (override === true) {
        processEnv[key] = parsed[key];
      }
      if (debug2) {
        if (override === true) {
          _debug(`"${key}" is already defined and WAS overwritten`);
        } else {
          _debug(`"${key}" is already defined and was NOT overwritten`);
        }
      }
    } else {
      processEnv[key] = parsed[key];
    }
  }
}
const DotenvModule = {
  configDotenv,
  _configVault,
  _parseVault,
  config,
  decrypt,
  parse,
  populate
};
main$1.exports.configDotenv = DotenvModule.configDotenv;
main$1.exports._configVault = DotenvModule._configVault;
main$1.exports._parseVault = DotenvModule._parseVault;
var config_1 = main$1.exports.config = DotenvModule.config;
main$1.exports.decrypt = DotenvModule.decrypt;
main$1.exports.parse = DotenvModule.parse;
main$1.exports.populate = DotenvModule.populate;
main$1.exports = DotenvModule;
getPrivateEnvVariables();
function getPrivateEnvVariables() {
  if (typeof process === "undefined" || typeof process.cwd === "undefined") {
    return new Proxy(
      {},
      {
        get: () => {
          throw Error(
            "`process.env` is undefined. You are accessing private env variables in a non-node environment, likely the browser. Private env variables should never be exposed to the client. Use `publicEnv` instead."
          );
        }
      }
    );
  }
  const result = config_1({ path: "/home/runner/work/monorepo/monorepo/.env" });
  if (result.error) {
    return process.env;
  }
  return { ...process.env, ...result.parsed };
}
var define_PUBLIC_ENV_DEFINED_IN_BUILD_STEP_default = { PUBLIC_IS_DEV: "false", PUBLIC_GIT_PROXY_BASE_URL: "https://git.inlang.com", PUBLIC_POSTHOG_TOKEN: "phc_m5yJZCxjOGxF8CJvP5sQ3H0d76xpnLrsmiZHduT4jDz", PUBLIC_ALLOWED_AUTH_URLS: "https://inlang.com,https://manage.inlang.com,https://fink.inlang.com", PUBLIC_SERVER_BASE_URL: "https://inlang.com", PUBLIC_FINK_SENTRY_DSN: "https://00c275e250bb5a103cda12a76e5a7d98@o4504345873285120.ingest.sentry.io/4506599134461952", PUBLIC_WEBSITE_SENTRY_DSN: "https://6ba3cb3bad464dd9a7f8700ed636c07a@o4504345873285120.ingest.sentry.io/4504346044006400", PUBLIC_HCAPTCHA_SITEKEY: "353a039d-fc34-40a6-a81d-91720e8851b0", PUBLIC_LIX_GITHUB_APP_NAME: "inlang", PUBLIC_LIX_GITHUB_APP_CLIENT_ID: "Iv1.436da58906364f96", PUBLIC_POSTHOG_PROJECT_ID: "2161" };
const publicEnv = new Proxy({}, {
  get(target, prop) {
    if (typeof prop === "string" && prop.startsWith("PUBLIC_") === false) {
      throw new Error("Public env variables must start with PUBLIC_");
    } else if (typeof process !== "undefined" && (process == null ? void 0 : process.env[prop])) {
      return process.env[prop];
    } else if (
      // @ts-expect-error - {"isProduction":true} is defined in build step
      typeof define_PUBLIC_ENV_DEFINED_IN_BUILD_STEP_default !== "undefined" && // @ts-expect-error - {"isProduction":true} is defined in build step
      define_PUBLIC_ENV_DEFINED_IN_BUILD_STEP_default[prop]
    ) {
      return define_PUBLIC_ENV_DEFINED_IN_BUILD_STEP_default[prop];
    }
    return target[prop];
  }
});
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value2) => {
    if (typeof value2 === "bigint") {
      return value2.toString();
    }
    return value2;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
const ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i2 = 0;
          while (i2 < issue.path.length) {
            const el = issue.path[i2];
            const terminal = i2 === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i2++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
const errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (params) => {
  const { data, path: path2, errorMaps, issueData } = params;
  const fullPath = [...path2, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value: value2 } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value2.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value2.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value2.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value2.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
});
const DIRTY = (value2) => ({ status: "dirty", value: value2 });
const OK = (value2) => ({ status: "valid", value: value2 });
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
class ParseInputLazyPath {
  constructor(parent, value2, path2, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value2;
    this._path = path2;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description: description2 } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description: description2 };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description: description2 };
}
class ZodType {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check2, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check2(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check2, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check2(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description2) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description: description2
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[a-z][a-z0-9]*$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
};
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        if (input.data.length < check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check2.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        if (input.data.length > check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check2.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "length") {
        const tooBig = input.data.length > check2.value;
        const tooSmall = input.data.length < check2.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check2.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check2.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check2.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check2.message
            });
          }
          status.dirty();
        }
      } else if (check2.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "regex") {
        check2.regex.lastIndex = 0;
        const testResult = check2.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "trim") {
        input.data = input.data.trim();
      } else if (check2.kind === "includes") {
        if (!input.data.includes(check2.value, check2.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check2.value, position: check2.position },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check2.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check2.kind === "startsWith") {
        if (!input.data.startsWith(check2.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check2.value },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "endsWith") {
        if (!input.data.endsWith(check2.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check2.value },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "datetime") {
        const regex = datetimeRegex(check2);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "ip") {
        if (!isValidIP(input.data, check2.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check2) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value2, options) {
    return this._addCheck({
      kind: "includes",
      value: value2,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value2, message) {
    return this._addCheck({
      kind: "startsWith",
      value: value2,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value2, message) {
    return this._addCheck({
      kind: "endsWith",
      value: value2,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check2 of this._def.checks) {
      if (check2.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "min") {
        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check2.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value2, message) {
    return this.setLimit("min", value2, true, errorUtil.toString(message));
  }
  gt(value2, message) {
    return this.setLimit("min", value2, false, errorUtil.toString(message));
  }
  lte(value2, message) {
    return this.setLimit("max", value2, true, errorUtil.toString(message));
  }
  lt(value2, message) {
    return this.setLimit("max", value2, false, errorUtil.toString(message));
  }
  setLimit(kind, value2, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value: value2,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value2, message) {
    return this._addCheck({
      kind: "multipleOf",
      value: value2,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "multipleOf") {
        if (input.data % check2.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value2, message) {
    return this.setLimit("min", value2, true, errorUtil.toString(message));
  }
  gt(value2, message) {
    return this.setLimit("min", value2, false, errorUtil.toString(message));
  }
  lte(value2, message) {
    return this.setLimit("max", value2, true, errorUtil.toString(message));
  }
  lt(value2, message) {
    return this.setLimit("max", value2, false, errorUtil.toString(message));
  }
  setLimit(kind, value2, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value: value2,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value2, message) {
    return this._addCheck({
      kind: "multipleOf",
      value: value2,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        if (input.data.getTime() < check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check2.message,
            inclusive: true,
            exact: false,
            minimum: check2.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        if (input.data.getTime() > check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check2.message,
            inclusive: true,
            exact: false,
            maximum: check2.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check2) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i2) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i2) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value2 = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value2, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value2 = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value2, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types2, params) => {
  return new ZodUnion({
    options: types2,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
const getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return Object.keys(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};
class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value2 of discriminatorValues) {
        if (optionsMap.has(value2)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value2)}`);
        }
        optionsMap.set(value2, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}
class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value2], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value2, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value2 = await pair.value;
          if (key.status === "aborted" || value2.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value2.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value2.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value2 = pair.value;
        if (key.status === "aborted" || value2.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value2.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value2.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value2, params) => {
  return new ZodLiteral({
    value: value2,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values) {
    return ZodEnum.create(values);
  }
  exclude(values) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
  }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return {
          status: "dirty",
          value: ctx.data
        };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
const custom = (check2, params = {}, fatal) => {
  if (check2)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check2(data)) {
        const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
const late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
const NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});
z.object({
  PUBLIC_LIX_GITHUB_APP_CLIENT_ID: z.string(),
  PUBLIC_LIX_GITHUB_APP_NAME: z.string(),
  PUBLIC_GIT_PROXY_BASE_URL: z.string().startsWith("http").regex(/^(?!.*\/$).+$/, "Must not end with a slash").describe(`Must be a url including protocol`),
  PUBLIC_WEBSITE_SENTRY_DSN: z.string().optional().describe("DSN for Sentry (in the browser)"),
  PUBLIC_FINK_SENTRY_DSN: z.string().optional().describe("DSN for Sentry (in the fink)"),
  PUBLIC_POSTHOG_TOKEN: z.string().optional(),
  PUBLIC_POSTHOG_PROJECT_ID: z.string(),
  PUBLIC_SERVER_BASE_URL: z.string().url().regex(/^(?!.*\/$).+$/, "Must not end with a slash").describe("The base url of the server e.g. https://inlang.com"),
  PUBLIC_ALLOWED_AUTH_URLS: z.string().describe("List of allowed base urls eg https://inlang.com,https://manage.inlang.com"),
  PUBLIC_HCAPTCHA_SITEKEY: z.string().describe("The sitekey to https://www.hcaptcha.com/")
});
z.object({
  LIX_GITHUB_APP_CLIENT_SECRET: z.string(),
  SESSION_COOKIE_SECRET: z.string(),
  JWE_SECRET: z.string(),
  OPEN_AI_KEY: z.string().optional(),
  GOOGLE_TRANSLATE_API_KEY: z.string().optional(),
  SERVER_SENTRY_DSN: z.string().optional().describe("DSN for Sentry (on the server)"),
  ALGOLIA_ADMIN: z.string(),
  ALGOLIA_APPLICATION: z.string(),
  POSTHOG_API_KEY: z.string()
  // prefixed with INLANG_ because github doesn't allow env vars with GITHUB_ in ci/cd.
});
const posthog = new PostHog(publicEnv.PUBLIC_POSTHOG_TOKEN ?? "placeholder", {
  host: "https://eu.posthog.com",
  // Events are not captured if not immediately flushed.
  //
  // Posthog shouldn't batch events because CLI commands
  // are short-lived, see https://posthog.com/docs/libraries/node.
  flushAt: 1,
  flushInterval: 0,
  requestTimeout: 1e3
});
const telemetry = new Proxy(posthog, {
  get(target, prop) {
    if (!publicEnv.PUBLIC_POSTHOG_TOKEN) {
      return () => void 0;
    } else if (prop === "capture") {
      return capture;
    }
    return target[prop];
  }
});
function capture(args, projectId) {
  if (!publicEnv.PUBLIC_POSTHOG_TOKEN) {
    return;
  }
  const data = {
    ...args,
    distinctId: "unknown"
  };
  if (projectId) {
    data.groups = {
      project: projectId
    };
  }
  return posthog.capture(data);
}
const RelevantPackages = [
  "next",
  "solid",
  "solid-start",
  "svelte",
  "@sveltejs/kit",
  "@sveltejs/adaper-static",
  "@sveltejs/adapter-node",
  "@sveltejs/adapter-netlify",
  "@sveltejs/adapter-vercel",
  "@sveltejs/adapter-cloudflare-workers",
  "@sveltejs/adapter-auto",
  "vue",
  "nuxt",
  "react",
  "react-native",
  "remix",
  "astro",
  "flutter",
  "vite",
  "webpack",
  "rollup",
  "esbuild",
  "qwick",
  "parcel",
  "lit",
  "lit-html",
  "@angular/core"
];
function getStackInfo(packageJson2) {
  const packages = {};
  try {
    const pkg = packageJson2;
    const dependencies = (pkg == null ? void 0 : pkg.dependencies) ?? {};
    const devDependencies2 = (pkg == null ? void 0 : pkg.devDependencies) ?? {};
    const peerDependencies = (pkg == null ? void 0 : pkg.peerDependencies) ?? {};
    const allDependencies = { ...dependencies, ...devDependencies2, ...peerDependencies };
    for (const dependencyName of RelevantPackages) {
      if (dependencyName in allDependencies) {
        const dependencyVersion = allDependencies[dependencyName];
        if (typeof dependencyVersion !== "string")
          continue;
        packages[dependencyName] = dependencyVersion;
      }
    }
    return { packages };
  } catch (error) {
    return { packages };
  }
}
async function pathExists(filePath, nodeishFs) {
  try {
    await nodeishFs.stat(filePath);
    return true;
  } catch (error) {
    if (error.code === "ENOENT") {
      return false;
    } else {
      throw new Error(`Failed to check if path exists: ${error}`, { cause: error });
    }
  }
}
async function findPackageJson(fs2, cwd) {
  const potentialPackageJsonPath = nodePath__default.resolve(cwd, "package.json");
  const packageJsonExists = await pathExists(potentialPackageJsonPath, fs2);
  if (packageJsonExists)
    return potentialPackageJsonPath;
  return void 0;
}
async function getPackageJson(fs2, cwd) {
  const packageJsonPath = await findPackageJson(fs2, cwd);
  if (!packageJsonPath)
    return void 0;
  try {
    const packageJsonContents = await fs2.readFile(packageJsonPath, { encoding: "utf-8" });
    return JSON.parse(packageJsonContents);
  } catch {
    return void 0;
  }
}
const ignoreDirectory = `# ignore everything because the directory is auto-generated by inlang paraglide-js
# for more info visit https://inlang.com/m/gerre34r/paraglide-js
*
`;
const compile = async (args) => {
  const compiledMessages = args.messages.map(
    (message) => compileMessage(message, args.settings.languageTags, args.settings.sourceLanguageTag)
  );
  const pkgJson = await getPackageJson(nodeFsPromises, process.cwd());
  const stack = getStackInfo(pkgJson);
  telemetry.capture(
    {
      event: "PARAGLIDE-JS compile executed",
      properties: {
        stack
      }
    },
    args.projectId
  );
  const resources = {};
  for (const compiledMessage of compiledMessages) {
    for (const languageTag of Object.keys(compiledMessage)) {
      if (languageTag === "index")
        continue;
      if (!resources[languageTag])
        resources[languageTag] = "";
      resources[languageTag] += "\n\n" + compiledMessage[languageTag];
    }
  }
  const languagesWithMessages = new Set(Object.keys(resources));
  const languagesWithoutMessages = args.settings.languageTags.filter(
    (languageTag) => !languagesWithMessages.has(languageTag)
  );
  for (const languageTag of languagesWithoutMessages) {
    if (!resources[languageTag])
      resources[languageTag] = "\n\nexport {};";
  }
  telemetry.shutdown();
  return {
    // boilerplate files
    ".prettierignore": ignoreDirectory,
    ".gitignore": ignoreDirectory,
    ...Object.fromEntries(
      Object.entries(resources).map(([languageTag, content]) => [
        `messages/${languageTag}.js`,
        `
/* eslint-disable */
/** 
* This file contains language specific message functions for tree-shaking. 
* 
*! WARNING: Only import messages from this file if you want to manually
*! optimize your bundle. Else, import from the \`messages.js\` file. 
* 
* Your bundler will (in the future) automatically replace the index function 
* with a language specific message function in the build step. 
*/` + content
      ])
    ),
    // message index file
    "messages.js": `
/* eslint-disable */
import { languageTag } from "./runtime.js"
${Object.keys(resources).map((languageTag) => `import * as ${i(languageTag)} from "./messages/${languageTag}.js"`).join("\n")}

${compiledMessages.map((message) => message.index).join("\n\n")}
`,
    "runtime.js": `
/* eslint-disable */
/** @type {((tag: AvailableLanguageTag) => void) | undefined} */ 
let _onSetLanguageTag

/**
 * The project's source language tag.
 * 
 * @example
 *   if (newlySelectedLanguageTag === sourceLanguageTag){
 *     // do nothing as the source language tag is the default language
 *     return
 *   }
 */
export const sourceLanguageTag = "${args.settings.sourceLanguageTag}"

/**
 * The project's available language tags.
 * 
 * @example 
 *   if (availableLanguageTags.includes(userSelectedLanguageTag) === false){
 *     throw new Error("Language tag not available")
 *   }
 */
export const availableLanguageTags = /** @type {const} */ (${JSON.stringify(
      args.settings.languageTags
    )})

/**
 * Get the current language tag.
 * 
 * @example
 *   if (languageTag() === "de"){
 *     console.log("Germany ")
 *   } else if (languageTag() === "nl"){
 *     console.log("Netherlands ")
 *   }
 * 
 * @type {() => AvailableLanguageTag}
 */
export let languageTag = () => sourceLanguageTag

/**
 * Set the language tag.
 * 
 * @example 
 * 
 *   // changing to language 
 *   setLanguageTag("en")
 * 
 *   // passing a getter function also works. 
 *   // 
 *   // a getter function is useful for resolving a language tag 
 *   // on the server where every request has a different language tag
 *   setLanguageTag(() => {
 *     return request.langaugeTag
 *   }) 
 *
 * @param {AvailableLanguageTag | (() => AvailableLanguageTag)} tag
 */
export const setLanguageTag = (tag) => {
	if (typeof tag === "function") {
		languageTag = enforceLanguageTag(tag)
	} else {
		languageTag = enforceLanguageTag(() => tag)
	}
	// call the callback function if it has been defined
	if (_onSetLanguageTag !== undefined) {
		_onSetLanguageTag(languageTag())
	}
}

/**
 * Wraps an untrusted function and enforces that it returns a language tag.
 * @param {() => AvailableLanguageTag} unsafeLanguageTag
 * @returns {() => AvailableLanguageTag}
 */
function enforceLanguageTag(unsafeLanguageTag) {
	return () => {
		const tag = unsafeLanguageTag()
		if(!isAvailableLanguageTag(tag)) {
			throw new Error(\`languageTag() didn't return a valid language tag. Check your setLanguageTag call\`)
		}
		return tag
	}
}

/**
 * Set the \`onSetLanguageTag()\` callback function.
 *
 * The function can be used to trigger client-side side-effects such as 
 * making a new request to the server with the updated language tag, 
 * or re-rendering the UI on the client (SPA apps).  
 * 
 * - Don't use this function on the server (!).
 *   Triggering a side-effect is only useful on the client because a server-side
 *   environment doesn't need to re-render the UI. 
 *     
 * - The \`onSetLanguageTag()\` callback can only be defined once to avoid unexpected behavior.
 * 
 * @example
 *   // if you use inlang paraglide on the server, make sure 
 *   // to not call \`onSetLanguageTag()\` on the server
 *   if (isServer === false) {
 *     onSetLanguageTag((tag) => {
 *       // (for example) make a new request to the 
 *       // server with the updated language tag
 *       window.location.href = \`/\${tag}/\${window.location.pathname}\`
 *     })
 *   }
 *
 * @param {(languageTag: AvailableLanguageTag) => void} fn
 */
export const onSetLanguageTag = (fn) => {
	_onSetLanguageTag = fn
}

/**
 * Check if something is an available language tag.
 * 
 * @example
 * 	if (isAvailableLanguageTag(params.locale)) {
 * 		setLanguageTag(params.locale)
 * 	} else {
 * 		setLanguageTag("en")
 * 	}
 * 
 * @param {any} thing
 * @returns {thing is AvailableLanguageTag}
 */
export function isAvailableLanguageTag(thing) {
	return availableLanguageTags.includes(thing)
}

// ------ TYPES ------

/**
 * A language tag that is available in the project.
 * 
 * @example
 *   setLanguageTag(request.languageTag as AvailableLanguageTag)
 * 
 * @typedef {typeof availableLanguageTags[number]} AvailableLanguageTag
 */
`
  };
};
let previousOutputHash;
async function writeOutput(outputDirectory, output, fs2) {
  const currentOutputHash = hashOutput(output, outputDirectory);
  if (currentOutputHash === previousOutputHash)
    return;
  await fs2.access(outputDirectory).catch(async () => {
    await fs2.mkdir(outputDirectory, { recursive: true });
  });
  const files = await fs2.readdir(outputDirectory);
  await Promise.allSettled(
    files.map(async (file) => {
      await fs2.unlink(outputDirectory + "/" + file);
    })
  );
  await Promise.allSettled(
    Object.keys(output).map(async (filePath) => {
      const fullPath = nodePath__default.resolve(outputDirectory, filePath);
      const directory = nodePath__default.dirname(fullPath);
      await fs2.mkdir(directory, { recursive: true });
    })
  );
  await Promise.allSettled(
    Object.entries(output).map(async ([filePath, fileContent]) => {
      const fullPath = nodePath__default.resolve(outputDirectory, filePath);
      await fs2.writeFile(fullPath, fileContent);
    })
  );
  previousOutputHash = currentOutputHash;
}
function hashOutput(output, outputDirectory) {
  const hash2 = crypto$2.createHash("sha256");
  hash2.update(JSON.stringify(output));
  hash2.update(outputDirectory);
  return hash2.digest("hex");
}
consola.options = {
  ...consola.options,
  formatOptions: { date: false }
};
class Logger {
  constructor(options = { silent: false, prefix: true }) {
    this.options = options;
  }
  /**
   * Prints an empty line to the console.
   */
  ln() {
    if (this.options.silent)
      return this;
    console.log("");
    return this;
  }
  log(message) {
    if (this.options.silent)
      return this;
    const prefix = this.options.prefix ? colors.bold("[paraglide] ") : "";
    consola.log(prefix + message);
    return this;
  }
  info(message) {
    if (this.options.silent)
      return this;
    const prefix = this.options.prefix ? colors.bold(colors.blue("[paraglide] ")) : "";
    consola.info(prefix + message);
    return this;
  }
  success(message) {
    if (this.options.silent)
      return this;
    const prefix = this.options.prefix ? colors.bold(colors.green("[paraglide] ")) : "";
    consola.success(prefix + message);
    return this;
  }
  warn(message, ...args) {
    consola.warn(message, ...args);
    return this;
  }
  error(message, ...args) {
    consola.error(message, ...args);
    return this;
  }
  box(message, ...args) {
    if (this.options.silent)
      return this;
    consola.box(message, ...args);
    return this;
  }
}
export {
  Logger,
  getBasename as a,
  normalizePath as b,
  getDefaultExportFromCjs as c,
  compile,
  commonjsGlobal as d,
  getAugmentedNamespace as e,
  pathExists as f,
  getDirname as g,
  telemetry as h,
  findPackageJson as i,
  loadProject as l,
  normalPath as n,
  pattern as p,
  typebox as t,
  value$1 as v,
  writeOutput
};
