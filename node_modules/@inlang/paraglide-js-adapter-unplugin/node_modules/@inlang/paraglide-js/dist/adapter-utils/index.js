function negotiateLanguagePreferences(accept, availableLanguageTags) {
  if (availableLanguageTags.length === 0)
    return [];
  accept ||= "*";
  const acceptLanguageSpecs = parseAcceptLanguageHeader(accept);
  const priorities = availableLanguageTags.map(
    (languageTag, index) => getHighestLanguagePriority(languageTag, acceptLanguageSpecs, index)
  );
  return priorities.filter((prio) => prio.quality > 0).sort(comparePriorities).map((priority) => priority.languageTag);
}
function parseAcceptLanguageHeader(acceptLanguage) {
  const acceptableLanguageDefinitions = acceptLanguage.split(",");
  const specs = acceptableLanguageDefinitions.map((dfn) => dfn.trim()).map((dfn, index) => parseLanguage(dfn, index)).filter((maybeSpec) => Boolean(maybeSpec));
  return specs;
}
function parseLanguage(str, index) {
  const LANGUAGE_REGEXP = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
  const match = LANGUAGE_REGEXP.exec(str);
  if (!match)
    return void 0;
  const [, prefix, suffix, qualityMatch] = match;
  if (!prefix)
    throw new Error(`Invalid language tag: ${str}`);
  const full = suffix ? `${prefix}-${suffix}` : prefix;
  const quality = qualityMatch ? parseQuality(qualityMatch) ?? 1 : 1;
  return {
    prefix,
    suffix,
    quality,
    index,
    full
  };
}
function parseQuality(qualityMatch) {
  const params = qualityMatch.split(";");
  for (const param of params) {
    const [key, value] = param.split("=");
    if (key === "q" && value)
      return parseFloat(value);
  }
  return void 0;
}
function getHighestLanguagePriority(availableLanguageTag, acceptableLanguages, index) {
  let highestPriority = {
    languageTag: availableLanguageTag,
    index: 0,
    order: -1,
    quality: 0,
    specificity: 0
  };
  for (const acceptableLanguage of acceptableLanguages) {
    const priority = calculatePriority(availableLanguageTag, acceptableLanguage, index);
    if (!priority)
      continue;
    if (
      //compare the calculated priority to the highest priority ignoring quality.
      (highestPriority.specificity - priority.specificity || highestPriority.quality - priority.quality || highestPriority.order - priority.order) < 0
    ) {
      highestPriority = priority;
    }
  }
  return highestPriority;
}
function calculatePriority(language, spec, index) {
  const parsed = parseLanguage(language, 0);
  if (!parsed)
    return void 0;
  let specificity = 0;
  if (spec.full.toLowerCase() === parsed.full.toLowerCase()) {
    specificity |= 4;
  } else if (spec.prefix.toLowerCase() === parsed.full.toLowerCase()) {
    specificity |= 2;
  } else if (spec.full.toLowerCase() === parsed.prefix.toLowerCase()) {
    specificity |= 1;
  }
  if (specificity === 0 && spec.full !== "*") {
    return void 0;
  }
  return {
    languageTag: language,
    index,
    order: spec.index,
    quality: spec.quality,
    specificity
  };
}
function comparePriorities(a, b) {
  return b.quality - a.quality || b.specificity - a.specificity || a.order - b.order || a.index - b.index || 0;
}
function detectLanguageFromPath({
  path,
  availableLanguageTags,
  base
}) {
  base ??= "";
  if (base === "/")
    base = "";
  if (!path.startsWith(base)) {
    return void 0;
  }
  const pathWithoutBase = path.replace(base, "");
  const maybeLang = pathWithoutBase.split("/")[1];
  if (!maybeLang)
    return void 0;
  for (const lang of availableLanguageTags) {
    if (lang.toLowerCase() === maybeLang.toLowerCase()) {
      return lang;
    }
  }
  return void 0;
}
const param_pattern = /^(\[)?(\.\.\.)?(\w+)(?:=(\w+))?(\])?$/;
function parseRouteDefinition(id) {
  const params = [];
  const pattern = id === "/" ? /^\/$/ : new RegExp(
    `^${get_route_segments(id).map((segment) => {
      const rest_match = /^\[\.\.\.(\w+)(?:=(\w+))?\]$/.exec(segment);
      if (rest_match) {
        params.push({
          name: rest_match[1],
          matcher: rest_match[2],
          optional: false,
          rest: true,
          chained: true
        });
        return "(?:/(.*))?";
      }
      const optional_match = /^\[\[(\w+)(?:=(\w+))?\]\]$/.exec(segment);
      if (optional_match) {
        params.push({
          name: optional_match[1],
          matcher: optional_match[2],
          optional: true,
          rest: false,
          chained: true
        });
        return "(?:/([^/]+))?";
      }
      if (!segment) {
        return;
      }
      const parts = segment.split(/\[(.+?)\](?!\])/);
      const result = parts.map((content, i) => {
        if (i % 2) {
          if (content.startsWith("x+")) {
            return escape(String.fromCharCode(parseInt(content.slice(2), 16)));
          }
          if (content.startsWith("u+")) {
            return escape(
              String.fromCharCode(
                ...content.slice(2).split("-").map((code) => parseInt(code, 16))
              )
            );
          }
          const match = (
            /** @type {RegExpExecArray} */
            param_pattern.exec(content)
          );
          if (!match) {
            throw new Error(
              `Invalid param: ${content}. Params and matcher names can only have underscores and alphanumeric characters.`
            );
          }
          const [, is_optional, is_rest, name, matcher] = match;
          params.push({
            name,
            matcher,
            optional: !!is_optional,
            rest: !!is_rest,
            chained: is_rest ? i === 1 && parts[0] === "" : false
          });
          return is_rest ? "(.*?)" : is_optional ? "([^/]*)?" : "([^/]+?)";
        }
        return escape(content);
      }).join("");
      return "/" + result;
    }).join("")}/?$`
  );
  return { pattern, params };
}
function exec(match, params, matchers) {
  const result = {};
  const values = match.slice(1);
  const values_needing_match = values.filter((value) => value !== void 0);
  let buffered = 0;
  for (const [i, param] of params.entries()) {
    let value = values[i - buffered];
    if (param.chained && param.rest && buffered) {
      value = values.slice(i - buffered, i + 1).filter((s) => s).join("/");
      buffered = 0;
    }
    if (value === void 0) {
      if (param.rest)
        result[param.name] = "";
      continue;
    }
    if (param.matcher && !matchers[param.matcher]) {
      return void 0;
    }
    const matcher = matchers[param.matcher] ?? (() => true);
    if (matcher(value)) {
      result[param.name] = value;
      const next_param = params[i + 1];
      const next_value = values[i + 1];
      if (next_param && !next_param.rest && next_param.optional && next_value && param.chained) {
        buffered = 0;
      }
      if (!next_param && !next_value && Object.keys(result).length === values_needing_match.length) {
        buffered = 0;
      }
      continue;
    }
    if (param.optional && param.chained) {
      buffered++;
      continue;
    }
    return;
  }
  if (buffered)
    return;
  return result;
}
function escape(str) {
  return str.normalize().replace(/[[\]]/g, "\\$&").replace(/%/g, "%25").replace(/\//g, "%2[Ff]").replace(/\?/g, "%3[Ff]").replace(/#/g, "%23").replace(/[.*+?^${}()|\\]/g, "\\$&");
}
const basic_param_pattern = /\[(\[)?(\.\.\.)?(\w+?)(?:=(\w+))?\]\]?/g;
function resolveRoute(id, params) {
  const segments = get_route_segments(id);
  return "/" + segments.map(
    (segment) => segment.replace(basic_param_pattern, (_, optional, rest, name) => {
      const param_value = params[name];
      if (!param_value) {
        if (optional)
          return "";
        if (rest && param_value !== void 0)
          return "";
        throw new Error(`Missing parameter '${name}' in route ${id}`);
      }
      if (param_value.startsWith("/") || param_value.endsWith("/"))
        throw new Error(
          `Parameter '${name}' in route ${id} cannot start or end with a slash -- this would cause an invalid route like foo//bar`
        );
      return param_value;
    })
  ).filter(Boolean).join("/");
}
function bestMatch(canonicalPath, pathDefinitions, matchers) {
  let bestMatch2 = void 0;
  for (const pathDefinition of pathDefinitions) {
    const route = parseRouteDefinition(pathDefinition);
    const match = route.pattern.exec(removeTrailingSlash(canonicalPath));
    if (!match)
      continue;
    const params = exec(match, route.params, matchers);
    if (!params)
      continue;
    if (!bestMatch2) {
      bestMatch2 = { params, route, id: pathDefinition };
      continue;
    }
    const bestMatchNumParams = Object.keys(bestMatch2.route.params).length;
    const currentMatchNumParams = Object.keys(route.params).length;
    if (bestMatchNumParams < currentMatchNumParams) {
      continue;
    }
    if (bestMatchNumParams > currentMatchNumParams) {
      bestMatch2 = { params, route, id: pathDefinition };
      continue;
    }
    if (bestMatchNumParams === currentMatchNumParams && route.pattern.source.length < bestMatch2.route.pattern.source.length) {
      bestMatch2 = { params, route, id: pathDefinition };
    }
  }
  return bestMatch2 ? {
    id: bestMatch2.id,
    params: bestMatch2.params
  } : void 0;
}
function removeTrailingSlash(path) {
  return path.endsWith("/") ? path.slice(0, -1) : path;
}
function get_route_segments(route) {
  return route.slice(1).split("/");
}
function validatePathTranslations(pathTranslations, availableLanguageTags, matchers) {
  const issues = [];
  const expectedLanguages = new Set(availableLanguageTags);
  const availableMatchers = new Set(Object.keys(matchers));
  for (const path in pathTranslations) {
    if (!isValidPath(path)) {
      issues.push({
        path,
        message: "Path must start with a slash."
      });
      continue;
    }
    const { params: expectedParams } = parseRouteDefinition(path);
    const expectedMatchers = expectedParams.map((param) => param.matcher).filter(Boolean);
    for (const matcher of expectedMatchers) {
      if (!availableMatchers.has(matcher)) {
        issues.push({
          path,
          message: `Matcher ${matcher} is used but not available. Did you forget to pass it to createI18n?`
        });
      }
    }
    const translations = pathTranslations[path];
    if (!translations)
      continue;
    for (const [lang, translatedPath] of Object.entries(translations)) {
      if (!isValidPath(translatedPath)) {
        issues.push({
          path,
          message: `The translation for language ${lang} must start with a slash.`
        });
      }
      const { params: actualParams } = parseRouteDefinition(translatedPath);
      let paramsDontMatch = false;
      for (const param of expectedParams) {
        if (!actualParams.some((actualParam) => paramsAreEqual(param, actualParam))) {
          paramsDontMatch = true;
        }
      }
      if (expectedParams.length !== actualParams.length) {
        paramsDontMatch = true;
      }
      if (paramsDontMatch) {
        issues.push({
          path,
          message: `The translation for language ${lang} must have the same parameters as the canonical path.`
        });
      }
    }
    const translatedLanguages = new Set(Object.keys(translations));
    if (!isSubset(expectedLanguages, translatedLanguages)) {
      const missingLanguages = new Set(expectedLanguages);
      for (const lang of translatedLanguages) {
        missingLanguages.delete(lang);
      }
      issues.push({
        path,
        message: `The following languages are missing translations: ${[...missingLanguages].join(
          ", "
        )}`
      });
    }
  }
  return issues;
}
function paramsAreEqual(param1, param2) {
  return param1.chained == param2.chained && param1.matcher == param2.matcher && param1.name == param2.name && param1.optional == param2.optional && param1.rest == param2.rest;
}
function isValidPath(maybePath) {
  return maybePath.startsWith("/");
}
function isSubset(a, b) {
  for (const value of a) {
    if (!b.has(value))
      return false;
  }
  return true;
}
function prettyPrintPathDefinitionIssues(issues) {
  return issues.map((issue) => `${issue.path}: ${issue.message}`).join("\n");
}
const resolveUserPathDefinitions = (userTranslations, availableLanguageTags) => Object.fromEntries(
  Object.entries(userTranslations).map(([path, translation]) => [
    path,
    typeof translation === "object" ? translation : fromMessage(translation, availableLanguageTags)
  ])
);
const fromMessage = (message, availableLanguageTags) => Object.fromEntries(
  availableLanguageTags.map((languageTag) => [languageTag, message({}, { languageTag })])
);
export {
  bestMatch,
  detectLanguageFromPath,
  exec,
  negotiateLanguagePreferences,
  parseRouteDefinition,
  prettyPrintPathDefinitionIssues,
  resolveRoute,
  resolveUserPathDefinitions,
  validatePathTranslations
};
